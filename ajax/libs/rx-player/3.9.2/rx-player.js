!function webpackUniversalModuleDefinition(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define([], factory) : "object" == typeof exports ? exports.RxPlayer = factory() : root.RxPlayer = factory();
}(window, function() {
    /******/
    return function(modules) {
        // webpackBootstrap
        /******/ // The module cache
        /******/ var installedModules = {};
        /******/
        /******/ // The require function
        /******/        function __webpack_require__(moduleId) {
            /******/
            /******/ // Check if module is in cache
            /******/ if (installedModules[moduleId]) 
            /******/ return installedModules[moduleId].exports;
            /******/
            /******/ // Create a new module (and put it into the cache)
            /******/            var module = installedModules[moduleId] = {
                /******/ i: moduleId,
                /******/ l: !1,
                /******/ exports: {}
                /******/            };
            /******/
            /******/ // Execute the module function
            /******/            
            /******/
            /******/ // Return the exports of the module
            /******/ return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            /******/
            /******/ // Flag the module as loaded
            /******/ module.l = !0, module.exports;
            /******/        }
        /******/
        /******/
        /******/ // expose the modules object (__webpack_modules__)
        /******/        
        /******/
        /******/
        /******/ // Load entry module and return exports
        /******/ return __webpack_require__.m = modules, 
        /******/
        /******/ // expose the module cache
        /******/ __webpack_require__.c = installedModules, 
        /******/
        /******/ // define getter function for harmony exports
        /******/ __webpack_require__.d = function(exports, name, getter) {
            /******/ __webpack_require__.o(exports, name) || 
            /******/ Object.defineProperty(exports, name, {
                enumerable: !0,
                get: getter
            })
            /******/;
        }, 
        /******/
        /******/ // define __esModule on exports
        /******/ __webpack_require__.r = function(exports) {
            /******/ "undefined" != typeof Symbol && Symbol.toStringTag && 
            /******/ Object.defineProperty(exports, Symbol.toStringTag, {
                value: "Module"
            })
            /******/ , Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        }, 
        /******/
        /******/ // create a fake namespace object
        /******/ // mode & 1: value is a module id, require it
        /******/ // mode & 2: merge all properties of value into the ns
        /******/ // mode & 4: return value when already ns object
        /******/ // mode & 8|1: behave like require
        /******/ __webpack_require__.t = function(value, mode) {
            /******/ if (
            /******/ 1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
            /******/            if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
            /******/            var ns = Object.create(null);
            /******/            
            /******/ if (__webpack_require__.r(ns), 
            /******/ Object.defineProperty(ns, "default", {
                enumerable: !0,
                value: value
            }), 2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
            /******/            return ns;
            /******/        }, 
        /******/
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ __webpack_require__.n = function(module) {
            /******/ var getter = module && module.__esModule ? 
            /******/ function getDefault() {
                return module.default;
            } : 
            /******/ function getModuleExports() {
                return module;
            };
            /******/            
            /******/ return __webpack_require__.d(getter, "a", getter), getter;
            /******/        }, 
        /******/
        /******/ // Object.prototype.hasOwnProperty.call
        /******/ __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        }, 
        /******/
        /******/ // __webpack_public_path__
        /******/ __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 107);
        /******/    }
    /************************************************************************/
    /******/ ([ 
    /* 0 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/utils/noop.ts
                var noop = __webpack_require__(20), logger = new (
        /* */
        function() {
            function Logger() {
                this.error = noop.a, this.warn = noop.a, this.info = noop.a, this.debug = noop.a, 
                this.LEVELS = {
                    NONE: 0,
                    ERROR: 1,
                    WARNING: 2,
                    INFO: 3,
                    DEBUG: 4
                }, this.currentLevel = "NONE";
            }
            /**
   * @param {string} levelStr
   */            var _proto = Logger.prototype;
            return _proto.setLevel = function setLevel(levelStr) {
                var level, foundLevel = this.LEVELS[levelStr];
                this.currentLevel = foundLevel ? (
                // levelStr is a ILoggerLevel
                level = foundLevel, levelStr) : (
                // either 0 or not found
                level = 0, "NONE")
                /* tslint:disable no-invalid-this */
                /* tslint:disable no-console */ , this.error = level >= this.LEVELS.ERROR ? console.error.bind(console) : noop.a, 
                this.warn = level >= this.LEVELS.WARNING ? console.warn.bind(console) : noop.a, 
                this.info = level >= this.LEVELS.INFO ? console.info.bind(console) : noop.a, this.debug = level >= this.LEVELS.DEBUG ? console.log.bind(console) : noop.a;
            }, 
            /**
   * @returns {string}
   */
            _proto.getLevel = function getLevel() {
                return this.currentLevel;
            }, Logger;
        }())();
        // CONCATENATED MODULE: ./src/utils/logger.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        __webpack_exports__.a = logger;
    }, 
    /* 1 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "p", function() {
            return strToBytes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return bytesToStr;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return bytesToUTF16Str;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() {
            return hexToBytes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return bytesToHex;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return concat;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return be2toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return be3toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return be4toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return be8toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() {
            return le2toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() {
            return le4toi;
        }), 
        /* unused harmony export le8toi */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() {
            return itobe2;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() {
            return itobe4;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() {
            return itobe8;
        }), 
        /* unused harmony export itole2 */
        /* unused harmony export itole4 */
        /* unused harmony export itole8 */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return guidToUuid;
        });
        /* unused harmony export toBase64URL */
        /* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns Uint8Array from UTF16 string.
 * /!\ Take only the first byte from each UTF16 code.
 * @param {string} str
 * @returns {Uint8Array}
 */        function strToBytes(str) {
            for (var len = str.length, arr = new Uint8Array(len), i = 0; i < len; i++) arr[i] = 255 & str.charCodeAt(i);
            return arr;
        }
        /**
 * construct string from unicode values.
 * /!\ does not support non-UCS-2 values
 * @param {Uint8Array} bytes
 * @returns {string}
 */        function bytesToStr(bytes) {
            return String.fromCharCode.apply(null, bytes);
        }
        /**
 * construct string from unicode values.
 * Only use every other byte for each UTF-16 character.
 * /!\ does not support non-UCS-2 values
 * @param {Uint8Array} bytes
 * @returns {string}
 */        function bytesToUTF16Str(bytes) {
            for (var str = "", len = bytes.length, i = 0; i < len; i += 2) str += String.fromCharCode(bytes[i]);
            return str;
        }
        /**
 * Convert hex codes in a string form into the corresponding bytes.
 * @param {string} str
 * @returns {Uint8Array}
 * @throws TypeError - str.length is odd
 */        function hexToBytes(str) {
            for (var len = str.length, arr = new Uint8Array(len / 2), i = 0, j = 0; i < len; i += 2, 
            j++) arr[j] = 255 & parseInt(str.substr(i, 2), 16);
            return arr;
        }
        /**
 * Convert bytes into the corresponding hex string, with the possibility
 * to add a separator.
 * @param {Uint8Array} bytes
 * @param {string} [sep=""] - separator. Separate each two hex character.
 * @returns {string}
 */        function bytesToHex(bytes, sep) {
            void 0 === sep && (sep = "");
            for (var hex = "", i = 0; i < bytes.byteLength; i++) hex += (bytes[i] >>> 4).toString(16), 
            hex += (15 & bytes[i]).toString(16), sep.length && i < bytes.byteLength - 1 && (hex += sep);
            return hex;
        }
        /**
 * Returns a Uint8Array from the arguments given, in order:
 *   - if the next argument given is a number N set the N next bytes to 0.
 *   - else set the next bytes to the argument given.
 * @param {...(Number|Uint8Array)} args
 * @returns {Uint8Array}
 */        function concat() {
            for (var arg, l = arguments.length, i = -1, len = 0; ++i < l; ) len += "number" == typeof (arg = i < 0 || arguments.length <= i ? void 0 : arguments[i]) ? arg : arg.length;
            var arr = new Uint8Array(len), offset = 0;
            for (i = -1; ++i < l; ) "number" == typeof (arg = i < 0 || arguments.length <= i ? void 0 : arguments[i]) ? offset += arg : 0 < arg.length && (arr.set(arg, offset), 
            offset += arg.length);
            return arr;
        }
        /**
 * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be2toi(bytes, offset) {
            return (bytes[offset + 0] << 8) + (bytes[offset + 1] << 0);
        }
        /**
 * Translate groups of 3 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be3toi(bytes, offset) {
            return 65536 * bytes[offset + 0] + 256 * bytes[offset + 1] + bytes[offset + 2];
        }
        /**
 * Translate groups of 4 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be4toi(bytes, offset) {
            return 16777216 * bytes[offset + 0] + 65536 * bytes[offset + 1] + 256 * bytes[offset + 2] + bytes[offset + 3];
        }
        /**
 * Translate groups of 8 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be8toi(bytes, offset) {
            return 4294967296 * (16777216 * bytes[offset + 0] + 65536 * bytes[offset + 1] + 256 * bytes[offset + 2] + bytes[offset + 3]) + 16777216 * bytes[offset + 4] + 65536 * bytes[offset + 5] + 256 * bytes[offset + 6] + bytes[offset + 7];
        }
        /**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding big-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */        function itobe2(num) {
            return new Uint8Array([ num >>> 8 & 255, 255 & num ]);
        }
        /**
 * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian
 * bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */        function itobe4(num) {
            return new Uint8Array([ num >>> 24 & 255, num >>> 16 & 255, num >>> 8 & 255, 255 & num ]);
        }
        /**
 * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian
 * bytes.
 * /!\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus
 * leading to a "bad" value.
 * @param {Number} num
 * @returns {Uint8Array}
 */        function itobe8(num) {
            var l = num % 4294967296, h = (num - l) / 4294967296;
            return new Uint8Array([ h >>> 24 & 255, h >>> 16 & 255, h >>> 8 & 255, 255 & h, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l ]);
        }
        /**
 * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function le2toi(bytes, offset) {
            return (bytes[offset + 0] << 0) + (bytes[offset + 1] << 8);
        }
        /**
 * Translate groups of 4 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function le4toi(bytes, offset) {
            return bytes[offset + 0] + 256 * bytes[offset + 1] + 65536 * bytes[offset + 2] + 16777216 * bytes[offset + 3];
        }
        /**
 * Translate groups of 8 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        
        /**
 * @param {string} uuid
 * @returns {string}
 * @throws AssertionError - The uuid length is not 16
 */
        function guidToUuid(uuid) {
            Object(_assert__WEBPACK_IMPORTED_MODULE_0__.b)(16 === uuid.length, "UUID length should be 16");
            var buf = strToBytes(uuid), p1A = buf[0], p1B = buf[1], p1C = buf[2], p1D = buf[3], p2A = buf[4], p2B = buf[5], p3A = buf[6], p3B = buf[7], p4 = buf.subarray(8, 10), p5 = buf.subarray(10, 16), ord = new Uint8Array(16);
            return ord[0] = p1D, ord[1] = p1C, ord[2] = p1B, ord[3] = p1A, // swap32 BE -> LE
            ord[4] = p2B, ord[5] = p2A, // swap16 BE -> LE
            ord[6] = p3B, ord[7] = p3A, // swap16 BE -> LE
            ord.set(p4, 8), ord.set(p5, 10), bytesToHex(ord);
        }
        /**
 * Creates a base-64 encoded ASCII string from a string of binary data, with
 * possible trailing equal sign(s) stripped.
 * @param {string} str
 * @returns {string}
 */    }, 
    /* 2 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Configuration file for the whole player.
 * Feel free to tweak those values if you know what you're doing.
 *
 * Please not that you will need to re-build the whole project to take these
 * modifications into account.
 *
 * @type {Object}
 */
        /* harmony default export */        __webpack_exports__.a = {
            /**
   * Volume set on unMute if the volume is set to 0 and either:
   *   - mute has never been called before
   *   - mute has last been called while the volume was already set to 0 (either
   *     via setVolume, or a previous mute call)
   * @type {Number}
   */
            DEFAULT_UNMUTED_VOLUME: .1,
            /**
   * Default time interval after which a request will timeout, in ms.
   * @type {Number}
   */
            DEFAULT_REQUEST_TIMEOUT: 3e4,
            /**
   * Can be either:
   *   - "native": Subtitles are all displayed in a <track> element
   *   - "html": Subtitles are all displayed in a <div> separated from the video
   *     element. Can be useful to display richer TTML subtitles, for example.
   * @type {Object|null}
   */
            DEFAULT_TEXT_TRACK_MODE: "native",
            /**
   * Strategy to adopt when manually setting the current bitrate.
   * Can be either:
   *   - "seamless": transitions are very smooth but not immediate.
   *   - "direct": the quality switch happens immediately but to achieve that,
   *     the player will need to set a new MediaSource on the media element in
   *     some cases. This often leads to a black screen + unavailable APIs
   *     during a short moment.
   * @type {string}
   */
            DEFAULT_MANUAL_BITRATE_SWITCHING_MODE: "seamless",
            /**
   * If set to true, video through loadVideo will auto play by default
   * @type {Boolean}
   */
            DEFAULT_AUTO_PLAY: !1,
            /**
   * If set to false, "native" subtitles (in a <track> element) will be hidden
   * by default.
   * @type {Boolean}
   */
            DEFAULT_SHOW_NATIVE_SUBTITLE: !0,
            /**
   * Default buffer goal in seconds.
   * Once enough content has been downloaded to fill the buffer up to
   * ``current position + DEFAULT_WANTED_BUFFER_AHEAD", we will stop downloading
   * content.
   * @type {Number}
   */
            DEFAULT_WANTED_BUFFER_AHEAD: 30,
            /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _after_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
            DEFAULT_MAX_BUFFER_AHEAD: Infinity,
            /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _before_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
            DEFAULT_MAX_BUFFER_BEHIND: Infinity,
            /* tslint:disable no-object-literal-type-assertion */
            /**
   * Maximum possible buffer ahead for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
            MAXIMUM_MAX_BUFFER_AHEAD: {
                text: 18e3
            },
            /* tslint:enable no-object-literal-type-assertion */
            /* tslint:disable no-object-literal-type-assertion */
            /**
   * Maximum possible buffer behind for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
            MAXIMUM_MAX_BUFFER_BEHIND: {
                text: 18e3
            },
            /* tslint:enable no-object-literal-type-assertion */
            /**
   * Default bitrate ceils initially set as the first content begins.
   *
   * If no track is found with a bitrate inferior or equal to the
   * bitrate there, the one with the lowest bitrate will be taken instead.
   *
   * Set to 0 for the lowest bitrate, Infinity for the highest.
   *
   * These values are only useful for the first content played, as consecutive
   * play will always take the last set one.
   * @type {Object}
   */
            DEFAULT_INITIAL_BITRATES: {
                audio: 0,
                video: 0,
                other: 0
            },
            /* tslint:disable no-object-literal-type-assertion */
            /**
   * Default bitrate ceil initially set to dictate the maximum bitrate the
   * ABR manager can automatically switch to.
   *
   * If no track is found with a quality inferior or equal to the
   * bitrate there, the lowest bitrate will be taken instead.
   *
   * Set to Infinity to discard any limit in the ABR strategy.
   * @type {Object}
   */
            DEFAULT_MAX_BITRATES: {
                audio: Infinity,
                video: Infinity,
                other: Infinity
            },
            /* tslint:enable no-object-literal-type-assertion */
            /**
   * Delay after which, if the page is hidden, the user is considered inactive
   * on the current video.
   *
   * Allow to enforce specific optimizations when the page is not shown.
   * @see DEFAULT_THROTTLE_WHEN_HIDDEN
   * @type {Number}
   */
            INACTIVITY_DELAY: 6e4,
            /**
   * If true, if the player is in a "hidden" state for a delay specified by the
   * INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
            DEFAULT_THROTTLE_WHEN_HIDDEN: !1,
            /**
   * If true, the video representations you can switch to in adaptive mode
   * are limited by the video element's width.
   *
   * Basically in that case, we won't switch to a video Representation with
   * a width higher than the current width of the video HTMLElement.
   * @type {Boolean}
   */
            DEFAULT_LIMIT_VIDEO_WIDTH: !1,
            /**
   * Default initial live gap considered if no presentation delay has been
   * suggested, in seconds.
   * @type {Number}
   */
            DEFAULT_LIVE_GAP: 10,
            /**
   * Default value for a manifest's suggested presentation delay if not
   * specified in the manifest.
   * @type {Object}
   */
            DEFAULT_SUGGESTED_PRESENTATION_DELAY: {
                SMOOTH: 10,
                DASH: 10
            },
            /**
   * Maximum time, in seconds, the player should automatically skip when stalled
   * because of a discontinuity in the downloaded range.
   * @type {Number}
   */
            DISCONTINUITY_THRESHOLD: 1,
            /**
   * Ratio used to know if an already loaded segment should be re-buffered.
   * We re-load the given segment if the current one times that ratio is
   * inferior to the new one.
   * @type {Number}
   */
            BITRATE_REBUFFERING_RATIO: 1.5,
            /**
   * Those are used when a "QuotaExceededError" error is received after
   * appending a new segment in the source buffer.
   *
   * This error can arise when the browser's buffer is considered full.
   * In this case, the player goes into manual garbage collection (GC) mode.
   * @type {Object}
   */
            BUFFER_GC_GAPS: {
                /**
     * _Low_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received.
     * In seconds.
     * @type {Number}
     */
                CALM: 240,
                /**
     * _High_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received, if the low one does not clean up any buffer.
     * In seconds.
     * @type {Number}
     */
                BEEFY: 30
            },
            /**
   * The default number of times a manifest request will be re-performed
   * when loaded/refreshed if the request finishes on an error which
   * justify an retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
   * @type Number
   */
            DEFAULT_MAX_MANIFEST_REQUEST_RETRY: 4,
            /**
   * The default number of times a pipeline request will be re-performed when
   * on error which justify a retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
   * @type Number
   */
            DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR: 4,
            /**
   * Under some circonstances, we're able to tell that the user is offline (see
   * the compat files).
   * When this happens, and xhr requests fails due to an error event (you might
   * still be able to perform xhr offline, e.g. on localhost), you might want to
   * retry indefinitely or with a higher number of retry than if the error is
   * due to a CDN problem.
   *
   * A capped exponential backoff will still be used (like for an error code).
   * @type {Number}
   */
            DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE: Infinity,
            /**
   * Initial backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * This delay will then grow exponentally by power of twos (200, 400, 800
   * etc.)
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
            INITIAL_BACKOFF_DELAY_BASE: 200,
            /**
   * Maximum backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
            MAX_BACKOFF_DELAY_BASE: 3e3,
            /**
   * Minimum interval at which timeupdate events will be "constructed". This
   * variable is for the "regular" mediasource strategy (that is, not for the
   * directfile API.
   *
   * Those events are the base of various important mechanisms in the player:
   *   - set the clock for the buffer.
   *   - set the clock for the ABR strategy.
   *   - used to trigger positionUpdate events.
   *
   * This common logic is for performance reasons, as we call multiple browser's
   * APIs which are useful for most of these.
   *
   * Keep in mind this is the minimum interval. This logic will also be
   * triggered when various events of the media element are received.
   * @type {Number}
   */
            SAMPLING_INTERVAL_MEDIASOURCE: 1e3,
            /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.
   * @type {Number}
   */
            SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,
            /**
   * Minimum number of bytes sampled before we trust the estimate.
   * If we have not sampled much data, our estimate may not be accurate
   * enough to trust.
   * If the total of bytes sampled is less than this value, we use a
   * default estimate.
   * This specific value is based on experimentations.
   * @type {Number}
   */
            ABR_MINIMUM_TOTAL_BYTES: 15e4,
            /**
   * Minimum number of bytes, under which samples are discarded.
   * Our models do not include latency information, so connection startup time
   * (time to first byte) is considered part of the download time.
   * Because of this, we should ignore very small downloads which would cause
   * our estimate to be too low.
   * This specific value is based on experimentation.
   * @type {Number}
   */
            ABR_MINIMUM_CHUNK_SIZE: 16e3,
            /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is in
   * starvation mode.
   * @type {Number}
   */
            ABR_STARVATION_FACTOR: .72,
            /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is not
   * in starvation mode.
   * @type {Number}
   */
            ABR_REGULAR_FACTOR: .9,
            /**
   * If a SourceBuffer has less than ABR_STARVATION_GAP in seconds ahead of the
   * current position in its buffer, the ABR manager will go into starvation
   * mode.
   *
   * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is
   * reached.
   *
   * Under this starvation mode:
   *
   *   - the bandwidth considered will be a little lower than the one estimated
   *
   *   - the time the next important request take will be checked
   *     multiple times to detect when/if it takes too much time.
   *     If the request is considered too long, the bitrate will be hastily
   *     re-calculated from this single request.
   *
   * @type {Number}
   */
            ABR_STARVATION_GAP: 5,
            OUT_OF_STARVATION_GAP: 7,
            /**
   * This is a security to avoid going into starvation mode when the content is
   * ending (@see ABR_STARVATION_GAP).
   * Basically, we subtract that value from the global duration of the content
   * and we never enter "starvation mode" if the currently available buffer
   * (which equals to the current position + the available buffer ahead of it)
   * is equal or higher than this value.
   * @type {Number}
   */
            ABR_STARVATION_DURATION_DELTA: .1,
            /**
   * Half-life, in seconds for a fastly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic will react to the bandwidth
   * falling quickly.
   * Should be kept to a lower number than ABR_SLOW_EMA for coherency reasons.
   * @type {Number}
   */
            ABR_FAST_EMA: 2,
            /**
   * Half-life, in seconds for a slowly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic is going to react to recent
   * bandwidth variation, on the higher and on the lower side.
   * Should be kept to a higher number than ABR_FAST_EMA for coherency reasons.
   * @type {Number}
   */
            ABR_SLOW_EMA: 10,
            /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * seeking on an unbuffered part of the stream.
   * @type {Number}
   */
            RESUME_GAP_AFTER_SEEKING: 1.5,
            /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * the player was stalled due to a low readyState.
   * @type {Number}
   */
            RESUME_GAP_AFTER_NOT_ENOUGH_DATA: .5,
            /**
   * Number of seconds ahead in the buffer after which playback will resume
   * after the player went through a buffering step.
   * @type {Number}
   */
            RESUME_GAP_AFTER_BUFFERING: 5,
            /**
   * Maximum number of seconds in the buffer based on which a "stalling"
   * strategy will be considered:
   * The player will pause playback to get enough time building a sufficient
   * buffer. This mostly happen when seeking in an unbuffered part or when
   * buffering.
   * @type {Number}
   */
            STALL_GAP: .5,
            /**
   * Maximum difference allowed between a segment _announced_ start (what the
   * rx-player infers to be the starting time) and its _real_  current starting
   * time in the source buffer, in seconds, until the segment is considered
   * "incomplete".
   * Same for the ending time announced and its effective end time in the source
   * buffer.
   *
   * If the difference is bigger than this value, the segment will be considered
   * incomplete (e.g. considered as partially garbage-collected) and as such
   * might be re-downloaded.
   *
   * Keeping a too high value might lead to incomplete segments being wrongly
   * considered as complete (and thus not be re-downloaded, this could lead the
   * player to stall).
   * Note that in a worst-case scenario this can happen for the end of a segment
   * and the start of the contiguous segment, leading to a discontinuity two
   * times this value.
   *
   * Keeping a too low value might lead to re-downloading the same segment
   * multiple times (when the start and end times are badly estimated) as they
   * will wrongly believed to be partially garbage-collected.
   *
   * If a segment has a perfect continuity with a previous/following one in the
   * source buffer the start/end of it will not be checked. This allows to limit
   * the number of time this error-prone logic is applied.
   *
   * Note that in most cases, the rx-player's start and end times estimations
   * are __really__ close to what they really are in the sourcebuffer (we
   * usually have a difference in the order of 10^-7), as time information is
   * most of the time directly parsed from the media container.
   *
   * @type {Number}
   */
            MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: .12,
            /**
   * The maximum time, in seconds, the real buffered time in the sourcebuffer
   * can be superior to the time inferred by the rx-player (the "real" buffered
   * start inferior to the inferred start and the "real" buffered end superior
   * to the inferred end).
   * This limit allows to avoid resizing too much downloaded segments because
   * no other segment is linked to a buffered part.
   *
   * Setting a value too high can lead to parts of the source buffer being
   * linked to the wrong segments.
   * Setting a value too low can lead to parts of the source buffer not being
   * linked to the concerned segment.
   * @type {Number}
   */
            MAX_BUFFERED_DISTANCE: .1,
            /**
   * Minimum duration in seconds a segment should be into a buffered range to be
   * considered as part of that range.
   * Segments which have less than this amount of time "linked" to a buffered
   * range will be deleted.
   *
   * Setting a value too low can lead in worst-case scenarios to segments being
   * wrongly linked to the next or previous range it is truly linked too (if
   * those ranges are too close).
   *
   * Setting a value too high can lead to part of the buffer not being assigned
   * any segment. It also limits the minimum duration a segment can be.
   *
   * TODO As of now, this limits the minimum size a complete segment can be. A
   * better logic would be to also consider the duration of a segment. Though
   * this logic could lead to bugs with the current code.
   * @type {Number}
   */
            MINIMUM_SEGMENT_SIZE: .2,
            /**
   * Maximum interval at which text tracks are refreshed in an "html"
   * textTrackMode.
   *
   * The text tracks are also refreshed on various video events, this interval
   * will only trigger a refresh if none of those events was received during
   * that timespan.
   *
   * Note that if the TextTrack cue did not change between two intervals or
   * events, the DOM won't be refreshed.
   * The TextTrack cues structure is also optimized for fast retrieval.
   * We should thus not have much of a performance impact here if we set a low
   * interval.
   *
   * @type {Number}
   */
            MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 50,
            /**
   * The Buffer padding is a time offset from the current time that affects
   * the buffer.
   *
   * Basically, from a given time, if the current buffer gap number (time
   * between the current time and the end of the downloaded buffer) is between
   * the "high" and "low" described here (of the corresponding type), we won't
   * reschedule segments for that range.
   *
   * This is to avoid excessive re-buffering.
   *
   * Keeping the "high"s too low would increase the risk of re-bufferings.
   *
   * Keeping the "high"s too high would delay visible quality increase.
   *
   * @type {Object}
   */
            BUFFER_PADDING: {
                audio: {
                    high: 1,
                    low: 1
                },
                video: {
                    high: 3,
                    low: 2
                },
                other: {
                    high: 1,
                    low: 1
                }
            },
            /**
   * Segments of different types are downloaded by steps:
   *
   *   - first the audio/video/text Segments which are immediately needed
   *
   *   - then once every of those Segments have been downloaded, less-needed
   *     Segments
   *
   *   - then once every of those less-needed Segments have been downloaded,
   *     even less-needed Segments
   *
   *   - etc.
   *
   * This stepped download strategy allows to make a better use of network
   * ressources.
   *
   * For example, if more than sufficient audio buffer has been downloaded but
   * the immediately-needed video Segment is still pending its request, we might
   * be in a situation of rebuffering.
   * In that case, a better strategy would be to make sure every network
   * ressource is allocated for this video Segment before rebuffering happens.
   *
   * This is where those steps become useful.
   *
   * --
   *
   * The numbers defined in this Array describe what the steps are.
   *
   * Each number is linked to a distance from the current playing position, in
   * seconds.
   * Distances which will be used as limit points, from which a new step is
   * reached (see example).
   *
   * Note: You can set an empty array to deactivate the steps feature (every
   * Segments have the same priority).
   *
   * @example
   *
   * let's imagine the following SEGMENT_PRIORITIES_STEPS array:
   * [5, 11, 17, 25]
   *
   * To link each Segments to a corresponding priority (and thus to a specific
   * step), we have to consider the distance d between the current position and
   * the start time of the Segment.
   *
   * We have in our example 5 groups, which correspond to the following possible
   * d values:
   *   1. inferior to 5
   *   2. between 5 and 11
   *   3. between 11 and 17
   *   4. between 17 and 25
   *   5. superior to 25
   *
   * Segments corresponding to a lower-step will need to all be downloaded
   * before Segments of a newer step begin.
   *
   * @type {Array.<Number>}
   */
            SEGMENT_PRIORITIES_STEPS: [ 6, 14 ],
            /**
   * Robustnesses used in the {audio,video}Capabilities of the
   * MediaKeySystemConfiguration (EME).
   *
   * Only used for widevine keysystems.
   *
   * Defined in order of importance (first will be tested first etc.)
   * @type {Array.<string>}
   */
            EME_DEFAULT_WIDEVINE_ROBUSTNESSES: [ "HW_SECURE_ALL", "HW_SECURE_DECODE", "HW_SECURE_CRYPTO", "SW_SECURE_DECODE", "SW_SECURE_CRYPTO" ],
            /**
   * Link canonical key systems names to their respective reverse domain name,
   * used in the EME APIs.
   * This allows to have a simpler API, where users just need to set "widevine"
   * or "playready" as a keySystem.
   * @type {Object}
   */
            /* tslint:disable no-object-literal-type-assertion */
            EME_KEY_SYSTEMS: {
                clearkey: [ "webkit-org.w3.clearkey", "org.w3.clearkey" ],
                widevine: [ "com.widevine.alpha" ],
                playready: [ "com.microsoft.playready", "com.chromecast.playready", "com.youtube.playready" ]
            },
            /* tslint:enable no-object-literal-type-assertion */
            /**
   * Max simultaneous MediaKeySessions that will be kept as a cache to avoid
   * doing superfluous license requests.
   * If this number is reached, any new session creation will close the oldest
   * one.
   * @type {Number}
   */
            EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS: 50,
            /**
   * The player relies on browser events and properties to update its status to
   * "ENDED".
   *
   * Sadly in some cases, like in Chrome 54, this event is never triggered on
   * some contents probably due to a browser bug.
   *
   * This threshold resolves this issue by forcing the status to "ENDED" when:
   *   1. the player is stalling
   *   2. the absolute difference between current playback time and duration is
   *      under this value
   *
   * If set to null, this workaround is disabled and the player only relies on
   * browser events.
   *
   * @type {Number|null}
   */
            FORCED_ENDED_THRESHOLD: .001,
            /**
   * Maximum duration from the current position we will let in the buffer when
   * switching an Adaptation of a given type.
   *
   * For example, if we have ``text: { before: 1, after: 4 }``, it means that
   * when switching subtitles, we will let 1 second before and 4 second after
   * the current position in the previous language (until the new segments
   * overwrite it).
   * This is to allow smooth transitions and avoid de-synchronization that
   * can happen when removing the content being decoded.
   * @type {Object}
   */
            ADAPTATION_SWITCH_BUFFER_PADDINGS: {
                video: {
                    before: .5,
                    after: 1
                },
                audio: {
                    before: .5,
                    after: 2
                },
                text: {
                    before: 0,
                    after: 0
                },
                image: {
                    before: 0,
                    after: 0
                }
            }
        };
    }, 
    /* 3 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return __extends;
        });
        /* unused harmony export __assign */
        /* unused harmony export __rest */
        /* unused harmony export __decorate */
        /* unused harmony export __param */
        /* unused harmony export __metadata */
        /* unused harmony export __awaiter */
        /* unused harmony export __generator */
        /* unused harmony export __exportStar */
        /* unused harmony export __values */
        /* unused harmony export __read */
        /* unused harmony export __spread */
        /* unused harmony export __await */
        /* unused harmony export __asyncGenerator */
        /* unused harmony export __asyncDelegator */
        /* unused harmony export __asyncValues */
        /* unused harmony export __makeTemplateObject */
        /* unused harmony export __importStar */
        /* unused harmony export __importDefault */
        /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
        /* global Reflect, Promise */
        var extendStatics = function(d, b) {
            return (extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            })(d, b);
        };
        function __extends(d, b) {
            function __() {
                this.constructor = d;
            }
            extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
            new __());
        }
    }, 
    /* 4 */ 
    /* 5 */ , 
    /* 6 */
    /***/ , 
    /* 6 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /*
object-assign
(c) Sindre Sorhus
@license MIT
*/
        /* eslint-disable no-unused-vars */        var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
            if (null == val) throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(val);
        }
        module.exports = function shouldUseNative() {
            try {
                if (!Object.assign) return !1;
                // Detect buggy property enumeration order in older V8 versions.
                // https://bugs.chromium.org/p/v8/issues/detail?id=4118
                                var test1 = new String("abc");
 // eslint-disable-line no-new-wrappers
                                if (test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) return !1;
                // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                                for (var test2 = {}, i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
                if ("0123456789" !== Object.getOwnPropertyNames(test2).map(function(n) {
                    return test2[n];
                }).join("")) return !1;
                // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                                var test3 = {};
                return "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                    test3[letter] = letter;
                }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, test3)).join("");
            } catch (err) {
                // We don't expect any of the above to throw, but better to be safe.
                return !1;
            }
        }() ? Object.assign : function(target, source) {
            for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
                for (var key in from = Object(arguments[s])) hasOwnProperty.call(from, key) && (to[key] = from[key]);
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
                }
            }
            return to;
        };
    }, 
    /* 7 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return Subscriber;
        });
        /* unused harmony export SafeSubscriber */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49), _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62), _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15), _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(55), _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(44), _util_hostReportError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(52), Subscriber = /* */ function(_super) {
            function Subscriber(destinationOrNext, error, complete) {
                var _this = _super.call(this) || this;
                switch (_this.syncErrorValue = null, _this.syncErrorThrown = !1, _this.syncErrorThrowable = !1, 
                _this.isStopped = !1, _this._parentSubscription = null, arguments.length) {
                  case 0:
                    _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__.a;
                    break;

                  case 1:
                    if (!destinationOrNext) {
                        _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__.a;
                        break;
                    }
                    if ("object" == typeof destinationOrNext) {
                        destinationOrNext instanceof Subscriber ? (_this.syncErrorThrowable = destinationOrNext.syncErrorThrowable, 
                        (_this.destination = destinationOrNext).add(_this)) : (_this.syncErrorThrowable = !0, 
                        _this.destination = new SafeSubscriber(_this, destinationOrNext));
                        break;
                    }

                  default:
                    _this.syncErrorThrowable = !0, _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                }
                return _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(Subscriber, _super), Subscriber.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__.a] = function() {
                return this;
            }, Subscriber.create = function(next, error, complete) {
                var subscriber = new Subscriber(next, error, complete);
                return subscriber.syncErrorThrowable = !1, subscriber;
            }, Subscriber.prototype.next = function(value) {
                this.isStopped || this._next(value);
            }, Subscriber.prototype.error = function(err) {
                this.isStopped || (this.isStopped = !0, this._error(err));
            }, Subscriber.prototype.complete = function() {
                this.isStopped || (this.isStopped = !0, this._complete());
            }, Subscriber.prototype.unsubscribe = function() {
                this.closed || (this.isStopped = !0, _super.prototype.unsubscribe.call(this));
            }, Subscriber.prototype._next = function(value) {
                this.destination.next(value);
            }, Subscriber.prototype._error = function(err) {
                this.destination.error(err), this.unsubscribe();
            }, Subscriber.prototype._complete = function() {
                this.destination.complete(), this.unsubscribe();
            }, Subscriber.prototype._unsubscribeAndRecycle = function() {
                var _parent = this._parent, _parents = this._parents;
                return this._parent = null, this._parents = null, this.unsubscribe(), this.closed = !1, 
                this.isStopped = !1, this._parent = _parent, this._parents = _parents, this._parentSubscription = null, 
                this;
            }, Subscriber;
        }(_Subscription__WEBPACK_IMPORTED_MODULE_3__.a), SafeSubscriber = /* */ function(_super) {
            function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
                var next, _this = _super.call(this) || this;
                _this._parentSubscriber = _parentSubscriber;
                var context = _this;
                return Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.a)(observerOrNext) ? next = observerOrNext : observerOrNext && (next = observerOrNext.next, 
                error = observerOrNext.error, complete = observerOrNext.complete, observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_2__.a && (context = Object.create(observerOrNext), 
                Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.a)(context.unsubscribe) && _this.add(context.unsubscribe.bind(context)), 
                context.unsubscribe = _this.unsubscribe.bind(_this))), _this._context = context, 
                _this._next = next, _this._error = error, _this._complete = complete, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SafeSubscriber, _super), SafeSubscriber.prototype.next = function(value) {
                if (!this.isStopped && this._next) {
                    var _parentSubscriber = this._parentSubscriber;
                    _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? this.__tryOrSetError(_parentSubscriber, this._next, value) && this.unsubscribe() : this.__tryOrUnsub(this._next, value);
                }
            }, SafeSubscriber.prototype.error = function(err) {
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber, useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling;
                    if (this._error) useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? this.__tryOrSetError(_parentSubscriber, this._error, err) : this.__tryOrUnsub(this._error, err), 
                    this.unsubscribe(); else if (_parentSubscriber.syncErrorThrowable) useDeprecatedSynchronousErrorHandling ? (_parentSubscriber.syncErrorValue = err, 
                    _parentSubscriber.syncErrorThrown = !0) : Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err), 
                    this.unsubscribe(); else {
                        if (this.unsubscribe(), useDeprecatedSynchronousErrorHandling) throw err;
                        Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err);
                    }
                }
            }, SafeSubscriber.prototype.complete = function() {
                var _this = this;
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber;
                    if (this._complete) {
                        var wrappedComplete = function() {
                            return _this._complete.call(_this._context);
                        };
                        _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? this.__tryOrSetError(_parentSubscriber, wrappedComplete) : this.__tryOrUnsub(wrappedComplete), 
                        this.unsubscribe();
                    } else this.unsubscribe();
                }
            }, SafeSubscriber.prototype.__tryOrUnsub = function(fn, value) {
                try {
                    fn.call(this._context, value);
                } catch (err) {
                    if (this.unsubscribe(), _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling) throw err;
                    Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err);
                }
            }, SafeSubscriber.prototype.__tryOrSetError = function(parent, fn, value) {
                if (!_config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling) throw new Error("bad call");
                try {
                    fn.call(this._context, value);
                } catch (err) {
                    return _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling ? (parent.syncErrorValue = err, 
                    parent.syncErrorThrown = !0) : (Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err), 
                    !0);
                }
                return !1;
            }, SafeSubscriber.prototype._unsubscribe = function() {
                var _parentSubscriber = this._parentSubscriber;
                this._context = null, this._parentSubscriber = null, _parentSubscriber.unsubscribe();
            }, SafeSubscriber;
        }(Subscriber);
        /* harmony import */    }, 
    /* 8 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return addTextTrack;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return canPlay;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return clearElementSrc;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return hasEMEAPIs;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return hasLoadedMetadata;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return isCodecSupported;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return isOffline;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return isPlaybackStuck;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return isVTTCue;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() {
            return makeCue;
        }), 
        /* unused harmony export onSourceOpen$ */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() {
            return play$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() {
            return setElementSrc$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() {
            return shouldRenewMediaKeys;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() {
            return shouldUnsetMediaKeys;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() {
            return tryToChangeSourceBufferType;
        });
        /* harmony import */ var next_tick__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56), next_tick__WEBPACK_IMPORTED_MODULE_0___default = /* */ __webpack_require__.n(next_tick__WEBPACK_IMPORTED_MODULE_0__), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(136), rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9), rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(134), rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(142), _log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0), _utils_castToObservable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(18), _utils_eventemitter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(36), _utils_rx_tryCatch__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(50), _constants__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(24), _events__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(12), _eme__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(131);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the given codec is supported by the browser's MediaSource
 * implementation.
 * @returns {Boolean}
 */
        function isCodecSupported(codec) {
            return !!_constants__WEBPACK_IMPORTED_MODULE_10__.c && (
            /* tslint:disable no-unbound-method */
            "function" != typeof _constants__WEBPACK_IMPORTED_MODULE_10__.c.isTypeSupported || _constants__WEBPACK_IMPORTED_MODULE_10__.c.isTypeSupported(codec));
        }
        function isVTTCue(cue) {
            return "function" == typeof window.VTTCue && cue instanceof window.VTTCue;
        }
        /**
 * Returns true if the browser has the minimum needed EME APIs to decrypt a
 * content.
 * @returns {Boolean}
 */        function hasEMEAPIs() {
            return "function" == typeof _eme__WEBPACK_IMPORTED_MODULE_12__.b;
        }
        /**
 * Returns true if the current target require the media keys to be renewed on
 * each content.
 * @returns {Boolean}
 */        function shouldRenewMediaKeys() {
            return _constants__WEBPACK_IMPORTED_MODULE_10__.g;
        }
        /**
 * Returns true if the mediakeys associated to a media element should be
 * unset once the content is stopped.
 * Depends on the target.
 * @returns {Boolean}
 */        function shouldUnsetMediaKeys() {
            return _constants__WEBPACK_IMPORTED_MODULE_10__.g;
        }
        /**
 * Wait for the MediaSource's sourceopen event and emit. Emit immediatelly if
 * already received.
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */        
        /**
 * Returns an observable emitting a single time, as soon as a seek is possible
 * (the metatada are loaded).
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
        function hasLoadedMetadata(mediaElement) {
            return mediaElement.readyState >= _constants__WEBPACK_IMPORTED_MODULE_10__.d.HAVE_METADATA ? Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(null) : _events__WEBPACK_IMPORTED_MODULE_11__.i(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(1));
        }
        /**
 * Returns ane observable emitting a single time, as soon as a play is possible.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        function canPlay(mediaElement) {
            return mediaElement.readyState >= _constants__WEBPACK_IMPORTED_MODULE_10__.d.HAVE_ENOUGH_DATA ? Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(null) : Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(mediaElement, "canplay").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(1));
        }
 // old WebKit SourceBuffer implementation,
        // where a synchronous append is used instead of appendBuffer
                if (window.WebKitSourceBuffer && !window.WebKitSourceBuffer.prototype.addEventListener) {
            var sourceBufferWebkitProto = window.WebKitSourceBuffer.prototype;
            for (var fnName in _utils_eventemitter__WEBPACK_IMPORTED_MODULE_8__.a.prototype) _utils_eventemitter__WEBPACK_IMPORTED_MODULE_8__.a.prototype.hasOwnProperty(fnName) && (sourceBufferWebkitProto[fnName] = _utils_eventemitter__WEBPACK_IMPORTED_MODULE_8__.a.prototype[fnName]);
            sourceBufferWebkitProto._listeners = [], sourceBufferWebkitProto.__emitUpdate = function(eventName, val) {
                var _this = this;
                next_tick__WEBPACK_IMPORTED_MODULE_0___default()(function() {
                    /* tslint:disable no-invalid-this */
                    _this.trigger(eventName, val), _this.updating = !1, _this.trigger("updateend");
                });
            }, sourceBufferWebkitProto.appendBuffer = function(data) {
                /* tslint:disable no-invalid-this */
                if (this.updating) throw new Error("updating");
                this.trigger("updatestart"), this.updating = !0;
                try {
                    this.append(data);
                } catch (error) {
                    return void this.__emitUpdate("error", error);
                }
                this.__emitUpdate("update");
            };
        }
        /**
 * Add text track to the given media element.
 * Returns an object with the following properties:
 *   - track {TextTrack}: the added text track
 *   - trackElement {HTMLElement|undefined}: the added <track> element.
 *     undefined if no trackElement was added.
 * @param {HTMLMediaElement} mediaElement
 * @param {Boolean} hidden
 * @returns {Object}
 */        function addTextTrack(mediaElement, hidden) {
            var track, trackElement;
            if (_constants__WEBPACK_IMPORTED_MODULE_10__.g) {
                var tracksLength = mediaElement.textTracks.length;
                (track = 0 < tracksLength ? mediaElement.textTracks[tracksLength - 1] : mediaElement.addTextTrack("subtitles")).mode = hidden ? track.HIDDEN : track.SHOWING;
            } else 
            // there is no removeTextTrack method... so we need to reuse old
            // text-tracks objects and clean all its pending cues
            trackElement = document.createElement("track"), mediaElement.appendChild(trackElement), 
            track = trackElement.track, trackElement.kind = "subtitles", track.mode = hidden ? "hidden" : "showing";
            return {
                track: track,
                trackElement: trackElement
            };
        }
        /**
 * firefox fix: sometimes the stream can be stalled, even if we are in a
 * buffer.
 *
 * TODO This seems to be about an old Firefox version. Delete it?
 * @param {number} time
 * @param {Object|null} currentRange
 * @param {string} state
 * @param {Boolean} isStalled
 * @returns {Boolean}
 */        function isPlaybackStuck(time, currentRange, state, isStalled) {
            // freeze threshold in seconds
            return _constants__WEBPACK_IMPORTED_MODULE_10__.f && isStalled && "timeupdate" === state && !!currentRange && 10 < currentRange.end - time;
        }
        /**
 * Clear element's src attribute.
 *
 * On IE11, element.src = "" is not sufficient as it
 * does not clear properly the current MediaKey Session.
 * Microsoft recommended to use element.removeAttr("src").
 * @param {HTMLMediaElement} element
 */        function clearElementSrc(element) {
            element.src = "", element.removeAttribute("src");
        }
        /**
 * Set an URL to the element's src.
 * Emit ``undefined`` when done.
 * Unlink src on unsubscription.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {string} url
 * @returns {Observable}
 */        function setElementSrc$(mediaElement, url) {
            return rxjs__WEBPACK_IMPORTED_MODULE_3__.a.create(function(observer) {
                return _log__WEBPACK_IMPORTED_MODULE_6__.a.info("Setting URL to Element", url, mediaElement), 
                mediaElement.src = url, observer.next(void 0), function() {
                    clearElementSrc(mediaElement);
                };
            });
        }
        /**
 * Some browsers have a builtin API to know if it's connected at least to a
 * LAN network, at most to the internet.
 *
 * /!\ This feature can be dangerous as you can both have false positives and
 * false negatives.
 *
 * False positives:
 *   - you can still play local contents (on localhost) if isOffline == true
 *   - on some browsers isOffline might be true even if we're connected to a LAN
 *     or a router (it would mean we're just not able to connect to the
 *     Internet). So we can eventually play LAN contents if isOffline == true
 *
 * False negatives:
 *   - in some cases, we even might have isOffline at false when we do not have
 *     any connection:
 *       - in browsers that do not support the feature
 *       - in browsers running in some virtualization softwares where the
 *         network adapters are always connected.
 *
 * Use with these cases in mind.
 * @returns {Boolean}
 */        function isOffline() {
            /* tslint:disable no-boolean-literal-compare */
            return !1 === navigator.onLine;
            /* tslint:enable no-boolean-literal-compare */        }
        /**
 * Creates a cue using the best platform-specific interface available.
 *
 * @param {Number} startTime
 * @param {Number} endTime
 * @param {string} payload
 * @returns {VTTCue|TextTrackCue|null} Text track cue or null if the parameters
 * were invalid.
 */        function makeCue(startTime, endTime, payload) {
            if (!_constants__WEBPACK_IMPORTED_MODULE_10__.e) throw new Error("VTT cues not supported in your target");
            return endTime <= startTime ? (
            // IE/Edge will throw in this case.
            // See issue #501
            _log__WEBPACK_IMPORTED_MODULE_6__.a.warn("Invalid cue times: " + startTime + " - " + endTime), 
            null) : new _constants__WEBPACK_IMPORTED_MODULE_10__.e(startTime, endTime, payload);
        }
        /**
 * Call play on the media element on subscription and return the response as an
 * observable.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        function play$(mediaElement) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__.a)(function() {
                // mediaElement.play is not always a Promise. In the improbable case it
                // throws, I prefer still to catch to return the error wrapped in an
                // Observable
                return Object(_utils_rx_tryCatch__WEBPACK_IMPORTED_MODULE_9__.a)(function() {
                    return Object(_utils_castToObservable__WEBPACK_IMPORTED_MODULE_7__.a)(mediaElement.play());
                });
            });
        }
        /**
 * If the changeType MSE API is implemented, update the current codec of the
 * SourceBuffer and return true if it succeeded.
 * In any other cases, return false.
 * @param {Object} sourceBuffer
 * @param {string} codec
 * @returns {boolean}
 */        function tryToChangeSourceBufferType(sourceBuffer, codec) {
            if ("function" != typeof sourceBuffer.changeType) return !1;
            try {
                sourceBuffer.changeType(codec);
            } catch (e) {
                return _log__WEBPACK_IMPORTED_MODULE_6__.a.warn("Could not call 'changeType' on the given SourceBuffer:", e), 
                !1;
            }
            return !0;
        }
        /***/    }, 
    /* 9 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
                var Subscriber = __webpack_require__(7);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/canReportError.js
        /** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */        function canReportError(observer) {
            for (;observer; ) {
                var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
                if (closed_1 || isStopped) return !1;
                observer = destination && destination instanceof Subscriber.a ? destination : null;
            }
            return !0;
        }
        //# sourceMappingURL=canReportError.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
                var rxSubscriber = __webpack_require__(55), Observer = __webpack_require__(62);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observer.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/toSubscriber.js
        /** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
        function toSubscriber(nextOrObserver, error, complete) {
            if (nextOrObserver) {
                if (nextOrObserver instanceof Subscriber.a) return nextOrObserver;
                if (nextOrObserver[rxSubscriber.a]) return nextOrObserver[rxSubscriber.a]();
            }
            return nextOrObserver || error || complete ? new Subscriber.a(nextOrObserver, error, complete) : new Subscriber.a(Observer.a);
        }
        //# sourceMappingURL=toSubscriber.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js
                var observable = __webpack_require__(48), noop = __webpack_require__(46);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/noop.js
                function pipeFromArray(fns) {
            return fns ? 1 === fns.length ? fns[0] : function piped(input) {
                return fns.reduce(function(prev, fn) {
                    return fn(prev);
                }, input);
            } : noop.a;
        }
        //# sourceMappingURL=pipe.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/config.js
                var config = __webpack_require__(44);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return Observable_Observable;
        });
        /** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
        var Observable_Observable = /* */ function() {
            function Observable(subscribe) {
                this._isScalar = !1, subscribe && (this._subscribe = subscribe);
            }
            return Observable.prototype.lift = function(operator) {
                var observable = new Observable();
                return observable.source = this, observable.operator = operator, observable;
            }, Observable.prototype.subscribe = function(observerOrNext, error, complete) {
                var operator = this.operator, sink = toSubscriber(observerOrNext, error, complete);
                if (operator ? operator.call(sink, this.source) : sink.add(this.source || config.a.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink)), 
                config.a.useDeprecatedSynchronousErrorHandling && sink.syncErrorThrowable && (sink.syncErrorThrowable = !1, 
                sink.syncErrorThrown)) throw sink.syncErrorValue;
                return sink;
            }, Observable.prototype._trySubscribe = function(sink) {
                try {
                    return this._subscribe(sink);
                } catch (err) {
                    config.a.useDeprecatedSynchronousErrorHandling && (sink.syncErrorThrown = !0, sink.syncErrorValue = err), 
                    canReportError(sink) ? sink.error(err) : console.warn(err);
                }
            }, Observable.prototype.forEach = function(next, promiseCtor) {
                var _this = this;
                return new (promiseCtor = getPromiseCtor(promiseCtor))(function(resolve, reject) {
                    var subscription;
                    subscription = _this.subscribe(function(value) {
                        try {
                            next(value);
                        } catch (err) {
                            reject(err), subscription && subscription.unsubscribe();
                        }
                    }, reject, resolve);
                });
            }, Observable.prototype._subscribe = function(subscriber) {
                var source = this.source;
                return source && source.subscribe(subscriber);
            }, Observable.prototype[observable.a] = function() {
                return this;
            }, Observable.prototype.pipe = function() {
                for (var operations = [], _i = 0; _i < arguments.length; _i++) operations[_i] = arguments[_i];
                return 0 === operations.length ? this : pipeFromArray(operations)(this);
            }, Observable.prototype.toPromise = function(promiseCtor) {
                var _this = this;
                return new (promiseCtor = getPromiseCtor(promiseCtor))(function(resolve, reject) {
                    var value;
                    _this.subscribe(function(x) {
                        return value = x;
                    }, function(err) {
                        return reject(err);
                    }, function() {
                        return resolve(value);
                    });
                });
            }, Observable.create = function(subscribe) {
                return new Observable(subscribe);
            }, Observable;
        }();
        function getPromiseCtor(promiseCtor) {
            if (promiseCtor || (promiseCtor = config.a.Promise || Promise), !promiseCtor) throw new Error("no Promise impl found");
            return promiseCtor;
        }
        //# sourceMappingURL=Observable.js.map
        /***/    }, 
    /* 10 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Initial features object, with no feature activated by default.
 * @type {Object}
 */        
        /* harmony default export */ __webpack_exports__.a = {
            transports: {},
            imageBuffer: null,
            imageParser: null,
            nativeTextTracksBuffer: null,
            nativeTextTracksParsers: {},
            htmlTextTracksBuffer: null,
            htmlTextTracksParsers: {},
            emeManager: null,
            directfile: null
        };
    }, 
    /* 11 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = function find(array, predicate, context) {
            if ("function" == typeof Array.prototype.find) return array.find(predicate, context);
            context = context || this;
            var i, length = array.length;
            if ("function" != typeof predicate) throw new TypeError(predicate + " is not a function");
            for (i = 0; i < length; i++) if (predicate.call(context, array[i], i, array)) return array[i];
        };
    }, 
    /* 12 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEvent.js
                var fromEvent = __webpack_require__(136), Observable = __webpack_require__(9), noop = __webpack_require__(46), NEVER = /* */ new Observable.a(noop.a);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                //# sourceMappingURL=never.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
        var merge = __webpack_require__(135), interval = __webpack_require__(139), map = __webpack_require__(42), filter = __webpack_require__(137), tslib_es6 = __webpack_require__(3), Subscriber = __webpack_require__(7), scheduler_async = __webpack_require__(34);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/debounceTime.js
        /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
        function debounceTime(dueTime, scheduler) {
            return void 0 === scheduler && (scheduler = scheduler_async.a), function(source) {
                return source.lift(new DebounceTimeOperator(dueTime, scheduler));
            };
        }
        var DebounceTimeOperator = /* */ function() {
            function DebounceTimeOperator(dueTime, scheduler) {
                this.dueTime = dueTime, this.scheduler = scheduler;
            }
            return DebounceTimeOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new debounceTime_DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
            }, DebounceTimeOperator;
        }(), debounceTime_DebounceTimeSubscriber = /* */ function(_super) {
            function DebounceTimeSubscriber(destination, dueTime, scheduler) {
                var _this = _super.call(this, destination) || this;
                return _this.dueTime = dueTime, _this.scheduler = scheduler, _this.debouncedSubscription = null, 
                _this.lastValue = null, _this.hasValue = !1, _this;
            }
            return tslib_es6.a(DebounceTimeSubscriber, _super), DebounceTimeSubscriber.prototype._next = function(value) {
                this.clearDebounce(), this.lastValue = value, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
            }, DebounceTimeSubscriber.prototype._complete = function() {
                this.debouncedNext(), this.destination.complete();
            }, DebounceTimeSubscriber.prototype.debouncedNext = function() {
                if (this.clearDebounce(), this.hasValue) {
                    var lastValue = this.lastValue;
                    this.lastValue = null, this.hasValue = !1, this.destination.next(lastValue);
                }
            }, DebounceTimeSubscriber.prototype.clearDebounce = function() {
                var debouncedSubscription = this.debouncedSubscription;
                null !== debouncedSubscription && (this.remove(debouncedSubscription), debouncedSubscription.unsubscribe(), 
                this.debouncedSubscription = null);
            }, DebounceTimeSubscriber;
        }(Subscriber.a);
        function dispatchNext(subscriber) {
            subscriber.debouncedNext();
        }
        //# sourceMappingURL=debounceTime.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
                var startWith = __webpack_require__(138), distinctUntilChanged = __webpack_require__(140), config = __webpack_require__(2), constants = __webpack_require__(24);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
                // CONCATENATED MODULE: ./src/compat/events.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return isInBackground$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() {
            return videoWidth$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() {
            return events_onPlayPause$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() {
            return events_onTextTrackChanges$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return onLoadedMetadata$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() {
            return onSeeking$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() {
            return onSeeked$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return onEnded$;
        }), 
        /* unused harmony export onTimeUpdate$ */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return onFullscreenChange$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() {
            return onSourceOpen$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() {
            return onUpdate$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() {
            return onRemoveSourceBuffers$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return onEncrypted$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return onKeyMessage$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return onKeyAdded$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return onKeyError$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return onKeyStatusesChange$;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file provides browser-agnostic event listeners under the form of
 * RxJS Observables
 */
        var BROWSER_PREFIXES = [ "", "webkit", "moz", "ms" ], INACTIVITY_DELAY = config.a.INACTIVITY_DELAY, pixelRatio = window.devicePixelRatio || 1;
        /**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {string} eventNameSuffix
 * @returns {Boolean}
 */
        function isEventSupported(element, eventNameSuffix) {
            var clone = document.createElement(element.tagName), eventName = "on" + eventNameSuffix;
            return eventName in clone || (clone.setAttribute(eventName, "return;"), "function" == typeof clone[eventName]);
        }
        /**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {Array.<string>} eventNames
 * @returns {string|undefined}
 */        function findSupportedEvent(element, eventNames) {
            return eventNames.filter(function(name) {
                return isEventSupported(element, name);
            })[0];
        }
        /**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Array.<string>}
 */        function eventPrefixed(eventNames, prefixes) {
            return eventNames.reduce(function(parent, name) {
                return parent.concat((prefixes || BROWSER_PREFIXES).map(function(p) {
                    return p + name;
                }));
            }, []);
        }
        /**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Observable}
 */        function compatibleListener(eventNames, prefixes) {
            var mem, prefixedEvents = eventPrefixed(eventNames, prefixes);
            return function(element) {
                // if the element is a HTMLElement we can detect
                // the supported event, and memoize it in `mem`
                return element instanceof constants.a ? (void 0 === mem && (mem = findSupportedEvent(element, prefixedEvents)), 
                mem ? Object(fromEvent.a)(element, mem) : NEVER) : merge.a.apply(void 0, prefixedEvents.map(function(eventName) {
                    return Object(fromEvent.a)(element, eventName);
                }));
 // otherwise, we need to listen to all the events
                // and merge them into one observable sequence
                        };
        }
        /**
 * Returns an observable:
 *   - emitting true when the visibility of document changes to hidden
 *   - emitting false when the visibility of document changes to visible
 * @returns {Observable}
 */        function visibilityChange() {
            var prefix, doc = document;
            null != doc.hidden ? prefix = "" : null != doc.mozHidden ? prefix = "moz" : null != doc.msHidden ? prefix = "ms" : null != doc.webkitHidden && (prefix = "webkit");
            var hidden = prefix ? prefix + "Hidden" : "hidden", visibilityChangeEvent = prefix + "visibilitychange";
            return Object(fromEvent.a)(document, visibilityChangeEvent).pipe(Object(map.a)(function() {
                return document[hidden];
            }));
        }
        /**
 * @returns {Observable}
 */        function videoSizeChange() {
            return Object(fromEvent.a)(window, "resize");
        }
        var isVisible$ = visibilityChange().pipe(Object(filter.a)(function(x) {
            return !x;
        })), isHidden$ = visibilityChange().pipe(debounceTime(INACTIVITY_DELAY), Object(filter.a)(function(x) {
            return x;
        }));
 // emit false when visible
        // Emit true if the visibility changed to hidden since 60s
                /**
 * @returns {Observable}
 */
        function isInBackground$() {
            return Object(merge.a)(isVisible$, isHidden$).pipe(Object(startWith.a)(!1));
        }
        /**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        function videoWidth$(mediaElement) {
            return Object(merge.a)(Object(interval.a)(2e4), videoSizeChange().pipe(debounceTime(500))).pipe(Object(startWith.a)(null), // emit on subscription
            Object(map.a)(function() {
                return mediaElement.clientWidth * pixelRatio;
            }), Object(distinctUntilChanged.a)());
        }
        /**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        var onLoadedMetadata$ = compatibleListener([ "loadedmetadata" ]), onSeeking$ = compatibleListener([ "seeking" ]), onSeeked$ = compatibleListener([ "seeked" ]), onEnded$ = compatibleListener([ "ended" ]), onFullscreenChange$ = (compatibleListener([ "timeupdate" ]), 
        compatibleListener([ "fullscreenchange", "FullscreenChange" ], // On IE11, fullscreen change events is called MSFullscreenChange
        BROWSER_PREFIXES.concat("MS"))), events_onPlayPause$ = function onPlayPause$(mediaElement) {
            return Object(merge.a)(compatibleListener([ "play" ])(mediaElement), compatibleListener([ "pause" ])(mediaElement));
        }, events_onTextTrackChanges$ = function onTextTrackChanges$(textTrackList) {
            return Object(merge.a)(compatibleListener([ "addtrack" ])(textTrackList), compatibleListener([ "removetrack" ])(textTrackList));
        }, onSourceOpen$ = compatibleListener([ "sourceopen", "webkitsourceopen" ]), onUpdate$ = compatibleListener([ "update" ]), onRemoveSourceBuffers$ = compatibleListener([ "onremovesourcebuffer" ]), onEncrypted$ = compatibleListener([ "encrypted", "needkey" ]), onKeyMessage$ = compatibleListener([ "keymessage", "message" ]), onKeyAdded$ = compatibleListener([ "keyadded", "ready" ]), onKeyError$ = compatibleListener([ "keyerror", "error" ]), onKeyStatusesChange$ = compatibleListener([ "keystatuseschange" ]);
        /**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */    }, 
    /* 13 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Array.prototype.includes ponyfill.
 * Returns ``true`` if the given array ``arr`` contains the element
 * ``searchElement``. false ``otherwise``.
 *
 * Inspired from MDN polyfill, but ponyfilled instead
 *
 * @example
 * ```js
 * arrayIncludes([1, 2, 3], 3);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 7);
 * // => false
 *
 * const obj = { a: 4 };
 * arrayIncludes([obj, { b: 7 }, { a: 3 }, obj);
 * // => true
 *
 * // does not perform deep equality
 * arrayIncludes([{ a: 4 }, { b: 7 }, { a: 3 }, { a: 4 });
 * // => false
 *
 * // the third argument state the starting index. 0 if not set.
 *
 * arrayIncludes([1, 2, 3], 2, 1);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 2, 2);
 * // => false
 * ```
 *
 * @param {Array} arr
 * @param {*} searchElement
 * @param {number} [fromIndex]
 * @returns {boolean}
 */
        function arrayIncludes(arr, searchElement, fromIndex) {
            /* tslint:disable no-unbound-method */
            if ("function" == typeof Array.prototype.includes) 
            /* tslint:enable no-unbound-method */
            return arr.includes(searchElement, fromIndex);
            var len = arr.length >>> 0;
            if (0 === len) return !1;
            for (var n = 0 | fromIndex, k = Math.max(0 <= n ? n : len - Math.abs(n), 0), areTheSame = function areTheSame(x, y) {
                return x === y || // Viva las JavaScriptas!
                "number" == typeof x && "number" == typeof y && isNaN(x) && isNaN(y);
            }; k < len; ) {
                if (areTheSame(arr[k], searchElement)) return !0;
                k++;
            }
            return !1;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return arrayIncludes;
        });
    }, 
    /* 14 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/errors/AssertionError.ts
                function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error due to an abnormal assertion fails.
 *
 * @class AssertionError
 * @extends Error
 */        var AssertionError = 
        /* */
        function(_Error) {
            /**
   * @param {string} message
   */
            function AssertionError(message) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_assertThisInitialized(_this)), AssertionError.prototype), 
                _this.name = "AssertionError", _this.message = message, Error.captureStackTrace && Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), AssertionError), 
                _this;
            }
            return _inheritsLoose(AssertionError, _Error), AssertionError;
        }(_wrapNativeSuper(Error));
        // CONCATENATED MODULE: ./src/utils/assert.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Throw an AssertionError if the given assertion is false.
 * @param {boolean} assertion
 * @param {string} [message] - Optional message property for the AssertionError.
 * @throws AssertionError - Throws if the assertion given is false
 */
        function assert(assertion, message) {
            if (!assertion) throw new AssertionError(message || "invalid assertion");
        }
        /**
 * Throws if the given Object does not respect the interface.
 * @param {Object} o
 * @param {Object} iface - Contains the checked keynames of o and link them
 * to their types (obtained through the typeof operator).
 * @param {string} [name="object"] - name of the _interface_
 * @throws AssertionError - The argument o given is not an object
 * @throws AssertionError - The _interface_ is not respected.
 */        function assertInterface(o, iface, name) {
            for (var k in void 0 === name && (name = "object"), assert(null != o, name + " should be an object"), 
            iface) iface.hasOwnProperty(k) && 
            /* tslint:disable:max-line-length */
            assert(typeof o[k] === iface[k], name + " should have property " + k + " as a " + iface[k]);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "b", function() {
            return assert;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return assertInterface;
        });
    }, 
    /* 15 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArray.js
                var isArray = __webpack_require__(47), isObject = __webpack_require__(68), isFunction = __webpack_require__(49), tryCatch = __webpack_require__(63), errorObject = __webpack_require__(43);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isObject.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function UnsubscriptionErrorImpl(errors) {
            return Error.call(this), this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
                return i + 1 + ") " + err.toString();
            }).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = errors, this;
        }
        UnsubscriptionErrorImpl.prototype = /* */ Object.create(Error.prototype);
        var UnsubscriptionError = UnsubscriptionErrorImpl;
        //# sourceMappingURL=UnsubscriptionError.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return Subscription_Subscription;
        });
        /** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_tryCatch,_util_errorObject,_util_UnsubscriptionError PURE_IMPORTS_END */
        var Subscription_Subscription = /* */ function() {
            function Subscription(unsubscribe) {
                this.closed = !1, this._parent = null, this._parents = null, this._subscriptions = null, 
                unsubscribe && (this._unsubscribe = unsubscribe);
            }
            return Subscription.prototype.unsubscribe = function() {
                var errors, hasErrors = !1;
                if (!this.closed) {
                    var _parent = this._parent, _parents = this._parents, _unsubscribe = this._unsubscribe, _subscriptions = this._subscriptions;
                    this.closed = !0, this._parent = null, this._parents = null, this._subscriptions = null;
                    for (var index = -1, len = _parents ? _parents.length : 0; _parent; ) _parent.remove(this), 
                    _parent = ++index < len && _parents[index] || null;
                    if (Object(isFunction.a)(_unsubscribe)) Object(tryCatch.a)(_unsubscribe).call(this) === errorObject.a && (hasErrors = !0, 
                    errors = errors || (errorObject.a.e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject.a.e.errors) : [ errorObject.a.e ]));
                    if (Object(isArray.a)(_subscriptions)) for (index = -1, len = _subscriptions.length; ++index < len; ) {
                        var sub = _subscriptions[index];
                        if (Object(isObject.a)(sub)) if (Object(tryCatch.a)(sub.unsubscribe).call(sub) === errorObject.a) {
                            hasErrors = !0, errors = errors || [];
                            var err = errorObject.a.e;
                            err instanceof UnsubscriptionError ? errors = errors.concat(flattenUnsubscriptionErrors(err.errors)) : errors.push(err);
                        }
                    }
                    if (hasErrors) throw new UnsubscriptionError(errors);
                }
            }, Subscription.prototype.add = function(teardown) {
                if (!teardown || teardown === Subscription.EMPTY) return Subscription.EMPTY;
                if (teardown === this) return this;
                var subscription = teardown;
                switch (typeof teardown) {
                  case "function":
                    subscription = new Subscription(teardown);

                  case "object":
                    if (subscription.closed || "function" != typeof subscription.unsubscribe) return subscription;
                    if (this.closed) return subscription.unsubscribe(), subscription;
                    if ("function" != typeof subscription._addParent) {
                        var tmp = subscription;
                        (subscription = new Subscription())._subscriptions = [ tmp ];
                    }
                    break;

                  default:
                    throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
                }
                return (this._subscriptions || (this._subscriptions = [])).push(subscription), subscription._addParent(this), 
                subscription;
            }, Subscription.prototype.remove = function(subscription) {
                var subscriptions = this._subscriptions;
                if (subscriptions) {
                    var subscriptionIndex = subscriptions.indexOf(subscription);
                    -1 !== subscriptionIndex && subscriptions.splice(subscriptionIndex, 1);
                }
            }, Subscription.prototype._addParent = function(parent) {
                var _parent = this._parent, _parents = this._parents;
                _parent && _parent !== parent ? _parents ? -1 === _parents.indexOf(parent) && _parents.push(parent) : this._parents = [ parent ] : this._parent = parent;
            }, Subscription.EMPTY = function(empty) {
                return empty.closed = !0, empty;
            }(new Subscription()), Subscription;
        }();
        function flattenUnsubscriptionErrors(errors) {
            return errors.reduce(function(errs, err) {
                return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
            }, []);
        }
        //# sourceMappingURL=Subscription.js.map
        /***/    }, 
    /* 16 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* unused harmony export createRange */
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return convertToRanges;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getInnerAndOuterTimeRanges;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getLeftSizeOfRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getNextRangeGap;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return getPlayedSizeOfRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return getRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return getSizeOfRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return insertInto;
        }), 
        /* unused harmony export isAfter */
        /* unused harmony export isBefore */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return isTimeInRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() {
            return keepRangeIntersection;
        });
        /* unused harmony export mergeContiguousRanges */
        /* unused harmony export removeEmptyRanges */
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file contains functions helping with TimeRanges management.
 *
 * For simplicity/performance reasons, many of those work with a simplified
 * "Range" object, which is an object with two keys:
 *   - start {Number}
 *   - end {Number}
 *
 * Those two corresponds to what is returned by the start and end methods of a
 * TimeRanges Object.
 *
 * You can convert from TimeRanges to Range object(s) with the getRange/
 * convertToRanges methods.
 */
        // Factor for rounding errors
        var EPSILON = 1 / 60;
        /**
 * @param {number} start
 * @param {number} end
 * @returns {Object}
 */        
        /**
 * Check equality with a tolerance of EPSILON.
 * Used for various functions with this sort of tolerance regarding the
 * start/end of contiguous ranges.
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
        function nearlyEqual(a, b) {
            return Math.abs(a - b) < EPSILON;
        }
        /**
 * Construct a new range which will have, as start/end, the min/max
 * of both the range given, and the given bitrate.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Object}
 */        function createRangeUnion(range1, range2) {
            return {
                start: Math.min(range1.start, range2.start),
                end: Math.max(range1.end, range2.end)
            };
        }
        /**
 * Clean array ranges from "empty" ranges.
 * That is, range objects which have their start equal to their end.
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */        function removeEmptyRanges(ranges) {
            for (var index = 0; index < ranges.length; index++) {
                var range = ranges[index];
                range.start === range.end && ranges.splice(index++, 1);
            }
            return ranges;
        }
        /**
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */        function mergeContiguousRanges(ranges) {
            for (var index = 1; index < ranges.length; index++) {
                var prevRange = ranges[index - 1], currRange = ranges[index];
                if (areRangesNearlyContiguous(prevRange, currRange)) {
                    var unionRange = createRangeUnion(prevRange, currRange);
                    ranges.splice(--index, 2, unionRange);
                }
            }
            return ranges;
        }
        /**
 * True if range1 is considered _after_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */        
        /**
 * True if range1 is considered _before_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
        function isBefore(range1, range2) {
            return range1.end <= range2.start;
        }
        /**
 * Returns true if the time given can be considered as part of the given range.
 * @param {Object} range1
 * @param {Number} Time
 * @returns {Boolean}
 */        function isTimeInRange(_ref, time) {
            var start = _ref.start, end = _ref.end;
            return start <= time && time < end;
        }
        /**
 * Returns true if the two ranges given are overlapping.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */        function areRangesOverlapping(range1, range2) {
            return isTimeInRange(range1, range2.start) || range1.start < range2.end && range2.end < range1.end || isTimeInRange(range2, range1.start);
        }
        /**
 * Returns true if the two ranges given can be considered contiguous.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */        function areRangesNearlyContiguous(range1, range2) {
            return nearlyEqual(range2.start, range1.end) || nearlyEqual(range2.end, range1.start);
        }
        /**
 * Convert from a TimeRanges object to an array of Ranges.
 * @param {TimeRanges} timeRanges
 * @returns {Array.<Object>}
 */        function convertToRanges(timeRanges) {
            for (var ranges = [], i = 0; i < timeRanges.length; i++) ranges.push({
                start: timeRanges.start(i),
                end: timeRanges.end(i)
            });
            return ranges;
        }
        /**
 * Get range object of a specific time in a TimeRanges object.
 * @param {TimeRanges} timeRanges
 * @returns {Object}
 */        function getRange(timeRanges, time) {
            for (var i = timeRanges.length - 1; 0 <= i; i--) {
                var start = timeRanges.start(i);
                if (start <= time) {
                    var end = timeRanges.end(i);
                    if (time < end) return {
                        start: start,
                        end: end
                    };
                }
            }
            return null;
        }
        /**
 * Get gap from a specific time until the start of the next Range.
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Number}
 */        function getNextRangeGap(timeRanges, time) {
            for (var len = timeRanges.length, i = 0; i < len; i++) {
                var start = timeRanges.start(i);
                if (time < start) return start - time;
            }
            return Infinity;
        }
        /**
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Object} - Object with two properties:
 *   - outerRanges {Array.<Object>}: every ranges which does not contain the
 *     given time.
 *   - innerRange {Object|null}: the range which contain the given time.
 */        function getInnerAndOuterTimeRanges(timeRanges, time) {
            for (var innerRange = null, outerRanges = [], i = 0; i < timeRanges.length; i++) {
                var start = timeRanges.start(i), end = timeRanges.end(i);
                time < start || end <= time ? outerRanges.push({
                    start: start,
                    end: end
                }) : innerRange = {
                    start: start,
                    end: end
                };
            }
            return {
                outerRanges: outerRanges,
                innerRange: innerRange
            };
        }
        /**
 * Get "size" (difference between end and start) of the range containing the
 * given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */        function getSizeOfRange(timeRanges, currentTime) {
            var range = getRange(timeRanges, currentTime);
            return range ? range.end - range.start : 0;
        }
        /**
 * Get "currently played" (difference between time given and start) of the
 * range containing the given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */        function getPlayedSizeOfRange(timeRanges, currentTime) {
            var range = getRange(timeRanges, currentTime);
            return range ? currentTime - range.start : 0;
        }
        /**
 * Get "left to play" (difference between end and time given) of the range
 * containing the given time. Infinity if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */        function getLeftSizeOfRange(timeRanges, currentTime) {
            var range = getRange(timeRanges, currentTime);
            return range ? range.end - currentTime : Infinity;
        }
        /**
 * Insert a range object into an array of ranges objects, at the right place.
 * /!\ Mutate the array of ranges.
 * @param {Array.<Object>} ranges
 * @param {Object} rangeToAddArg
 * @returns {Array.<Object>}
 */        function insertInto(ranges, rangeToAddArg) {
            if (rangeToAddArg.start === rangeToAddArg.end) return ranges;
            for (var rangeToAdd = rangeToAddArg, index = 0 // For each present range check if we need to:
            // - In case we are overlapping or contiguous:
            //   - if added range has the same bitrate as the overlapped or
            //     contiguous one, we can merge themcurrentRange
            //   - if added range has a different bitrate we need to insert it
            //     in place
            // - Need to insert in place, we we are completely, not overlapping
            //   and not contiguous in between two ranges.
            ; index < ranges.length; index++) {
                var range = ranges[index], overlapping = areRangesOverlapping(rangeToAdd, range), contiguous = areRangesNearlyContiguous(rangeToAdd, range);
                // We assume ranges are ordered and two ranges can not be
                // completely overlapping.
                if (overlapping || contiguous) rangeToAdd = createRangeUnion(rangeToAdd, range), 
                ranges.splice(index--, 1); else 
                // Check the case for which there is no more to do
                if (0 === index) {
                    if (isBefore(rangeToAdd, ranges[0])) 
                    // First index, and we are completely before that range (and
                    // not contiguous, nor overlapping). We just need to be
                    // inserted here.
                    break;
                } else if (isBefore(ranges[index - 1], rangeToAdd) && isBefore(rangeToAdd, range)) 
                // We are exactly after the current previous range, and
                // before the current range, while not overlapping with none
                // of them. Insert here.
                break;
            }
 // Now that we are sure we don't overlap with any range, just add it.
                        return ranges.splice(index, 0, rangeToAdd), mergeContiguousRanges(removeEmptyRanges(ranges));
        }
        /**
 * Returns range, from a range objects array overlapping with a range given
 * in argument. null if none is found.
 * @param {Object} range
 * @param {Array.<Object>} ranges
 * @returns {Array.<Object>}
 */        function findOverlappingRanges(range, ranges) {
            for (var resultingRanges = [], i = 0; i < ranges.length; i++) areRangesOverlapping(range, ranges[i]) && resultingRanges.push(ranges[i]);
            return resultingRanges;
        }
        /**
 * Returns only the intersection between the two ranges, from the first
 * ranges argument given.
 * @param {Array.<Range>} ranges1
 * @param {Array.<Range>} ranges2
 * @returns {Array.<Range>}
 */        function keepRangeIntersection(ranges1, ranges2) {
            for (var result = [], i = 0; i < ranges1.length; i++) {
                var range = ranges1[i], overlappingRanges = findOverlappingRanges(range, ranges2);
                if (overlappingRanges.length) for (var j = 0; j < overlappingRanges.length; j++) {
                    var overlappingRange = overlappingRanges[j];
                    result.push({
                        start: Math.max(range.start, overlappingRange.start),
                        end: Math.min(range.end, overlappingRange.end)
                    });
                }
            }
            return result;
        }
        /***/    }, 
    /* 17 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isKnownError;
        });
        /* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // Custom Errors
        // Error used for XHRs
        /**
 * Whether the error given is a ICustomError.
 * @param {Error} error
 * @returns {Boolean}
 */        function isKnownError(error) {
            return !!error && !!error.type && 0 <= Object.keys(_constants__WEBPACK_IMPORTED_MODULE_0__.b).indexOf(error.type);
        }
        /***/    }, 
    /* 18 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(64);
        /* harmony import */        
        /* harmony default export */ __webpack_exports__.a = 
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function castToObservable(value) {
            if (value instanceof rxjs__WEBPACK_IMPORTED_MODULE_0__.a) return value;
            if (value && "function" == typeof value.subscribe) {
                var valObsLike = value;
                return new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(function(obs) {
                    var sub = valObsLike.subscribe(function(val) {
                        obs.next(val);
                    }, function(err) {
                        obs.error(err);
                    }, function() {
                        obs.complete();
                    });
                    return function() {
                        sub && sub.dispose ? sub.dispose() : sub && sub.unsubscribe && sub.unsubscribe();
                    };
                });
            }
            return value && "function" == typeof value.then ? Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(value) : Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(value);
        };
    }, 
    /* 19 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return ErrorTypes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return RequestErrorTypes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return ErrorCodes;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var ErrorTypes = {
            NETWORK_ERROR: "NETWORK_ERROR",
            MEDIA_ERROR: "MEDIA_ERROR",
            ENCRYPTED_MEDIA_ERROR: "ENCRYPTED_MEDIA_ERROR",
            OTHER_ERROR: "OTHER_ERROR"
        }, RequestErrorTypes = {
            TIMEOUT: "TIMEOUT",
            ERROR_EVENT: "ERROR_EVENT",
            ERROR_HTTP_CODE: "ERROR_HTTP_CODE",
            PARSE_ERROR: "PARSE_ERROR"
        }, ErrorCodes = {
            PIPELINE_RESOLVE_ERROR: "PIPELINE_RESOLVE_ERROR",
            PIPELINE_LOAD_ERROR: "PIPELINE_LOAD_ERROR",
            PIPELINE_PARSING_ERROR: "PIPELINE_PARSING_ERROR",
            MANIFEST_PARSE_ERROR: "MANIFEST_PARSE_ERROR",
            MANIFEST_INCOMPATIBLE_CODECS_ERROR: "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
            MANIFEST_UNSUPPORTED_ADAPTATION_TYPE: "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE",
            MEDIA_STARTING_TIME_NOT_FOUND: "MEDIA_STARTING_TIME_NOT_FOUND",
            MEDIA_TIME_BEFORE_MANIFEST: "MEDIA_TIME_BEFORE_MANIFEST",
            MEDIA_TIME_AFTER_MANIFEST: "MEDIA_TIME_AFTER_MANIFEST",
            MEDIA_TIME_NOT_FOUND: "MEDIA_TIME_NOT_FOUND",
            MEDIA_IS_ENCRYPTED_ERROR: "MEDIA_IS_ENCRYPTED_ERROR",
            KEY_ERROR: "KEY_ERROR",
            KEY_STATUS_CHANGE_ERROR: "KEY_STATUS_CHANGE_ERROR",
            KEY_UPDATE_ERROR: "KEY_UPDATE_ERROR",
            KEY_LOAD_ERROR: "KEY_LOAD_ERROR",
            KEY_LOAD_TIMEOUT: "KEY_LOAD_TIMEOUT",
            KEY_GENERATE_REQUEST_ERROR: "KEY_GENERATE_REQUEST_ERROR",
            INCOMPATIBLE_KEYSYSTEMS: "INCOMPATIBLE_KEYSYSTEMS",
            LICENSE_SERVER_CERTIFICATE_ERROR: "LICENSE_SERVER_CERTIFICATE_ERROR",
            BUFFER_APPEND_ERROR: "BUFFER_APPEND_ERROR",
            BUFFER_FULL_ERROR: "BUFFER_FULL_ERROR",
            BUFFER_TYPE_UNKNOWN: "BUFFER_TYPE_UNKNOWN",
            MEDIA_ERR_BLOCKED_AUTOPLAY: "MEDIA_ERR_BLOCKED_AUTOPLAY",
            MEDIA_ERR_ABORTED: "MEDIA_ERR_ABORTED",
            MEDIA_ERR_NETWORK: "MEDIA_ERR_NETWORK",
            MEDIA_ERR_DECODE: "MEDIA_ERR_DECODE",
            MEDIA_ERR_SRC_NOT_SUPPORTED: "MEDIA_ERR_SRC_NOT_SUPPORTED",
            MEDIA_ERR_UNKNOWN: "MEDIA_ERR_UNKNOWN",
            MEDIA_SOURCE_NOT_SUPPORTED: "MEDIA_SOURCE_NOT_SUPPORTED",
            MEDIA_KEYS_NOT_SUPPORTED: "MEDIA_KEYS_NOT_SUPPORTED"
        };
    }, 
    /* 20 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Do nothing (but do it well).
 *
 * Having this definition here allow to use the same reference each time a noop
 * is needed.
 * Also, it allows to avoid telling tslint to ignore empty blocks everywhere.
 */
        /* tslint:disable:no-empty */
        /* harmony default export */        __webpack_exports__.a = function() {};
    }, 
    /* 21 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return generateNewId;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var _lastId = 0;
        /**
 * @returns {string}
 */        function generateNewId() {
            var newId = 0;
            return _lastId < Number.MAX_VALUE && (newId = _lastId + 1), "" + (_lastId = newId);
        }
        /***/    }, 
    /* 22 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToResult;
        });
        /* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37), _subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69);
        /* harmony import */        
        /** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */
        function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
            if (void 0 === destination && (destination = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__.a(outerSubscriber, outerValue, outerIndex)), 
            !destination.closed) return Object(_subscribeTo__WEBPACK_IMPORTED_MODULE_1__.a)(result)(destination);
        }
        //# sourceMappingURL=subscribeToResult.js.map
        /***/    }, 
    /* 23 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return OuterSubscriber;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), OuterSubscriber = /* */ function(_super) {
            function OuterSubscriber() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(OuterSubscriber, _super), OuterSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, OuterSubscriber.prototype.notifyError = function(error, innerSub) {
                this.destination.error(error);
            }, OuterSubscriber.prototype.notifyComplete = function(innerSub) {
                this.destination.complete();
            }, OuterSubscriber;
        }(__webpack_require__(7).a);
        /* harmony import */    }, 
    /* 24 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return HTMLElement_;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return MediaKeys_;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return MediaSource_;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return READY_STATES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return VTTCue_;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return isFirefox;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return isIE;
        });
        /* harmony import */ var _errors_MediaError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28), win = window, HTMLElement_ = win.HTMLElement, VTTCue_ = win.VTTCue || win.TextTrackCue, MediaSource_ = win.MediaSource || win.MozMediaSource || win.WebKitMediaSource || win.MSMediaSource, MediaKeys_ = win.MediaKeys || win.MozMediaKeys || win.WebKitMediaKeys || win.MSMediaKeys || 
        /* */
        function() {
            return function _class() {
                var noMediaKeys = function noMediaKeys() {
                    throw new _errors_MediaError__WEBPACK_IMPORTED_MODULE_0__.a("MEDIA_KEYS_NOT_SUPPORTED", null, !0);
                };
                this.create = noMediaKeys, this.createSession = noMediaKeys, this.isTypeSupported = noMediaKeys, 
                this.setServerCertificate = noMediaKeys;
            };
        }(), isIE = "Microsoft Internet Explorer" === navigator.appName || "Netscape" === navigator.appName && /(Trident|Edge)\//.test(navigator.userAgent), isFirefox = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox"), READY_STATES = {
            HAVE_NOTHING: 0,
            HAVE_METADATA: 1,
            HAVE_CURRENT_DATA: 2,
            HAVE_FUTURE_DATA: 3,
            HAVE_ENOUGH_DATA: 4
        };
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */    }, 
    /* 25 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2), _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19), _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82), DEFAULT_REQUEST_TIMEOUT = _config__WEBPACK_IMPORTED_MODULE_1__.a.DEFAULT_REQUEST_TIMEOUT;
        /* harmony import */        
        /**
 * @param {string} data
 * @returns {Object|null}
 */
        function toJSONForIE(data) {
            try {
                return JSON.parse(data);
            } catch (e) {
                return null;
            }
        }
        /* harmony default export */ __webpack_exports__.a = function request(options) {
            var requestOptions = {
                url: options.url,
                body: options.body,
                headers: options.headers,
                method: null == options.method ? "GET" : options.method,
                responseType: null == options.responseType ? "json" : options.responseType,
                timeout: null == options.timeout ? DEFAULT_REQUEST_TIMEOUT : options.timeout
            };
            return rxjs__WEBPACK_IMPORTED_MODULE_0__.a.create(function(obs) {
                var url = requestOptions.url, headers = requestOptions.headers, method = requestOptions.method, responseType = requestOptions.responseType, timeout = requestOptions.timeout, body = requestOptions.body, xhr = new XMLHttpRequest();
                if (xhr.open(method, url, !0), 0 <= timeout && (xhr.timeout = timeout), xhr.responseType = responseType, 
                "document" === xhr.responseType && xhr.overrideMimeType("text/xml"), headers) {
                    var _headers = headers;
                    for (var key in _headers) _headers.hasOwnProperty(key) && xhr.setRequestHeader(key, _headers[key]);
                }
                var sendingTime = performance.now();
                return xhr.onerror = function onXHRError() {
                    var errorCode = _errors__WEBPACK_IMPORTED_MODULE_2__.c.ERROR_EVENT;
                    obs.error(new _errors__WEBPACK_IMPORTED_MODULE_3__.a(xhr, url, errorCode));
                }, xhr.ontimeout = function onXHRTimeout() {
                    var errorCode = _errors__WEBPACK_IMPORTED_MODULE_2__.c.TIMEOUT;
                    obs.error(new _errors__WEBPACK_IMPORTED_MODULE_3__.a(xhr, url, errorCode));
                }, options.ignoreProgressEvents || (xhr.onprogress = function onXHRProgress(event) {
                    var currentTime = performance.now();
                    obs.next({
                        type: "progress",
                        value: {
                            url: url,
                            duration: currentTime - sendingTime,
                            sendingTime: sendingTime,
                            currentTime: currentTime,
                            size: event.loaded,
                            totalSize: event.total
                        }
                    });
                }), xhr.onload = function onXHRLoad(event) {
                    if (4 === xhr.readyState) if (200 <= xhr.status && xhr.status < 300) {
                        var responseData, receivedTime = performance.now(), totalSize = xhr.response instanceof ArrayBuffer ? xhr.response.byteLength : event.total, status = xhr.status, loadedResponseType = xhr.responseType, _url = xhr.responseURL || url;
                        if (null == (
                        // IE bug where response is string with responseType json
                        responseData = "json" === loadedResponseType ? "string" !== xhr.response ? xhr.response : toJSONForIE(xhr.responseText) : xhr.response)) {
                            var errorCode = _errors__WEBPACK_IMPORTED_MODULE_2__.c.PARSE_ERROR;
                            return void obs.error(new _errors__WEBPACK_IMPORTED_MODULE_3__.a(xhr, _url, errorCode));
                        }
                        obs.next({
                            type: "response",
                            value: {
                                status: status,
                                url: _url,
                                responseType: loadedResponseType,
                                sendingTime: sendingTime,
                                receivedTime: receivedTime,
                                duration: receivedTime - sendingTime,
                                size: totalSize,
                                responseData: responseData
                            }
                        }), obs.complete();
                    } else {
                        var _errorCode = _errors__WEBPACK_IMPORTED_MODULE_2__.c.ERROR_HTTP_CODE;
                        obs.error(new _errors__WEBPACK_IMPORTED_MODULE_3__.a(xhr, url, _errorCode));
                    }
                }, void 0 !== body ? xhr.send(body) : xhr.send(), function() {
                    xhr && 4 !== xhr.readyState && xhr.abort();
                };
            });
        };
    }, 
    /* 26 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return fromArray;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15), _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */
        function fromArray(input, scheduler) {
            return scheduler ? new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.a(), i = 0;
                return sub.add(scheduler.schedule(function() {
                    i !== input.length ? (subscriber.next(input[i++]), subscriber.closed || sub.add(this.schedule())) : subscriber.complete();
                })), sub;
            }) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_2__.a)(input));
        }
        //# sourceMappingURL=fromArray.js.map
        /***/    }, 
    /* 27 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return EMPTY;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return empty;
        });
        /* unused harmony export emptyScheduled */
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), EMPTY = /* */ new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
            return subscriber.complete();
        });
        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */        function empty(scheduler) {
            return scheduler ? emptyScheduled(scheduler) : EMPTY;
        }
        function emptyScheduled(scheduler) {
            return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return scheduler.schedule(function() {
                    return subscriber.complete();
                });
            });
        }
        //# sourceMappingURL=empty.js.map
        /***/    }, 
    /* 28 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return MediaError;
        });
        /* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19), _errorMessage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
        /* harmony import */        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error linked to the media Playback.
 *
 * @class MediaError
 * @extends Error
 */        var MediaError = 
        /* */
        function(_Error) {
            /**
   * @param {string} code
   * @param {Error|null} [reason]
   * @param {Boolean} [fatal]
   */
            function MediaError(code, reason, fatal) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_assertThisInitialized(_this)), MediaError.prototype), 
                _this.name = "MediaError", _this.type = _constants__WEBPACK_IMPORTED_MODULE_0__.b.MEDIA_ERROR, 
                _this.reason = reason, _this.code = _constants__WEBPACK_IMPORTED_MODULE_0__.a.hasOwnProperty(code) ? _constants__WEBPACK_IMPORTED_MODULE_0__.a[code] : "", 
                _this.fatal = !!fatal, _this.message = Object(_errorMessage__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, _this.reason), 
                _this;
            }
            return _inheritsLoose(MediaError, _Error), MediaError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 29 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "c", function() {
            return REGXP_PERCENT_VALUES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return REGXP_TIME_COLON;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return REGXP_TIME_COLON_FRAMES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return REGXP_TIME_COLON_MS;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return REGXP_TIME_FRAMES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return REGXP_TIME_HMS;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return REGXP_TIME_TICK;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return REGXP_4_HEX_COLOR;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return REGXP_8_HEX_COLOR;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @type {RegExp}
 * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
 */
        var REGXP_TIME_COLON_FRAMES = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, REGXP_TIME_COLON = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/, REGXP_TIME_COLON_MS = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/, REGXP_TIME_FRAMES = /^(\d*\.?\d*)f$/, REGXP_TIME_TICK = /^(\d*\.?\d*)t$/, REGXP_TIME_HMS = /^(?:(\d*\.?\d*)h)?(?:(\d*\.?\d*)m)?(?:(\d*\.?\d*)s)?(?:(\d*\.?\d*)ms)?$/, REGXP_PERCENT_VALUES = /^(\d{1,2}|100)% (\d{1,2}|100)%$/, REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/, REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;
        /**
 * @type {RegExp}
 * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
 */    }, 
    /* 30 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Construct a "loaded" event.
 * @returns {Object}
 */        var STREAM_EVENTS = {
            loaded: function loaded() {
                return {
                    type: "loaded",
                    value: !0
                };
            }
            /**
 * Construct a "stalled" event.
 * @param {Object|null} stalling
 * @returns {Object}
 */ ,
            manifestReady: 
            /**
 * Construct a "manifestReady" event.
 * @param {Object} abrManager
 * @param {Object} manifest
 * @returns {Object}
 */
            function manifestReady(abrManager, manifest) {
                return {
                    type: "manifestReady",
                    value: {
                        abrManager: abrManager,
                        manifest: manifest
                    }
                };
            }
            /**
 * Construct a "manifestUpdate" event.
 * @param {Object} manifest
 * @param {number|undefined} sendingTime
 * @returns {Object}
 */ ,
            manifestUpdate: function manifestUpdate(manifest, sendingTime) {
                return {
                    type: "manifestUpdate",
                    value: {
                        manifest: manifest,
                        sendingTime: sendingTime
                    }
                };
            }
            /**
 * Construct a "speedChanged" event.
 * @param {Number} speed
 * @returns {Object}
 */ ,
            nullRepresentation: 
            /**
 * Construct a "representationChange" event.
 * @param {string} type
 * @param {Object} period
 * @returns {Object}
 */
            function nullRepresentation(type, period) {
                return {
                    type: "representationChange",
                    value: {
                        type: type,
                        representation: null,
                        period: period
                    }
                };
            }
            /**
 * Construct a "warning" event.
 * @param {Error} value
 * @returns {Object}
 */ ,
            reloadingStream: function reloadingStream() {
                return {
                    type: "reloading-stream",
                    value: void 0
                };
            },
            speedChanged: function speedChanged(speed) {
                return {
                    type: "speedChanged",
                    value: speed
                };
            },
            stalled: function stalled(stalling) {
                return {
                    type: "stalled",
                    value: stalling
                };
            },
            warning: function warning(value) {
                return {
                    type: "warning",
                    value: value
                };
            }
        };
        /* harmony default export */        __webpack_exports__.a = STREAM_EVENTS;
    }, 
    /* 31 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isScheduler(value) {
            return value && "function" == typeof value.schedule;
        }
        //# sourceMappingURL=isScheduler.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isScheduler;
        });
    }, 
    /* 32 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return getMDHDTimescale;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getTrackFragmentDecodeTime;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return getDurationFromTrun;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getSegmentsFromSidx;
        });
        /* unused harmony export patchPssh */
        /* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14), _utils_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1), _read__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Find the right atom (box) in an isobmff file from its hexa-encoded name.
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} atomName - the 'name' of the box (e.g. 'sidx' or 'moov'),
 * hexa encoded
 * @returns {Number} - offset where the corresponding box is (starting with its
 * size), 0 if not found.
 */
        function findAtom(buf, atomName) {
            for (var name, l = buf.length, i = 0, size = 0; i + 8 < l && (size = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, i), 
            name = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, i + 4), Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__.b)(0 < size, "out of range size"), 
            name !== atomName); ) i += size;
            return l <= i ? -1 : (Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__.b)(i + size <= l, "atom out of range"), 
            i);
        }
        /**
 * Parse the sidx part (segment index) of the isobmff.
 * Returns null if not found.
 *
 * @param {Uint8Array} buf
 * @param {Number} initialOffset
 * @returns {Object|null} {Array.<Object>} - Informations about each subsegment.
 * Contains those keys:
 *   - time {Number}: starting _presentation time_ for the subsegment,
 *     timescaled
 *   - duration {Number}: duration of the subsegment, timescaled
 *   - timescale {Number}: the timescale in which the time and duration are set
 *   - count {Number}: always at 0
 *   - range {Array.<Number>}: first and last bytes in the media file
 *     from the anchor point (first byte after the sidx box) for the
 *     concerned subsegment.
 */        function getSegmentsFromSidx(buf, initialOffset) {
            var index = findAtom(buf, 1936286840
            /* "sidx" */);
            if (-1 === index) return null;
            var offset = initialOffset, size = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, index), pos = index + 
            /* size */
            4 + 
            /* name */
            4, version = buf[pos];
            pos += 8;
            var time, timescale = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, pos);
            if (pos += 4, 0 === version) time = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, pos), 
            pos += 4, offset += Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, pos) + size, 
            pos += 4; else {
                if (1 !== version) return null;
                time = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.d)(buf, pos), pos += 8, 
                offset += Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.d)(buf, pos) + size, 
                pos += 8;
            }
            var segments = [];
            /* reserved(16) */
            /* reference_count(16) */            pos += 2;
            var count = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.a)(buf, pos);
            for (pos += 2; 0 <= --count; ) {
                /* reference_type(1) */
                /* reference_size(31) */
                /* segment_duration(32) */
                /* sap..(32) */
                var refChunk = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, pos);
                pos += 4;
                var refSize = 2147483647 & refChunk;
                // when set to 1 indicates that the reference is to a sidx, else to media
                if (1 === (2147483648 & refChunk) >>> 31) throw new Error("not implemented");
                var duration = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, pos);
                pos += 4, // let sapChunk = be4toi(buf, pos + 8);
                pos += 4, // TODO(pierre): handle sap
                // let startsWithSap = (sapChunk & 0x80000000) >>> 31;
                // let sapType = (sapChunk & 0x70000000) >>> 28;
                // let sapDelta = sapChunk & 0x0FFFFFFF;
                segments.push({
                    time: time,
                    duration: duration,
                    count: 0,
                    timescale: timescale,
                    range: [ offset, offset + refSize - 1 ]
                }), time += duration, offset += refSize;
            }
            return segments;
        }
        /**
 * Parse track Fragment Decode Time to get a precize initial time for this
 * segment (in the media timescale).
 * Stops at the first tfdt encountered from the beginning of the file.
 * Returns this time. -1 if not found.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */        function getTrackFragmentDecodeTime(buffer) {
            var traf = Object(_read__WEBPACK_IMPORTED_MODULE_2__.c)(buffer);
            if (!traf) return -1;
            var index = findAtom(traf, 1952867444
            /* tfdt */);
            if (-1 === index) return -1;
            var pos = index + 
            /* size */
            4 + 
            /* name */
            4, version = traf[pos];
            return pos += 4, 1 < version ? -1 : version ? Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.d)(traf, pos) : Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(traf, pos);
        }
        /**
 * @param {Uint8Array} traf
 * @returns {number}
 */        function getDefaultDurationFromTFHDInTRAF(traf) {
            var index = findAtom(traf, 1952868452
            /* tfhd */);
            if (-1 === index) return -1;
            var pos = index + 
            /* size */
            4 + 
            /* name */
            4 + 
            /* version */
            1, flags = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.b)(traf, pos);
            return 8 & flags ? (pos += 4, 1 & flags && (pos += 8), 2 & flags && (pos += 4), 
            Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(traf, pos)) : -1;
        }
        /**
 * @param {Uint8Array} buffer
 * @returns {number}
 */        function getDurationFromTrun(buffer) {
            var traf = Object(_read__WEBPACK_IMPORTED_MODULE_2__.c)(buffer);
            if (!traf) return -1;
            var index = findAtom(traf, 1953658222
            /* tfdt */);
            if (-1 === index) return -1;
            var pos = index + 
            /* size */
            4 + 
            /* name */
            4, version = traf[pos];
            if (pos += 1, 1 < version) return -1;
            var flags = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.b)(traf, pos);
            pos += 3;
            var hasSampleDuration = 256 & flags, defaultDuration = 0;
            if (!hasSampleDuration) return 0 <= (defaultDuration = getDefaultDurationFromTFHDInTRAF(traf)) ? defaultDuration : -1;
            var hasDataOffset = 1 & flags, hasFirstSampleFlags = 4 & flags, hasSampleSize = 512 & flags, hasSampleFlags = 1024 & flags, hasSampleCompositionOffset = 2048 & flags, sampleCounts = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(traf, pos);
            pos += 4, hasDataOffset && (pos += 4), hasFirstSampleFlags && (pos += 4);
            for (var i = sampleCounts, duration = 0; i--; ) hasSampleDuration ? (duration += Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(traf, pos), 
            pos += 4) : duration += defaultDuration, hasSampleSize && (pos += 4), hasSampleFlags && (pos += 4), 
            hasSampleCompositionOffset && (pos += 4);
            return duration;
        }
        /**
 * Get various informations from a movie header box. Found in init segments.
 * null if not found or not parsed.
 *
 * This timescale is the default timescale used for segments.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */        function getMDHDTimescale(buffer) {
            var mdia = Object(_read__WEBPACK_IMPORTED_MODULE_2__.b)(buffer);
            if (!mdia) return -1;
            var index = findAtom(mdia, 1835296868
            /* "mdhd" */);
            if (-1 === index) return -1;
            var pos = index + 
            /* size */
            4 + 
            /* name */
            4, version = mdia[pos];
            return pos += 4, 1 === version ? (pos += 16, Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(mdia, pos)) : 0 === version ? (pos += 8, 
            Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(mdia, pos)) : -1;
        }
        /**
 * Create a new _Atom_ (isobmff box).
 * @param {string} name - The box name (e.g. sidx, moov, pssh etc.)
 * @param {Uint8Array} buff - The box's content
 */    }, 
    /* 33 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return SubjectSubscriber;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return Subject;
        });
        /* unused harmony export AnonymousSubject */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9), _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7), _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15), _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40), _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77), _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(55), SubjectSubscriber = /* */ function(_super) {
            function SubjectSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.destination = destination, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SubjectSubscriber, _super), SubjectSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.a), Subject = /* */ function(_super) {
            function Subject() {
                var _this = _super.call(this) || this;
                return _this.observers = [], _this.closed = !1, _this.isStopped = !1, _this.hasError = !1, 
                _this.thrownError = null, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(Subject, _super), Subject.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__.a] = function() {
                return new SubjectSubscriber(this);
            }, Subject.prototype.lift = function(operator) {
                var subject = new AnonymousSubject(this, this);
                return subject.operator = operator, subject;
            }, Subject.prototype.next = function(value) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                if (!this.isStopped) for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].next(value);
            }, Subject.prototype.error = function(err) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                this.hasError = !0, this.thrownError = err, this.isStopped = !0;
                for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].error(err);
                this.observers.length = 0;
            }, Subject.prototype.complete = function() {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                this.isStopped = !0;
                for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].complete();
                this.observers.length = 0;
            }, Subject.prototype.unsubscribe = function() {
                this.isStopped = !0, this.closed = !0, this.observers = null;
            }, Subject.prototype._trySubscribe = function(subscriber) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                return _super.prototype._trySubscribe.call(this, subscriber);
            }, Subject.prototype._subscribe = function(subscriber) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                return this.hasError ? (subscriber.error(this.thrownError), _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY) : this.isStopped ? (subscriber.complete(), 
                _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY) : (this.observers.push(subscriber), 
                new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__.a(this, subscriber));
            }, Subject.prototype.asObservable = function() {
                var observable = new _Observable__WEBPACK_IMPORTED_MODULE_1__.a();
                return observable.source = this, observable;
            }, Subject.create = function(destination, source) {
                return new AnonymousSubject(destination, source);
            }, Subject;
        }(_Observable__WEBPACK_IMPORTED_MODULE_1__.a), AnonymousSubject = /* */ function(_super) {
            function AnonymousSubject(destination, source) {
                var _this = _super.call(this) || this;
                return _this.destination = destination, _this.source = source, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(AnonymousSubject, _super), AnonymousSubject.prototype.next = function(value) {
                var destination = this.destination;
                destination && destination.next && destination.next(value);
            }, AnonymousSubject.prototype.error = function(err) {
                var destination = this.destination;
                destination && destination.error && this.destination.error(err);
            }, AnonymousSubject.prototype.complete = function() {
                var destination = this.destination;
                destination && destination.complete && this.destination.complete();
            }, AnonymousSubject.prototype._subscribe = function(subscriber) {
                return this.source ? this.source.subscribe(subscriber) : _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY;
            }, AnonymousSubject;
        }(Subject);
        /* harmony import */    }, 
    /* 34 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return async;
        });
        /* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(106), async = /* */ new (__webpack_require__(105).a)(_AsyncAction__WEBPACK_IMPORTED_MODULE_0__.a);
        /* harmony import */    }, 
    /* 35 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                var Observable = __webpack_require__(9), isPromise = __webpack_require__(73), isArrayLike = __webpack_require__(71), symbol_observable = __webpack_require__(48);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isPromise.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
        /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
        function isInteropObservable(input) {
            return input && "function" == typeof input[symbol_observable.a];
        }
        //# sourceMappingURL=isInteropObservable.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/iterator.js
                var symbol_iterator = __webpack_require__(53);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isIterable.js
        /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */        function isIterable(input) {
            return input && "function" == typeof input[symbol_iterator.a];
        }
        //# sourceMappingURL=isIterable.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromArray.js
                var fromArray = __webpack_require__(26), Subscription = __webpack_require__(15), subscribeToPromise = __webpack_require__(74);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromPromise.js
        /** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */
        function fromPromise(input, scheduler) {
            return scheduler ? new Observable.a(function(subscriber) {
                var sub = new Subscription.a();
                return sub.add(scheduler.schedule(function() {
                    return input.then(function(value) {
                        sub.add(scheduler.schedule(function() {
                            subscriber.next(value), sub.add(scheduler.schedule(function() {
                                return subscriber.complete();
                            }));
                        }));
                    }, function(err) {
                        sub.add(scheduler.schedule(function() {
                            return subscriber.error(err);
                        }));
                    });
                })), sub;
            }) : new Observable.a(Object(subscribeToPromise.a)(input));
        }
        //# sourceMappingURL=fromPromise.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
                var subscribeToIterable = __webpack_require__(75);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromIterable.js
        /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */        function fromIterable(input, scheduler) {
            if (!input) throw new Error("Iterable cannot be null");
            return scheduler ? new Observable.a(function(subscriber) {
                var iterator, sub = new Subscription.a();
                return sub.add(function() {
                    iterator && "function" == typeof iterator.return && iterator.return();
                }), sub.add(scheduler.schedule(function() {
                    iterator = input[symbol_iterator.a](), sub.add(scheduler.schedule(function() {
                        if (!subscriber.closed) {
                            var value, done;
                            try {
                                var result = iterator.next();
                                value = result.value, done = result.done;
                            } catch (err) {
                                return void subscriber.error(err);
                            }
                            done ? subscriber.complete() : (subscriber.next(value), this.schedule());
                        }
                    }));
                })), sub;
            }) : new Observable.a(Object(subscribeToIterable.a)(input));
        }
        //# sourceMappingURL=fromIterable.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
                var subscribeToObservable = __webpack_require__(70);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromObservable.js
        /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */        function fromObservable(input, scheduler) {
            return scheduler ? new Observable.a(function(subscriber) {
                var sub = new Subscription.a();
                return sub.add(scheduler.schedule(function() {
                    var observable = input[symbol_observable.a]();
                    sub.add(observable.subscribe({
                        next: function(value) {
                            sub.add(scheduler.schedule(function() {
                                return subscriber.next(value);
                            }));
                        },
                        error: function(err) {
                            sub.add(scheduler.schedule(function() {
                                return subscriber.error(err);
                            }));
                        },
                        complete: function() {
                            sub.add(scheduler.schedule(function() {
                                return subscriber.complete();
                            }));
                        }
                    }));
                })), sub;
            }) : new Observable.a(Object(subscribeToObservable.a)(input));
        }
        //# sourceMappingURL=fromObservable.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js
                var subscribeTo = __webpack_require__(69);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */
        function from(input, scheduler) {
            if (!scheduler) return input instanceof Observable.a ? input : new Observable.a(Object(subscribeTo.a)(input));
            if (null != input) {
                if (isInteropObservable(input)) return fromObservable(input, scheduler);
                if (Object(isPromise.a)(input)) return fromPromise(input, scheduler);
                if (Object(isArrayLike.a)(input)) return Object(fromArray.a)(input, scheduler);
                if (isIterable(input) || "string" == typeof input) return fromIterable(input, scheduler);
            }
            throw new TypeError((null !== input && typeof input || input) + " is not observable");
        }
        //# sourceMappingURL=from.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return from;
        });
    }, 
    /* 36 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return EventEmitter;
        });
        /* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0), EventEmitter = 
        /* */
        function() {
            function EventEmitter() {
                this._listeners = {};
            }
            /**
   * Register a new callback for an event.
   *
   * @param {string} evt - The event to register a callback to
   * @param {Function} fn - The callback to call as that event is triggered.
   * The callback will take as argument the eventual payload of the event
   * (single argument).
   */            var _proto = EventEmitter.prototype;
            return _proto.addEventListener = function addEventListener(evt, fn) {
                var listeners = this._listeners[evt];
                listeners ? listeners.push(fn) : 
                // TS Bug?
                this._listeners[evt] = [ fn ];
            }, 
            /**
   * Unregister callbacks linked to events.
   * @param {string} [evt] - The event for which the callback[s] should be
   * unregistered. Set it to null or undefined to remove all callbacks
   * currently registered (for any event).
   * @param {Function} [fn] - The callback to unregister. If set to null
   * or undefined while the evt argument is set, all callbacks linked to that
   * event will be unregistered.
   */
            _proto.removeEventListener = function removeEventListener(evt, fn) {
                if (null != evt) {
                    var listeners = this._listeners[evt];
                    if (listeners) if (null != fn) {
                        var index = listeners.indexOf(fn);
                        ~index && listeners.splice(index, 1), listeners.length || delete this._listeners[evt];
                    } else delete this._listeners[evt];
                } else this._listeners = {};
            }, 
            /**
   * Trigger every registered callbacks for a given event
   * @param {string} evt - The event to trigger
   * @param {*} arg - The eventual payload for that event. All triggered
   * callbacks will recieve this payload as argument.
   */
            _proto.trigger = function trigger(evt, arg) {
                var listeners = this._listeners[evt];
                listeners && listeners.slice().forEach(function(listener) {
                    try {
                        listener(arg);
                    } catch (e) {
                        _log__WEBPACK_IMPORTED_MODULE_0__.a.error(e, e.stack);
                    }
                });
            }, EventEmitter;
        }();
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Simple EventEmitted implementation.
 * @class EventEmitter
 */    }, 
    /* 37 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return InnerSubscriber;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), InnerSubscriber = /* */ function(_super) {
            function InnerSubscriber(parent, outerValue, outerIndex) {
                var _this = _super.call(this) || this;
                return _this.parent = parent, _this.outerValue = outerValue, _this.outerIndex = outerIndex, 
                _this.index = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(InnerSubscriber, _super), InnerSubscriber.prototype._next = function(value) {
                this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
            }, InnerSubscriber.prototype._error = function(error) {
                this.parent.notifyError(error, this), this.unsubscribe();
            }, InnerSubscriber.prototype._complete = function() {
                this.parent.notifyComplete(this), this.unsubscribe();
            }, InnerSubscriber;
        }(__webpack_require__(7).a);
        /* harmony import */    }, 
    /* 38 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "c", function() {
            return getTRAF;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return getMDAT;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getMDIA;
        });
        /* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14), _utils_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 'name' of the box (e.g. 'sidx' or 'moov'),
 * hexa encoded
 * @returns {UInt8Array|null}
 */
        function getBox(buf, boxName) {
            for (var name, l = buf.length, i = 0, size = 0; i + 8 < l && (size = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, i), 
            name = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, i + 4), Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__.b)(0 < size, "out of range size"), 
            name !== boxName); ) i += size;
            return i < l ? buf.subarray(i + 8, i + size) : null;
        }
        /**
 * Returns TRAF Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */        function getTRAF(buffer) {
            var moof = getBox(buffer, 1836019558
            /* moof */);
            return moof ? getBox(moof, 1953653094
            /* traf */) : null;
        }
        /**
 * Returns MDAT Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */        function getMDAT(buf) {
            return getBox(buf, 1835295092
            /* "mdat" */);
        }
        /**
 * Returns MDIA Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */        function getMDIA(buf) {
            var moov = getBox(buf, 1836019574
            /* moov */);
            if (!moov) return null;
            var trak = getBox(moov, 1953653099
            /* "trak" */);
            return trak ? getBox(trak, 1835297121
            /* "mdia" */) : null;
        }
        /***/    }, 
    /* 39 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return resolveURL;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return normalizeBaseURL;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // Scheme part of an url (e.g. "http://").
        var schemeRe = /^(?:[a-z]+:)?\/\//i, selfDirRe = /\/\.{1,2}\//;
 // Captures "/../" or "/./".
                /**
 * Resolve self directory and previous directory references to obtain a
 * "normalized" url.
 * @example "https://foo.bar/baz/booz/../biz" => "https://foo.bar/baz/biz"
 * @param {string} url
 * @returns {string}
 */
        function _normalizeUrl(url) {
            // fast path if no ./ or ../ are present in the url
            if (!selfDirRe.test(url)) return url;
            for (var newUrl = [], oldUrl = url.split("/"), i = 0, l = oldUrl.length; i < l; i++) if (".." === oldUrl[i]) newUrl.pop(); else {
                if ("." === oldUrl[i]) continue;
                newUrl.push(oldUrl[i]);
            }
            return newUrl.join("/");
        }
        /**
 * Construct an url from the arguments given.
 * Basically:
 *   - The last arguments that contains a scheme (e.g. "http://") is the base
 *     of the url.
 *   - every subsequent string arguments are concatened to it.
 * @param {...string|undefined} args
 * @returns {string}
 */        function resolveURL() {
            var len = arguments.length;
            if (0 === len) return "";
            for (var base = "", i = 0; i < len; i++) {
                var part = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                "string" == typeof part && "" !== part && (base = schemeRe.test(part) ? part : (
                // trim if begins with "/"
                "/" === part[0] && (part = part.substr(1)), // trim if ends with "/"
                "/" === base[base.length - 1] && (base = base.substr(0, base.length - 1)), base + "/" + part));
            }
            return _normalizeUrl(base);
        }
        /**
 * Remove string after the last '/'.
 * @param {string} url
 * @returns {string}
 */        function normalizeBaseURL(url) {
            var slash = url.lastIndexOf("/");
            return 0 <= slash ? url.substring(0, slash + 1) : url;
        }
        /***/    }, 
    /* 40 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function ObjectUnsubscribedErrorImpl() {
            return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", 
            this;
        }
        __webpack_require__.d(__webpack_exports__, "a", function() {
            return ObjectUnsubscribedError;
        }), ObjectUnsubscribedErrorImpl.prototype = /* */ Object.create(Error.prototype);
        var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
        //# sourceMappingURL=ObjectUnsubscribedError.js.map
        /***/    }, 
    /* 41 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Generate a normalized error message.
 * @param {string} name
 * @param {string} code
 * @param {Error|string|Event|null} [reason]
 * @returns {string}
 */
        function errorMessage(name, code, reason) {
            return null == reason ? name + " (" + code + ")" : "string" == typeof reason ? name + " (" + code + ") " + reason : name + " (" + code + ") " + (reason instanceof Event ? reason.type : reason.message);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return errorMessage;
        });
    }, 
    /* 42 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return map;
        });
        /* unused harmony export MapOperator */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function map(project, thisArg) {
            return function mapOperation(source) {
                if ("function" != typeof project) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
                return source.lift(new MapOperator(project, thisArg));
            };
        }
        var MapOperator = /* */ function() {
            function MapOperator(project, thisArg) {
                this.project = project, this.thisArg = thisArg;
            }
            return MapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
            }, MapOperator;
        }(), MapSubscriber = /* */ function(_super) {
            function MapSubscriber(destination, project, thisArg) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.count = 0, _this.thisArg = thisArg || _this, 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MapSubscriber, _super), MapSubscriber.prototype._next = function(value) {
                var result;
                try {
                    result = this.project.call(this.thisArg, value, this.count++);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(result);
            }, MapSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 43 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return errorObject;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var errorObject = {
            e: {}
        };
        //# sourceMappingURL=errorObject.js.map
        /***/    }, 
    /* 44 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return config;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var _enable_super_gross_mode_that_will_cause_bad_things = !1, config = {
            Promise: void 0,
            set useDeprecatedSynchronousErrorHandling(value) {
                value && /* */ new Error().stack;
                _enable_super_gross_mode_that_will_cause_bad_things = value;
            },
            get useDeprecatedSynchronousErrorHandling() {
                return _enable_super_gross_mode_that_will_cause_bad_things;
            }
        };
    }, 
    /* 45 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return warnOnce;
        });
        /* harmony import */ var _array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13), WARNED_MESSAGES = [];
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * Perform a console.warn only once in the application lifetime.
 *
 * Useful for deprecated messages, for example.
 *
 * @param {string} message
 */
        function warnOnce(message) {
            Object(_array_includes__WEBPACK_IMPORTED_MODULE_0__.a)(WARNED_MESSAGES, message) || (
            /* tslint:disable no-console */
            console.warn(message), 
            /* tslint:enable no-console */
            WARNED_MESSAGES.push(message));
        }
        /***/    }, 
    /* 46 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function noop() {}
        //# sourceMappingURL=noop.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return noop;
        });
    }, 
    /* 47 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isArray;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var isArray = Array.isArray || function(x) {
            return x && "number" == typeof x.length;
        };
        //# sourceMappingURL=isArray.js.map
        /***/    }, 
    /* 48 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return observable;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var observable = "function" == typeof Symbol && Symbol.observable || "@@observable";
        //# sourceMappingURL=observable.js.map
        /***/    }, 
    /* 49 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isFunction(x) {
            return "function" == typeof x;
        }
        //# sourceMappingURL=isFunction.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isFunction;
        });
    }, 
    /* 50 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return tryCatch;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Function} func - A function you want to execute
 * @param {*} args - The function's argument
 * @returns {*} - If it fails, returns a throwing Observable, else the
 * function's result (which should be, in most cases, an Observable).
 */        function tryCatch(func, args) {
            try {
                return func(args);
            } catch (e) {
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(e);
            }
        }
        /***/    }, 
    /* 51 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns first line after the WEBVTT header.
 * That is, the line after the first blank line after the first line!
 * @param {Array.<string>} linified
 * @returns {Number}
 */
        function getFirstLineAfterHeader(linified) {
            for (var i = 0; i < linified.length; ) {
                if ("" === linified[i]) return i + 1;
                i++;
            }
            return i;
        }
        /**
 * Returns true if the given line looks like the beginning of a Style block.
 * @param {string} text
 * @returns {Boolean}
 */        function isStartOfStyleBlock(lines, index) {
            return !!lines[index] && /^STYLE( .*)?$/g.test(lines[index]) && (// A cue identifer can also contain "STYLe". Check that we have no timings
            // on the second line
            !lines[index + 1] || lines[index + 1].indexOf("--\x3e") < 0);
        }
        /**
 * Returns true if the given line looks like the beginning of a comment block.
 * @param {string} text
 * @returns {Boolean}
 */        function isStartOfNoteBlock(lines, index) {
            return !!lines[index] && /^NOTE( .*)?$/g.test(lines[index]) && (// A cue identifer can also contain "NOTE". Check that we have no timings
            // on the second line
            !lines[index + 1] || lines[index + 1].indexOf("--\x3e") < 0);
        }
        /**
 * Returns true if the given line looks like the beginning of a region block.
 * @param {string} text
 * @returns {Boolean}
 */        function isStartOfRegionBlock(lines, index) {
            return !!lines[index] && /^REGION( .*)?$/g.test(lines[index]) && (// A cue identifer can also contain "REGION". Check that we have no timings
            // on the second line
            !lines[index + 1] || lines[index + 1].indexOf("--\x3e") < 0);
        }
        /**
 * Returns true if the line given looks like the beginning of a cue.
 * You should provide to this function only lines following "empty" lines.
 * @param {Array.<string>} lines
 * @param {number} index
 * @returns {Boolean}
 */        function isStartOfCueBlock(lines, index) {
            // checked cases:
            //   - empty lines
            //   - start of a comment
            //   - start of a region
            //   - start of a style
            // Anything else whose first or second line is a timestamp line is a cue.
            var firstLine = lines[index];
            if (!firstLine || isStartOfStyleBlock(lines, index) || isStartOfRegionBlock(lines, index) || isStartOfNoteBlock(lines, index)) return !1;
            if (0 <= firstLine.indexOf("--\x3e")) return !0;
            var secondLine = lines[index + 1];
            return !!secondLine && 0 <= secondLine.indexOf("--\x3e");
        }
        /**
 * Find end of current WebVTT cue block.
 * @param {Array<string>} linified
 * @param {number} startOfCueBlock
 * @returns {number}
 */        function findEndOfCueBlock(linified, startOfCueBlock) {
            // continue incrementing i until either:
            //   - empty line
            //   - end
            for (var firstEmptyLineIndex = startOfCueBlock + 1; linified[firstEmptyLineIndex]; ) firstEmptyLineIndex++;
            return firstEmptyLineIndex;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "b", function() {
            return getFirstLineAfterHeader;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return isStartOfCueBlock;
        }), 
        /* unused harmony export isStartOfNoteBlock */
        /* unused harmony export isStartOfRegionBlock */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return isStartOfStyleBlock;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return findEndOfCueBlock;
        });
    }, 
    /* 52 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function hostReportError(err) {
            setTimeout(function() {
                throw err;
            });
        }
        //# sourceMappingURL=hostReportError.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return hostReportError;
        });
    }, 
    /* 53 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* unused harmony export getSymbolIterator */
        /* harmony export (binding) */        
        /* unused harmony export $$iterator */
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function getSymbolIterator() {
            return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator";
        }
        __webpack_require__.d(__webpack_exports__, "a", function() {
            return iterator;
        });
        var iterator = /* */ getSymbolIterator();
    }, 
    /* 54 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Request fullScreen action on a given element.
 * @param {HTMLElement} elt
 * rs-detect)
 */
        function requestFullscreen(element) {
            if (!isFullscreen()) {
                var elt = element;
                elt.requestFullscreen ? 
                /* tslint:disable no-floating-promises */
                elt.requestFullscreen() : elt.msRequestFullscreen ? elt.msRequestFullscreen() : elt.mozRequestFullScreen ? elt.mozRequestFullScreen() : elt.webkitRequestFullscreen && elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
        }
        /**
 * Exit fullscreen if an element is currently in fullscreen.
 */        function exitFullscreen() {
            if (isFullscreen()) {
                var doc = document;
                doc.exitFullscreen ? 
                /* tslint:disable no-floating-promises */
                doc.exitFullscreen() : doc.msExitFullscreen ? doc.msExitFullscreen() : doc.mozCancelFullScreen ? doc.mozCancelFullScreen() : doc.webkitExitFullscreen && doc.webkitExitFullscreen();
            }
        }
        /**
 * Returns true if an element in the document is being displayed in fullscreen
 * mode;
 * otherwise it's false.
 * @returns {boolean}
 */        function isFullscreen() {
            var doc = document;
            return !!(doc.fullscreenElement || doc.mozFullScreenElement || doc.webkitFullscreenElement || doc.msFullscreenElement);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "c", function() {
            return requestFullscreen;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return exitFullscreen;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return isFullscreen;
        });
    }, 
    /* 55 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return rxSubscriber;
        });
        /* unused harmony export $$rxSubscriber */
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var rxSubscriber = "function" == typeof Symbol ? /* */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* */ Math.random();
    }, 
    /* 56 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        var callable, byObserver;
        callable = function(fn) {
            if ("function" != typeof fn) throw new TypeError(fn + " is not a function");
            return fn;
        }, byObserver = function(Observer) {
            var queue, currentQueue, node = document.createTextNode(""), i = 0;
            return new Observer(function() {
                var callback;
                if (queue) currentQueue && (queue = currentQueue.concat(queue)); else {
                    if (!currentQueue) return;
                    queue = currentQueue;
                }
                if (currentQueue = queue, queue = null, "function" == typeof currentQueue) return callback = currentQueue, 
                currentQueue = null, void callback();
                // Invoke other batch, to handle leftover callbacks in case of crash
                for (node.data = i = ++i % 2; currentQueue; ) callback = currentQueue.shift(), currentQueue.length || (currentQueue = null), 
                callback();
            }).observe(node, {
                characterData: !0
            }), function(fn) {
                callable(fn), queue ? "function" == typeof queue ? queue = [ queue, fn ] : queue.push(fn) : (queue = fn, 
                node.data = i = ++i % 2);
            };
        }, module.exports = function() {
            // Node.js
            if ("object" == typeof process && process && "function" == typeof process.nextTick) return process.nextTick;
            // MutationObserver
                        if ("object" == typeof document && document) {
                if ("function" == typeof MutationObserver) return byObserver(MutationObserver);
                if ("function" == typeof WebKitMutationObserver) return byObserver(WebKitMutationObserver);
            }
            // W3C Draft
            // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
                        return "function" == typeof setImmediate ? function(cb) {
                setImmediate(callable(cb));
            } : 
            // Wide available standard
            "function" == typeof setTimeout || "object" == typeof setTimeout ? function(cb) {
                setTimeout(callable(cb), 0);
            } : null;
        }();
    }, 
    /* 57 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mergeMap;
        });
        /* unused harmony export MergeMapOperator */
        /* unused harmony export MergeMapSubscriber */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23), _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37), _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(42), _observable_from__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
        function mergeMap(project, resultSelector, concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), "function" == typeof resultSelector ? function(source) {
                return source.pipe(mergeMap(function(a, i) {
                    return Object(_observable_from__WEBPACK_IMPORTED_MODULE_5__.a)(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_4__.a)(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }, concurrent));
            } : ("number" == typeof resultSelector && (concurrent = resultSelector), function(source) {
                return source.lift(new MergeMapOperator(project, concurrent));
            });
        }
        var MergeMapOperator = /* */ function() {
            function MergeMapOperator(project, concurrent) {
                void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), this.project = project, 
                this.concurrent = concurrent;
            }
            return MergeMapOperator.prototype.call = function(observer, source) {
                return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
            }, MergeMapOperator;
        }(), MergeMapSubscriber = /* */ function(_super) {
            function MergeMapSubscriber(destination, project, concurrent) {
                void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY);
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.concurrent = concurrent, _this.hasCompleted = !1, 
                _this.buffer = [], _this.active = 0, _this.index = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MergeMapSubscriber, _super), MergeMapSubscriber.prototype._next = function(value) {
                this.active < this.concurrent ? this._tryNext(value) : this.buffer.push(value);
            }, MergeMapSubscriber.prototype._tryNext = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.active++, this._innerSub(result, value, index);
            }, MergeMapSubscriber.prototype._innerSub = function(ish, value, index) {
                var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__.a(this, void 0, void 0);
                this.destination.add(innerSubscriber), Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__.a)(this, ish, value, index, innerSubscriber);
            }, MergeMapSubscriber.prototype._complete = function() {
                this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), 
                this.unsubscribe();
            }, MergeMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, MergeMapSubscriber.prototype.notifyComplete = function(innerSub) {
                var buffer = this.buffer;
                this.remove(innerSub), this.active--, 0 < buffer.length ? this._next(buffer.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete();
            }, MergeMapSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__.a);
    }, 
    /* 58 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/array-find/find.js
                var find = __webpack_require__(11), find_default = /* */ __webpack_require__.n(find), array_includes = __webpack_require__(13);
        // CONCATENATED MODULE: ./src/utils/starts-with.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * String.prototype.startsWith ponyfill.
 * Indicates Whether a string starts with another substring.
 *
 * Inspired from MDN polyfill, but ponyfilled instead.
 * @param {string} completeString
 * @param {string} searchString
 * @param {number} [position]
 * @returns {boolean}
 */
        function startsWith(completeString, searchString, position) {
            /* tslint:disable no-unbound-method */
            return "function" == typeof String.prototype.startsWith ? completeString.startsWith(searchString, position) : completeString.substr(position || 0, searchString.length) === searchString;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/style.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Retrieve the attributes given in arguments in the given nodes and their
 * associated style(s)/region.
 * The first notion of the attribute encountered will be taken (by looping
 * through the given nodes in order).
 *
 * TODO manage IDREFS (plural) for styles and regions, that is, multiple one
 * @param {Array.<string>} attributes
 * @param {Array.<Node>} nodes
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @returns {Object}
 */
        function getStylingAttributes(attributes, nodes, styles, regions) {
            for (var currentStyle = {}, leftAttributes = attributes.slice(), i = 0; i <= nodes.length - 1; i++) {
                var node = nodes[i];
                if (node) {
                    var _ret = function() {
                        var styleID = void 0, regionID = void 0;
                        // 1. the style is directly set on a "tts:" attribute
                        if (node.nodeType === Node.ELEMENT_NODE) for (var element = node, j = 0; j <= element.attributes.length - 1; j++) {
                            var attribute = element.attributes[j], name = attribute.name;
                            if ("style" === name) styleID = attribute.value; else if ("region" === name) regionID = attribute.value; else {
                                var nameWithoutTTS = name.substr(4);
                                if (Object(array_includes.a)(leftAttributes, nameWithoutTTS) && (currentStyle[nameWithoutTTS] = attribute.value, 
                                leftAttributes.splice(j, 1), !leftAttributes.length)) return {
                                    v: currentStyle
                                };
                            }
                        }
 // 2. the style is referenced on a "style" attribute
                                                if (styleID) {
                            var style = find_default()(styles, function(x) {
                                return x.id === styleID;
                            });
                            if (style) for (var _j = 0; _j <= leftAttributes.length - 1; _j++) {
                                var _attribute = leftAttributes[_j];
                                if (!currentStyle[_attribute] && style.style[_attribute]) {
                                    if (currentStyle[_attribute] = style.style[_attribute], leftAttributes.splice(_j, 1), 
                                    !leftAttributes.length) return {
                                        v: currentStyle
                                    };
                                    _j--;
                                }
                            }
                        }
 // 3. the node reference a region (which can have a value for the
                        //    corresponding style)
                                                if (regionID) {
                            var region = find_default()(regions, function(x) {
                                return x.id === regionID;
                            });
                            if (region) for (var _j2 = 0; _j2 <= leftAttributes.length - 1; _j2++) {
                                var _attribute2 = leftAttributes[_j2];
                                if (!currentStyle[_attribute2] && region.style[_attribute2]) {
                                    if (currentStyle[_attribute2] = region.style[_attribute2], leftAttributes.splice(_j2, 1), 
                                    !leftAttributes.length) return {
                                        v: currentStyle
                                    };
                                    _j2--;
                                }
                            }
                        }
                    }();
                    if ("object" == typeof _ret) return _ret.v;
                }
            }
            return currentStyle;
        }
        /**
 * Returns the styling directly linked to an element.
 * @param {Node} node
 * @returns {Object}
 */        function getStylingFromElement(node) {
            if (node.nodeType !== Node.ELEMENT_NODE) return {};
            for (var element = node, currentStyle = {}, i = 0; i <= element.attributes.length - 1; i++) {
                var styleAttribute = element.attributes[i];
                if (startsWith(styleAttribute.name, "tts")) currentStyle[styleAttribute.name.substr(4)] = styleAttribute.value;
            }
            return currentStyle;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getStylingAttributes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getStylingFromElement;
        });
    }, 
    /* 59 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return SimpleSet;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Simple hash-based set.
 * @class SimpleSet
 */
        var SimpleSet = 
        /* */
        function() {
            function SimpleSet() {
                this._hashes = {};
            }
            /**
   * Add a new hash entry in the set.
   * Do not have any effect on already-added hashes
   * @param {string|number} x
   */            var _proto = SimpleSet.prototype;
            return _proto.add = function add(x) {
                this._hashes[x] = !0;
            }, 
            /**
   * Remove an hash entry from the set.
   * Do not have any effect on already-removed or inexistant hashes
   * @param {string|number} x
   */
            _proto.remove = function remove(x) {
                delete this._hashes[x];
            }, 
            /**
   * Test if the given hash has an entry in the set.
   * @param {string|number} x
   * @returns {boolean}
   */
            _proto.test = function test(x) {
                return !!this._hashes[x];
            }, 
            /**
   * Returns true if there's currently no hash in this set.
   * @returns {boolean}
   */
            _proto.isEmpty = function isEmpty() {
                return !Object.keys(this._hashes).length;
            }, SimpleSet;
        }();
        /***/    }, 
    /* 60 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the parent elements which have the given tagName, by order of
 * closeness relative to our element.
 * @param {Element|Node} element
 * @param {string} tagName
 * @returns {Array.<Element>}
 */
        function getParentElementsByTagName(element, tagName) {
            if (!(element.parentNode instanceof Element)) return [];
            return function constructArray(_element) {
                var elements = [];
                _element.tagName.toLowerCase() === tagName.toLowerCase() && elements.push(_element);
                var parentNode = _element.parentNode;
                return parentNode instanceof Element && elements.push.apply(elements, constructArray(parentNode)), 
                elements;
            }(element.parentNode);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getParentElementsByTagName;
        });
    }, 
    /* 61 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = function(arr, predicate, ctx) {
            if ("function" == typeof Array.prototype.findIndex) return arr.findIndex(predicate, ctx);
            if ("function" != typeof predicate) throw new TypeError("predicate must be a function");
            var list = Object(arr), len = list.length;
            if (0 === len) return -1;
            for (var i = 0; i < len; i++) if (predicate.call(ctx, list[i], i, list)) return i;
            return -1;
        };
    }, 
    /* 62 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return empty;
        });
        /* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(44), _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52), empty = {
            closed: !0,
            next: function(value) {},
            error: function(err) {
                if (_config__WEBPACK_IMPORTED_MODULE_0__.a.useDeprecatedSynchronousErrorHandling) throw err;
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__.a)(err);
            },
            complete: function() {}
        };
        /* harmony import */    }, 
    /* 63 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return tryCatch;
        });
        /* harmony import */ var tryCatchTarget, _errorObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);
        /** PURE_IMPORTS_START _errorObject PURE_IMPORTS_END */        function tryCatcher() {
            try {
                return tryCatchTarget.apply(this, arguments);
            } catch (e) {
                return _errorObject__WEBPACK_IMPORTED_MODULE_0__.a.e = e, _errorObject__WEBPACK_IMPORTED_MODULE_0__.a;
            }
        }
        function tryCatch(fn) {
            return tryCatchTarget = fn, tryCatcher;
        }
        //# sourceMappingURL=tryCatch.js.map
        /***/    }, 
    /* 64 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return of;
        });
        /* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31), _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26), _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27), _scalar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(76);
        /* harmony import */        
        /** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */
        function of() {
            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
            var scheduler = args[args.length - 1];
            switch (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.a)(scheduler) ? args.pop() : scheduler = void 0, 
            args.length) {
              case 0:
                return Object(_empty__WEBPACK_IMPORTED_MODULE_2__.b)(scheduler);

              case 1:
                return scheduler ? Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__.a)(args, scheduler) : Object(_scalar__WEBPACK_IMPORTED_MODULE_3__.a)(args[0]);

              default:
                return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__.a)(args, scheduler);
            }
        }
        //# sourceMappingURL=of.js.map
        /***/    }, 
    /* 65 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return getFuzzedDelay;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return getBackedoffDelay;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var FUZZ_FACTOR = .3;
        /**
 * Perform "fuzzing" on the delay given.
 * @param {Number} retryDelay
 * @returns {Number}
 */        function getFuzzedDelay(retryDelay) {
            return retryDelay * ((2 * Math.random() - 1) * FUZZ_FACTOR + 1);
 // Max 1.3 Min 0.7
                }
        /**
 * Calculate a "backed off" fuzzed delay.
 * That is, a delay augmented depending on the current retry count.
 * @param {Number} retryDelay
 * @param {Number} [retryCount=1]
 * @returns {Number}
 */        function getBackedoffDelay(retryDelay, retryCount) {
            return void 0 === retryCount && (retryCount = 1), getFuzzedDelay(retryDelay * Math.pow(2, retryCount - 1));
        }
        /***/    }, 
    /* 66 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isNumeric;
        });
        /* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);
        /** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */        function isNumeric(val) {
            return !Object(_isArray__WEBPACK_IMPORTED_MODULE_0__.a)(val) && 0 <= val - parseFloat(val) + 1;
        }
        //# sourceMappingURL=isNumeric.js.map
        /***/    }, 
    /* 67 */ 
    /* 68 */
    /***/ , 
    /* 68 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isObject(x) {
            return null != x && "object" == typeof x;
        }
        //# sourceMappingURL=isObject.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isObject;
        });
    }, 
    /* 69 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeTo;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), _subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72), _subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74), _subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75), _subscribeToObservable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(70), _isArrayLike__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(71), _isPromise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(73), _isObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(68), _symbol_iterator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(53), _symbol_observable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(48), subscribeTo = function(result) {
            if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.a) return function(subscriber) {
                return result._isScalar ? (subscriber.next(result.value), void subscriber.complete()) : result.subscribe(subscriber);
            };
            if (result && "function" == typeof result[_symbol_observable__WEBPACK_IMPORTED_MODULE_9__.a]) return Object(_subscribeToObservable__WEBPACK_IMPORTED_MODULE_4__.a)(result);
            if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_5__.a)(result)) return Object(_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__.a)(result);
            if (Object(_isPromise__WEBPACK_IMPORTED_MODULE_6__.a)(result)) return Object(_subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__.a)(result);
            if (result && "function" == typeof result[_symbol_iterator__WEBPACK_IMPORTED_MODULE_8__.a]) return Object(_subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__.a)(result);
            var value = Object(_isObject__WEBPACK_IMPORTED_MODULE_7__.a)(result) ? "an invalid object" : "'" + result + "'";
            throw new TypeError("You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.");
        };
        /* harmony import */    }, 
    /* 70 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToObservable;
        });
        /* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48), subscribeToObservable = function(obj) {
            return function(subscriber) {
                var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__.a]();
                if ("function" != typeof obs.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable");
                return obs.subscribe(subscriber);
            };
        };
        /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */    }, 
    /* 71 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isArrayLike;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var isArrayLike = function(x) {
            return x && "number" == typeof x.length && "function" != typeof x;
        };
        //# sourceMappingURL=isArrayLike.js.map
        /***/    }, 
    /* 72 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToArray;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var subscribeToArray = function(array) {
            return function(subscriber) {
                for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) subscriber.next(array[i]);
                subscriber.closed || subscriber.complete();
            };
        };
        //# sourceMappingURL=subscribeToArray.js.map
        /***/    }, 
    /* 73 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isPromise(value) {
            return value && "function" != typeof value.subscribe && "function" == typeof value.then;
        }
        //# sourceMappingURL=isPromise.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isPromise;
        });
    }, 
    /* 74 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToPromise;
        });
        /* harmony import */ var _hostReportError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52), subscribeToPromise = function(promise) {
            return function(subscriber) {
                return promise.then(function(value) {
                    subscriber.closed || (subscriber.next(value), subscriber.complete());
                }, function(err) {
                    return subscriber.error(err);
                }).then(null, _hostReportError__WEBPACK_IMPORTED_MODULE_0__.a), subscriber;
            };
        };
        /** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */    }, 
    /* 75 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToIterable;
        });
        /* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53), subscribeToIterable = function(iterable) {
            return function(subscriber) {
                for (var iterator = iterable[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__.a](); ;) {
                    var item = iterator.next();
                    if (item.done) {
                        subscriber.complete();
                        break;
                    }
                    if (subscriber.next(item.value), subscriber.closed) break;
                }
                return "function" == typeof iterator.return && subscriber.add(function() {
                    iterator.return && iterator.return();
                }), subscriber;
            };
        };
        /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */    }, 
    /* 76 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return scalar;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */        function scalar(value) {
            var result = new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                subscriber.next(value), subscriber.complete();
            });
            return result._isScalar = !0, result.value = value, result;
        }
        //# sourceMappingURL=scalar.js.map
        /***/    }, 
    /* 77 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return SubjectSubscription;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), SubjectSubscription = /* */ function(_super) {
            function SubjectSubscription(subject, subscriber) {
                var _this = _super.call(this) || this;
                return _this.subject = subject, _this.subscriber = subscriber, _this.closed = !1, 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SubjectSubscription, _super), SubjectSubscription.prototype.unsubscribe = function() {
                if (!this.closed) {
                    this.closed = !0;
                    var subject = this.subject, observers = subject.observers;
                    if (this.subject = null, observers && 0 !== observers.length && !subject.isStopped && !subject.closed) {
                        var subscriberIndex = observers.indexOf(this.subscriber);
                        -1 !== subscriberIndex && observers.splice(subscriberIndex, 1);
                    }
                }
            }, SubjectSubscription;
        }(__webpack_require__(15).a);
        /* harmony import */    }, 
    /* 78 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return throwError;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */        function throwError(error, scheduler) {
            return scheduler ? new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return scheduler.schedule(dispatch, 0, {
                    error: error,
                    subscriber: subscriber
                });
            }) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return subscriber.error(error);
            });
        }
        function dispatch(_a) {
            var error = _a.error;
            _a.subscriber.error(error);
        }
        //# sourceMappingURL=throwError.js.map
        /***/    }, 
    /* 79 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function ArgumentOutOfRangeErrorImpl() {
            return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", 
            this;
        }
        __webpack_require__.d(__webpack_exports__, "a", function() {
            return ArgumentOutOfRangeError;
        }), ArgumentOutOfRangeErrorImpl.prototype = /* */ Object.create(Error.prototype);
        var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
        //# sourceMappingURL=ArgumentOutOfRangeError.js.map
        /***/    }, 
    /* 80 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return EncryptedMediaError;
        });
        /* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19), _errorMessage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
        /* harmony import */        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error linked to the encryption of the media.
 *
 * @class EncryptedMediaError
 * @extends Error
 */        var EncryptedMediaError = 
        /* */
        function(_Error) {
            /**
   * @param {string} code
   * @param {Object} [reason]
   * @Param {Boolean} [fatal]
   */
            function EncryptedMediaError(code, reason, fatal) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_assertThisInitialized(_this)), EncryptedMediaError.prototype), 
                _this.name = "EncryptedMediaError", _this.type = _constants__WEBPACK_IMPORTED_MODULE_0__.b.ENCRYPTED_MEDIA_ERROR, 
                _this.reason = reason, _this.code = _constants__WEBPACK_IMPORTED_MODULE_0__.a.hasOwnProperty(code) ? _constants__WEBPACK_IMPORTED_MODULE_0__.a[code] : "", 
                _this.fatal = !!fatal, _this.message = Object(_errorMessage__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, _this.reason), 
                _this;
            }
            return _inheritsLoose(EncryptedMediaError, _Error), EncryptedMediaError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 81 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return checkManifestIDs;
        });
        /* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0), _utils_array_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Ensure that no two periods, adaptations from the same period and
 * representations from the same adaptation, have the same ID.
 *
 * Log and mutate their ID if not until this is verified.
 *
 * @param {Object} manifest
 */
        function checkManifestIDs(manifest) {
            var periodIDS = [];
            manifest.periods.forEach(function(period) {
                var periodID = period.id;
                if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)(periodIDS, periodID)) {
                    _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Two periods with the same ID found. Updating.");
                    var newID = periodID + "-dup";
                    period.id = newID, checkManifestIDs(manifest), periodIDS.push(newID);
                } else periodIDS.push(periodID);
                var adaptations = period.adaptations, adaptationIDs = [];
                Object.keys(adaptations).forEach(function(type) {
                    (adaptations[type] || []).forEach(function(adaptation) {
                        var adaptationID = adaptation.id;
                        if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)(adaptationIDs, adaptationID)) {
                            _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Two adaptations with the same ID found. Updating.", adaptationID);
                            var _newID = adaptationID + "-dup";
                            adaptation.id = _newID, checkManifestIDs(manifest), adaptationIDs.push(_newID);
                        } else adaptationIDs.push(adaptationID);
                        var representationIDs = [];
                        adaptation.representations.forEach(function(representation) {
                            var representationID = representation.id;
                            if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)(representationIDs, representationID)) {
                                _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Two representations with the same ID found. Updating.", representationID);
                                var _newID2 = representationID + "-dup";
                                representation.id = _newID2, checkManifestIDs(manifest), representationIDs.push(_newID2);
                            } else representationIDs.push(representationID);
                        });
                    });
                });
            });
        }
        /***/    }, 
    /* 82 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Errors linked to the XHR implentation done in the RxPlayer.
 *
 * @class RequestError
 * @extends Error
 */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return RequestError;
        });
        var RequestError = 
        /* */
        function(_Error) {
            /**
   * @param {XMLHttpRequest} xhr
   * @param {string} url
   * @param {string} type
   */
            function RequestError(xhr, url, type) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_assertThisInitialized(_this)), RequestError.prototype), 
                _this.name = "RequestError", _this.url = url, _this.xhr = xhr, _this.status = xhr.status, 
                _this.type = type, _this.message = type, _this;
            }
            return _inheritsLoose(RequestError, _Error), RequestError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 83 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} tt
 * @returns {Element}
 */
        function getBodyNode(tt) {
            return tt.getElementsByTagName("body")[0];
        }
        /**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */        function getStyleNodes(tt) {
            return tt.getElementsByTagName("style");
        }
        /**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */        function getRegionNodes(tt) {
            return tt.getElementsByTagName("region");
        }
        /**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */        function getTextNodes(tt) {
            return tt.getElementsByTagName("p");
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getBodyNode;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getStyleNodes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getRegionNodes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getTextNodes;
        });
    }, 
    /* 84 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/utils/languages/ISO_639-1_to_ISO_639-3.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Translate ISO 639-1 language codes into ISO 639-3 ones.
 */        var ISO_639_1_to_ISO_639_3 = {
            aa: "aar",
            ab: "abk",
            ae: "ave",
            af: "afr",
            ak: "aka",
            am: "amh",
            an: "arg",
            ar: "ara",
            as: "asm",
            av: "ava",
            ay: "aym",
            az: "aze",
            ba: "bak",
            be: "bel",
            bg: "bul",
            bi: "bis",
            bm: "bam",
            bn: "ben",
            bo: "bod",
            br: "bre",
            bs: "bos",
            ca: "cat",
            ce: "che",
            ch: "cha",
            co: "cos",
            cr: "cre",
            cs: "ces",
            cu: "chu",
            // Old Slavonic, Old Bulgarian
            cv: "chv",
            cy: "cym",
            da: "dan",
            de: "deu",
            dv: "div",
            dz: "dzo",
            ee: "ewe",
            el: "ell",
            en: "eng",
            eo: "epo",
            es: "spa",
            et: "est",
            eu: "eus",
            fa: "fas",
            ff: "ful",
            fi: "fin",
            fj: "fij",
            fo: "fao",
            fr: "fra",
            fy: "fry",
            ga: "gle",
            gd: "gla",
            gl: "glg",
            gn: "grn",
            gu: "guj",
            gv: "glv",
            ha: "hau",
            he: "heb",
            hi: "hin",
            ho: "hmo",
            hr: "hrv",
            ht: "hat",
            hu: "hun",
            hy: "hye",
            hz: "her",
            ia: "ina",
            id: "ind",
            ie: "ile",
            ig: "ibo",
            ii: "iii",
            ik: "ipk",
            io: "ido",
            is: "isl",
            it: "ita",
            iu: "iku",
            ja: "jpn",
            jv: "jav",
            ka: "kat",
            kg: "kon",
            ki: "kik",
            kj: "kua",
            kk: "kaz",
            kl: "kal",
            km: "khm",
            kn: "kan",
            ko: "kor",
            kr: "kau",
            ks: "kas",
            ku: "kur",
            kv: "kom",
            kw: "cor",
            ky: "kir",
            la: "lat",
            lb: "ltz",
            lg: "lug",
            li: "lim",
            ln: "lin",
            lo: "lao",
            lt: "lit",
            lu: "lub",
            lv: "lav",
            mg: "mlg",
            mh: "mah",
            mi: "mri",
            mk: "mkd",
            ml: "mal",
            mn: "mon",
            mr: "mar",
            ms: "msa",
            mt: "mlt",
            my: "mya",
            na: "nau",
            nb: "nob",
            nd: "nde",
            ne: "nep",
            ng: "ndo",
            nl: "nld",
            nn: "nno",
            no: "nor",
            nr: "nbl",
            nv: "nav",
            ny: "nya",
            oc: "oci",
            oj: "oji",
            om: "orm",
            or: "ori",
            os: "oss",
            pa: "pan",
            pi: "pli",
            pl: "pol",
            ps: "pus",
            pt: "por",
            qu: "que",
            rm: "roh",
            rn: "run",
            ro: "ron",
            ru: "rus",
            rw: "kin",
            sa: "san",
            sc: "srd",
            sd: "snd",
            se: "sme",
            sg: "sag",
            si: "sin",
            sk: "slk",
            sl: "slv",
            sm: "smo",
            sn: "sna",
            so: "som",
            sq: "sqi",
            sr: "srp",
            ss: "ssw",
            st: "sot",
            su: "sun",
            sv: "swe",
            sw: "swa",
            ta: "tam",
            te: "tel",
            tg: "tgk",
            th: "tha",
            ti: "tir",
            tk: "tuk",
            tl: "tgl",
            tn: "tsn",
            to: "ton",
            tr: "tur",
            ts: "tso",
            tt: "tat",
            tw: "twi",
            ty: "tah",
            ug: "uig",
            uk: "ukr",
            ur: "urd",
            uz: "uzb",
            ve: "ven",
            vi: "vie",
            vo: "vol",
            wa: "wln",
            wo: "wol",
            xh: "xho",
            yi: "yid",
            yo: "yor",
            za: "zha",
            zh: "zho",
            zu: "zul"
        }, ISO_639_2_to_ISO_639_3 = {
            alb: "sqi",
            arm: "hye",
            baq: "eus",
            bur: "mya",
            chi: "zho",
            cze: "ces",
            dut: "nld",
            fre: "fra",
            geo: "kat",
            ger: "deu",
            gre: "ell",
            ice: "isl",
            mac: "mkd",
            mao: "mri",
            may: "msa",
            per: "fas",
            slo: "slk",
            rum: "ron",
            tib: "bod",
            wel: "cym"
        };
        /* harmony default export */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Normalize language given.
 * Basically:
 *   - converts it to lowercase.
 *   - normalize "base" (what is before the possible first "-") to an ISO639-3
 *     compatible string.
 * @param {string} _language
 * @returns {string}
 */
        function normalize(_language) {
            if (null == _language || "" === _language) return "";
            var fields = ("" + _language).toLowerCase().split("-"), normalizedBase = normalizeBase(fields[0]);
            return normalizedBase && (fields[0] = normalizedBase), fields.join("-");
        }
        /**
 * Normalize language into an ISO639-3 format.
 * @param {string} base
 * @returns {string}
 */        function normalizeBase(base) {
            var result;
            switch (base.length) {
              case 2:
                result = ISO_639_1_to_ISO_639_3[base];
                break;

              case 3:
                result = ISO_639_2_to_ISO_639_3[base];
            }
            return result || base;
        }
        /**
 * Normalize text track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - closedCaption {Boolean}: Whether the track is a closed caption track
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */        function normalizeTextTrack(_language) {
            return null == _language ? _language : (closedCaption = "string" == typeof _language ? (language = _language, 
            !1) : (language = _language.language, !!_language.closedCaption), {
                language: language,
                closedCaption: closedCaption,
                normalized: normalize(language)
            });
            var language, closedCaption;
        }
        /**
 * Normalize audio track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - audioDescription {Boolean}: Whether the track is a closed caption track
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */        function normalizeAudioTrack(_language) {
            return null == _language ? _language : (audioDescription = "string" == typeof _language ? (language = _language, 
            !1) : (language = _language.language, !!_language.audioDescription), {
                language: language,
                audioDescription: audioDescription,
                normalized: normalize(language)
            });
            var language, audioDescription;
        }
        /***/        
        // CONCATENATED MODULE: ./src/utils/languages/index.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return normalize;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return normalizeAudioTrack;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return normalizeTextTrack;
        });
    }, 
    /* 85 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/next-tick/index.js
                var next_tick = __webpack_require__(56), next_tick_default = /* */ __webpack_require__.n(next_tick), of = __webpack_require__(64), eventemitter = __webpack_require__(36), rx_tryCatch = __webpack_require__(50), ranges = __webpack_require__(16), time_ranges_ManualTimeRanges = 
        /* */
        function() {
            function ManualTimeRanges() {
                this._ranges = [], this.length = 0;
            }
            var _proto = ManualTimeRanges.prototype;
            return _proto.insert = function insert(start, end) {
                Object(ranges.h)(this._ranges, {
                    start: start,
                    end: end
                }), this.length = this._ranges.length;
            }, _proto.remove = function remove(start, end) {
                var rangesToIntersect = [];
                0 < start && rangesToIntersect.push({
                    start: 0,
                    end: start
                }), end < Infinity && rangesToIntersect.push({
                    start: end,
                    end: Infinity
                }), this._ranges = Object(ranges.j)(this._ranges, rangesToIntersect), this.length = this._ranges.length;
            }, _proto.start = function start(index) {
                if (index >= this._ranges.length) throw new Error("INDEX_SIZE_ERROR");
                return this._ranges[index].start;
            }, _proto.end = function end(index) {
                if (index >= this._ranges.length) throw new Error("INDEX_SIZE_ERROR");
                return this._ranges[index].end;
            }, ManualTimeRanges;
        }();
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Abstract class for a custom SourceBuffer implementation.
 * @class AbstractSourceBuffer
 * @extends EventEmitter
 */        
        // CONCATENATED MODULE: ./src/core/source_buffers/abstract_source_buffer.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return abstract_source_buffer_AbstractSourceBuffer;
        });
        var abstract_source_buffer_AbstractSourceBuffer = 
        /* */
        function(_EventEmitter) {
            function AbstractSourceBuffer() {
                var _this;
                return (_this = _EventEmitter.call(this) || this).updating = !1, _this.readyState = "opened", 
                _this.buffered = new time_ranges_ManualTimeRanges(), _this.timestampOffset = 0, 
                _this;
            }
            /**
   * Mimic the SourceBuffer _appendBuffer_ method: Append a segment to the
   * buffer.
   * @param {*} data
   */            _inheritsLoose(AbstractSourceBuffer, _EventEmitter);
            var _proto = AbstractSourceBuffer.prototype;
            return _proto.appendBuffer = function appendBuffer(data) {
                var _this2 = this;
                this._lock(function() {
                    return _this2._append(data);
                });
            }, 
            /**
   * Mimic the SourceBuffer _remove_ method: remove buffered segments.
   * @param {Number} from
   * @param {Number} to
   */
            _proto.remove = function remove(from, to) {
                var _this3 = this;
                this._lock(function() {
                    return _this3._remove(from, to);
                });
            }, 
            /**
   * Mimic the SourceBuffer _abort_ method.
   */
            _proto.abort = function abort() {
                this.remove(0, Infinity), this.updating = !1, this.readyState = "closed", this._abort();
            }, 
            /**
   * Active a lock, execute the given function, unlock when finished (on
   * nextTick).
   * Throws if multiple lock are active at the same time.
   * Also triggers the right events on start, error and end
   * @param {Function} func
   */
            _proto._lock = function _lock(func) {
                var _this4 = this;
                if (this.updating) throw new Error("SourceBuffer: SourceBuffer already updating.");
                this.updating = !0, this.trigger("updatestart", void 0), Object(rx_tryCatch.a)(function() {
                    return func(), Object(of.a)(void 0);
                }).subscribe(function() {
                    return next_tick_default()(function() {
                        _this4.updating = !1, _this4.trigger("update", void 0), _this4.trigger("updateend", void 0);
                    });
                }, function(e) {
                    return next_tick_default()(function() {
                        _this4.updating = !1, _this4.trigger("error", e), _this4.trigger("updateend", void 0);
                    });
                });
            }, AbstractSourceBuffer;
        }(eventemitter.a);
        /***/    }, 
    /* 86 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
        var defer = __webpack_require__(134), empty = __webpack_require__(27), combineLatest = __webpack_require__(145), merge = __webpack_require__(135), concat = __webpack_require__(109), of = __webpack_require__(64), ignoreElements = __webpack_require__(144), mergeMap = __webpack_require__(57), map = __webpack_require__(42), tap = __webpack_require__(150), filter = __webpack_require__(137), compat = __webpack_require__(8), events = __webpack_require__(12), log = __webpack_require__(0), noop = __webpack_require__(20), castToObservable = __webpack_require__(18), MediaKeys = __webpack_require__(131);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js
                // CONCATENATED MODULE: ./src/compat/eme/setMediaKeys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Set the MediaKeys given on the media element.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {*}
 */
        function _setMediaKeys(elt, mediaKeys) {
            return mediaKeys instanceof MediaKeys.a ? mediaKeys._setVideo(elt) : elt.setMediaKeys ? elt.setMediaKeys(mediaKeys) : null !== mediaKeys ? elt.WebkitSetMediaKeys ? elt.WebkitSetMediaKeys(mediaKeys) : elt.mozSetMediaKeys ? elt.mozSetMediaKeys(mediaKeys) : elt.msSetMediaKeys ? elt.msSetMediaKeys(mediaKeys) : void 0 : void 0;
        }
        /**
 * Set the given MediaKeys on the given HTMLMediaElement.
 * Emits null when done then complete.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {Observable}
 */        function setMediaKeys$(elt, mediaKeys) {
            return Object(defer.a)(function() {
                return Object(castToObservable.a)(_setMediaKeys(elt, mediaKeys));
            });
        }
        // CONCATENATED MODULE: ./src/core/eme/attach_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Set the MediaKeys object on the HTMLMediaElement if it is not already on the
 * element.
 * If a MediaKeys was already set on it, dispose of it before setting the new
 * one.
 *
 * /!\ Mutates heavily currentMediaKeysInfos
 * @param {Object} mediaKeysInfos
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} currentMediaKeysInfos
 * @returns {Observable}
 */        function attachMediaKeys(mediaKeysInfos, mediaElement, currentMediaKeysInfos) {
            return Object(defer.a)(function() {
                var previousState = currentMediaKeysInfos.getState(mediaElement), keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess, mediaKeys = mediaKeysInfos.mediaKeys, sessionsStore = mediaKeysInfos.sessionsStore;
                return currentMediaKeysInfos.setState(mediaElement, {
                    keySystemOptions: keySystemOptions,
                    mediaKeySystemAccess: mediaKeySystemAccess,
                    mediaKeys: mediaKeys,
                    sessionsStore: sessionsStore
                }), (previousState && previousState.sessionsStore !== sessionsStore ? previousState.sessionsStore.closeAllSessions() : Object(of.a)(null)).pipe(Object(mergeMap.a)(function() {
                    return mediaElement.mediaKeys === mediaKeys ? Object(of.a)(null) : (log.a.debug("EME: Setting MediaKeys"), 
                    setMediaKeys$(mediaElement, mediaKeys));
                }));
            });
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js
                var mergeMapTo = __webpack_require__(143);
        // CONCATENATED MODULE: ./src/core/eme/dispose_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */        function disposeMediaKeys(mediaElement, mediaKeysInfos) {
            return Object(defer.a)(function() {
                var currentState = mediaKeysInfos.getState(mediaElement);
                if (!currentState) return Object(of.a)(null);
                log.a.debug("EME: Disposing of the current MediaKeys");
                var sessionsStore = currentState.sessionsStore;
                return mediaKeysInfos.clearState(mediaElement), sessionsStore.closeAllSessions().pipe(Object(mergeMapTo.a)(setMediaKeys$(mediaElement, null)));
            });
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/catchError.js
                var catchError = __webpack_require__(146), EncryptedMediaError = __webpack_require__(80);
        // EXTERNAL MODULE: ./src/errors/EncryptedMediaError.ts
                // CONCATENATED MODULE: ./src/core/eme/generate_key_request.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Generate a request from session.
 * @param {MediaKeySession} session
 * @param {Uint8Array} initData
 * @param {string} initDataType
 * @param {string} sessionType
 * @returns {Observable}
 */
        function generateKeyRequest(session, initData, initDataType) {
            return Object(defer.a)(function() {
                return log.a.debug("EME: Calling generateRequest on the MediaKeySession"), Object(castToObservable.a)(session.generateRequest(initDataType || "", initData)).pipe(Object(catchError.a)(function(error) {
                    throw new EncryptedMediaError.a("KEY_GENERATE_REQUEST_ERROR", error, !1);
                }));
            });
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                var Observable = __webpack_require__(9), config = __webpack_require__(2), array_includes = __webpack_require__(13), EME_DEFAULT_WIDEVINE_ROBUSTNESSES = config.a.EME_DEFAULT_WIDEVINE_ROBUSTNESSES, EME_KEY_SYSTEMS = config.a.EME_KEY_SYSTEMS;
        // EXTERNAL MODULE: ./src/config.ts
                /**
 * @param {Array.<Object>} keySystems
 * @param {Object} currentMediaKeysInfos
 * @returns {null|Object}
 */
        function checkCachedMediaKeySystemAccess(keySystems, currentKeySystemAccess, currentKeySystemOptions) {
            var mksConfiguration = currentKeySystemAccess.getConfiguration();
 // NOTE(pierre): alwaysRenew flag is used for IE11 which require the
            // creation of a new MediaKeys instance for each session creation
                        if (Object(compat.m)() || !mksConfiguration) return null;
            var firstCompatibleOption = keySystems.filter(function(ks) {
                // TODO Do it with MediaKeySystemAccess.prototype.keySystem instead
                return ks.type === currentKeySystemOptions.type && ((!ks.persistentLicense || "required" === mksConfiguration.persistentState) && (!ks.distinctiveIdentifierRequired || "required" === mksConfiguration.distinctiveIdentifier));
            })[0];
            return firstCompatibleOption ? {
                keySystemOptions: firstCompatibleOption,
                keySystemAccess: currentKeySystemAccess
            } : null;
        }
        /**
 * Find key system canonical name from key system type.
 * @param {string} ksType - Obtained via inversion
 * @returns {string|undefined} - Either the canonical name, or undefined.
 */        function findKeySystemCanonicalName(ksType) {
            for (var _arr = Object.keys(EME_KEY_SYSTEMS), _i = 0; _i < _arr.length; _i++) {
                var ksName = _arr[_i];
                if (Object(array_includes.a)(EME_KEY_SYSTEMS[ksName], ksType)) return ksName;
            }
        }
        /**
 * Build configuration for the requestMediaKeySystemAccess EME API, based
 * on the current keySystem object.
 * @param {string} [ksName] - Generic name for the key system. e.g. "clearkey",
 * "widevine", "playready". Can be used to make exceptions depending on it.
 * @param {Object} keySystem
 * @returns {Array.<Object>} - Configuration to give to the
 * requestMediaKeySystemAccess API.
 */        function buildKeySystemConfigurations(ksName, keySystem) {
            var sessionTypes = [ "temporary" ], persistentState = "optional", distinctiveIdentifier = "optional";
            keySystem.persistentLicense && (persistentState = "required", sessionTypes.push("persistent-license")), 
            keySystem.persistentStateRequired && (persistentState = "required"), keySystem.distinctiveIdentifierRequired && (distinctiveIdentifier = "required");
            // Set robustness, in order of consideration:
            //   1. the user specified its own robustnesses
            //   2. a "widevine" key system is used, in that case set the default widevine
            //      robustnesses as defined in the config
            //   3. set an undefined robustness
            var videoRobustnesses = keySystem.videoRobustnesses || ("widevine" === ksName ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []), audioRobustnesses = keySystem.audioRobustnesses || ("widevine" === ksName ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);
            // TODO Re-test with a set contentType but an undefined robustness on the
            // STBs on which this problem was found.
            //
            // add another with no {audio,video}Capabilities for some legacy browsers.
            // As of today's spec, this should return NotSupported but the first
            // candidate configuration should be good, so we should have no downside
            // doing that.
            // initDataTypes: ["cenc"],
            // videoCapabilities: undefined,
            // audioCapabilities: undefined,
            // distinctiveIdentifier,
            // persistentState,
            // sessionTypes,
            return videoRobustnesses.length || videoRobustnesses.push(void 0), audioRobustnesses.length || audioRobustnesses.push(void 0), 
            [ {
                initDataTypes: [ "cenc" ],
                videoCapabilities: videoRobustnesses.map(function(robustness) {
                    return {
                        contentType: 'video/mp4;codecs="avc1.4d401e"',
                        robustness: robustness
                    };
                }),
                audioCapabilities: audioRobustnesses.map(function(robustness) {
                    return {
                        contentType: 'audio/mp4;codecs="mp4a.40.2"',
                        robustness: robustness
                    };
                }),
                distinctiveIdentifier: distinctiveIdentifier,
                persistentState: persistentState,
                sessionTypes: sessionTypes
            } ];
        }
        /**
 * Try to find a compatible key system from the keySystems array given.
 *
 * Returns an Observable which, when subscribed to, will request a
 * MediaKeySystemAccess based on the various keySystems provided. This
 * Observable will:
 *   - emit the MediaKeySystemAccess and the keySystems as an object, when
 *     found. The object is under this form:
 *     {
 *       keySystemAccess {MediaKeySystemAccess}
 *       keySystem {Object}
 *     }
 *   - complete immediately after emitting.
 *   - throw if no  compatible key system has been found.
 *
 * @param {Array.<Object>} keySystems - The keySystems you want to test.
 * @param {Object} currentMediaKeysInfos
 * @returns {Observable}
 */        function getMediaKeySystemAccess(mediaElement, keySystemsConfigs, currentMediaKeysInfos) {
            return Object(defer.a)(function() {
                var currentState = currentMediaKeysInfos.getState(mediaElement);
                if (currentState) {
                    // Fast way to find a compatible keySystem if the currently loaded
                    // one as exactly the same compatibility options.
                    var cachedKeySystemAccess = checkCachedMediaKeySystemAccess(keySystemsConfigs, currentState.mediaKeySystemAccess, currentState.keySystemOptions);
                    if (cachedKeySystemAccess) return log.a.debug("EME: Found cached compatible keySystem", cachedKeySystemAccess), 
                    Object(of.a)({
                        type: "reuse-media-key-system-access",
                        value: {
                            mediaKeySystemAccess: cachedKeySystemAccess.keySystemAccess,
                            options: cachedKeySystemAccess.keySystemOptions
                        }
                    });
                }
                /**
     * Array of set keySystems for this content.
     * Each item of this array is an object containing the following keys:
     *   - keyName {string}: keySystem canonical name (e.g. "widevine")
     *   - keyType {string}: keySystem type (e.g. "com.widevine.alpha")
     *   - keySystem {Object}: the original keySystem object
     * @type {Array.<Object>}
     */                var keySystemsType = keySystemsConfigs.reduce(function(arr, keySystemOptions) {
                    var ksType, managedRDNs = EME_KEY_SYSTEMS[keySystemOptions.type];
                    null != managedRDNs ? ksType = managedRDNs.map(function(keyType) {
                        return {
                            keyName: keySystemOptions.type,
                            keyType: keyType,
                            keySystemOptions: keySystemOptions
                        };
                    }) : ksType = [ {
                        keyName: findKeySystemCanonicalName(keySystemOptions.type) || "",
                        keyType: keySystemOptions.type,
                        keySystemOptions: keySystemOptions
                    } ];
                    return arr.concat(ksType);
                }, []);
                return Observable.a.create(function(obs) {
                    var sub, disposed = !1;
                    /**
       * Test the key system as defined in keySystemsType[index].
       * @param {Number} index
       */
                    return function testKeySystem(index) {
                        // completely quit the loop if unsubscribed
                        if (!disposed) // if we iterated over the whole keySystemsType Array, quit on error
                        if (index >= keySystemsType.length) obs.error(new EncryptedMediaError.a("INCOMPATIBLE_KEYSYSTEMS", null, !0)); else {
                            var _keySystemsType$index = keySystemsType[index], keyName = _keySystemsType$index.keyName, keyType = _keySystemsType$index.keyType, keySystemOptions = _keySystemsType$index.keySystemOptions, keySystemConfigurations = buildKeySystemConfigurations(keyName, keySystemOptions);
                            if (log.a.debug("EME: Request keysystem access " + keyType + "," + (index + 1) + " of " + keySystemsType.length, keySystemConfigurations), 
                            null == MediaKeys.b) throw new Error("requestMediaKeySystemAccess is not implemented in your browser.");
                            sub = Object(MediaKeys.b)(keyType, keySystemConfigurations).subscribe(function(keySystemAccess) {
                                log.a.info("EME: Found compatible keysystem", keyType, keySystemConfigurations), 
                                obs.next({
                                    type: "create-media-key-system-access",
                                    value: {
                                        options: keySystemOptions,
                                        mediaKeySystemAccess: keySystemAccess
                                    }
                                }), obs.complete();
                            }, function() {
                                log.a.debug("EME: Rejected access to keysystem", keyType, keySystemConfigurations), 
                                sub = null, testKeySystem(index + 1);
                            });
                        }
                    }(0), function() {
                        disposed = !0, sub && sub.unsubscribe();
                    };
                });
            });
        }
        // EXTERNAL MODULE: ./node_modules/array-find/find.js
                var find = __webpack_require__(11), find_default = /* */ __webpack_require__.n(find);
        // CONCATENATED MODULE: ./src/utils/hash_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert given buffer to a 32bit integer hash
 * @param {Array.<number>|TypedArray} buffer
 * @returns {number}
 */
        function hashBuffer(buffer) {
            for (var hash = 0, i = 0; i < buffer.length; i++) hash = (hash << 5) - hash + buffer[i], 
            hash &= hash;
            return hash;
        }
        // CONCATENATED MODULE: ./src/core/eme/utils/open_sessions_store.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create and store MediaKeySessions linked to a single MediaKeys
 * instance.
 *
 * Keep track of sessionTypes and of the initialization data each
 * MediaKeySession is created for.
 * @class MediaKeySessionsStore
 */        var open_sessions_store_MediaKeySessionsStore = 
        /* */
        function() {
            function MediaKeySessionsStore(mediaKeys) {
                this._mediaKeys = mediaKeys, this._entries = [];
            }
            /**
   * @returns {Array.<Object>}
   */            var _proto = MediaKeySessionsStore.prototype;
            return _proto.getAll = function getAll() {
                return this._entries.map(function(entry) {
                    return {
                        session: entry.session,
                        sessionType: entry.sessionType
                    };
                });
            }, 
            /**
   * Returns an entry in this cache with the initData and initDataType given.
   * null if no such session is stored.
   *
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {Object|null}
   */
            _proto.get = function get(initData, initDataType) {
                var initDataHash = hashBuffer(initData), foundEntry = find_default()(this._entries, function(entry) {
                    return entry.initData === initDataHash && entry.initDataType === initDataType;
                });
                return foundEntry ? {
                    session: foundEntry.session,
                    sessionType: foundEntry.sessionType
                } : null;
            }, 
            /**
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @param {string} sessionType
   * @returns {MediaKeySession}
   * @throws {EncryptedMediaError}
   */
            _proto.createSession = function createSession(initData, initDataType, sessionType) {
                var _this = this;
                if (this.get(initData, initDataType)) {
                    var error = new Error("This initialization data was already stored.");
                    throw new EncryptedMediaError.a("MULTIPLE_SESSIONS_SAME_INIT_DATA", error, !0);
                }
                var session = this._mediaKeys
                /* TS bug */ .createSession(sessionType), entry = {
                    session: session,
                    sessionType: sessionType,
                    initData: hashBuffer(initData),
                    initDataType: initDataType
                };
                return null !== session.closed && session.closed.then(function() {
                    _this._delete(session);
                }).catch(function(e) {
                    log.a.warn("EME-MKSS: session.closed rejected: " + e);
                }), log.a.debug("EME-MKSS: Add session", entry), this._entries.push(entry), session;
            }, 
            /**
   * Close a MediaKeySession and remove its entry if it's found in the store.
   * @param {MediaKeySession} session
   * @returns {Observable}
   */
            _proto.deleteAndCloseSession = function deleteAndCloseSession(session) {
                var _this2 = this;
                return Object(defer.a)(function() {
                    return _this2._delete(session), log.a.debug("EME-MKSS: Close session", session), 
                    Object(castToObservable.a)(session.close()).pipe(Object(catchError.a)(function() {
                        return Object(of.a)(null);
                    }));
                });
            }, 
            /**
   * Close all sessions in this store.
   * Emit null when done
   * @returns {Observable}
   */
            _proto.closeAllSessions = function closeAllSessions() {
                var _this3 = this;
                return Object(defer.a)(function() {
                    var previousEntries = _this3._entries;
                    _this3._entries = [];
                    // clean completely the cache first
                    var disposed = previousEntries.map(function(entry) {
                        return _this3.deleteAndCloseSession(entry.session);
                    });
                    return Object(concat.a)(merge.a.apply(void 0, disposed).pipe(Object(ignoreElements.a)()), Object(of.a)(null));
                });
            }, 
            /**
   * Remove a MediaKeySession from the Cache, without closing it.
   * Returns the entry if found, null otherwise.
   * @param {MediaKeySession} session
   * @returns {number} - index of the session in the cache. -1 of not found.
   */
            _proto._delete = function _delete(session) {
                var entry = find_default()(this._entries, function(e) {
                    return e.session === session;
                });
                if (!entry) return -1;
                log.a.debug("EME-MKSS: delete session", entry);
                var idx = this._entries.indexOf(entry);
                return this._entries.splice(idx, 1), idx;
            }, MediaKeySessionsStore;
        }(), assert = __webpack_require__(14);
        // EXTERNAL MODULE: ./src/utils/assert.ts + 1 modules
                // CONCATENATED MODULE: ./src/core/eme/utils/persisted_session_store.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function checkStorage(storage) {
            Object(assert.b)(null != storage, "no licenseStorage given for keySystem with persistentLicense"), 
            Object(assert.a)(storage, {
                save: "function",
                load: "function"
            }, "licenseStorage");
        }
        /**
 * Set representing persisted licenses. Depends on a simple local-
 * storage implementation with a `save`/`load` synchronous interface
 * to persist informations on persisted sessions.
 *
 * This set is used only for a cdm/keysystem with license persistency
 * supported.
 * @class PersistedSessionsStore
 */        var persisted_session_store_PersistedSessionsStore = 
        /* */
        function() {
            /**
   * @param {Object} storage
   */
            function PersistedSessionsStore(storage) {
                checkStorage(storage), this._entries = [], this._storage = storage;
                try {
                    this._entries = this._storage.load(), Object(assert.b)(Array.isArray(this._entries));
                } catch (e) {
                    log.a.warn("EME-PSS: Could not get entries from license storage", e), this.dispose();
                }
            }
            /**
   * Retrieve entry (sessionId + initData) based on its initData.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   * @returns {Object|null}
   */            var _proto = PersistedSessionsStore.prototype;
            return _proto.get = function get(initData, initDataType) {
                var hash = hashBuffer(initData);
                return find_default()(this._entries, function(e) {
                    return e.initData === hash && e.initDataType === initDataType;
                }) || null;
            }, 
            /**
   * Add a new entry in the storage.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   * @param {MediaKeySession} session
   */
            _proto.add = function add(initData, initDataType, session) {
                var sessionId = session && session.sessionId;
                if (sessionId) {
                    var currentEntry = this.get(initData, initDataType);
                    currentEntry && currentEntry.sessionId === sessionId || (currentEntry && 
                    // currentEntry has a different sessionId
                    this.delete(initData, initDataType), log.a.info("EME-PSS: Add new session", sessionId, session), 
                    this._entries.push({
                        sessionId: sessionId,
                        initData: hashBuffer(initData),
                        initDataType: initDataType
                    }), this._save());
                }
            }, 
            /**
   * Delete entry (sessionId + initData) based on its initData.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   */
            _proto.delete = function _delete(initData, initDataType) {
                var hash = hashBuffer(initData), entry = find_default()(this._entries, function(e) {
                    return e.initData === hash && e.initDataType === initDataType;
                });
                if (entry) {
                    log.a.warn("EME-PSS: Delete session from store", entry);
                    var idx = this._entries.indexOf(entry);
                    this._entries.splice(idx, 1), this._save();
                }
            }, 
            /**
   * Delete all saved entries.
   */
            _proto.dispose = function dispose() {
                this._entries = [], this._save();
            }, 
            /**
   * Use the given storage to store the current entries.
   */
            _proto._save = function _save() {
                try {
                    this._storage.save(this._entries);
                } catch (e) {
                    log.a.warn("EME-PSS: Could not save licenses in localStorage");
                }
            }, PersistedSessionsStore;
        }();
        // CONCATENATED MODULE: ./src/core/eme/get_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} keySystemOptions
 * @returns {Object|null}
 * @throws {EncryptedMediaError}
 */        function createSessionStorage(keySystemOptions) {
            if (!keySystemOptions.persistentLicense) return null;
            var licenseStorage = keySystemOptions.licenseStorage;
            if (licenseStorage) return log.a.info("EME: Set the given license storage"), new persisted_session_store_PersistedSessionsStore(licenseStorage);
            var error = new Error("no license storage found for persistent license.");
            throw new EncryptedMediaError.a("INVALID_KEY_SYSTEM", error, !0);
        }
        function getMediaKeysInfos(mediaElement, keySystemsConfigs, currentMediaKeysInfos) {
            return getMediaKeySystemAccess(mediaElement, keySystemsConfigs, currentMediaKeysInfos).pipe(Object(mergeMap.a)(function(evt) {
                var _evt$value = evt.value, options = _evt$value.options, mediaKeySystemAccess = _evt$value.mediaKeySystemAccess, currentState = currentMediaKeysInfos.getState(mediaElement), sessionStorage = createSessionStorage(options);
                if (null == currentState || "reuse-media-key-system-access" !== evt.type) return log.a.debug("EME: Calling createMediaKeys on the MediaKeySystemAccess"), 
                Object(castToObservable.a)(mediaKeySystemAccess.createMediaKeys()).pipe(Object(map.a)(function(mediaKeys) {
                    return {
                        mediaKeys: mediaKeys,
                        sessionsStore: new open_sessions_store_MediaKeySessionsStore(mediaKeys),
                        mediaKeySystemAccess: mediaKeySystemAccess,
                        keySystemOptions: options,
                        sessionStorage: sessionStorage
                    };
                }));
                var mediaKeys = currentState.mediaKeys, sessionsStore = currentState.sessionsStore;
                return Object(of.a)({
                    mediaKeys: mediaKeys,
                    sessionsStore: sessionsStore,
                    mediaKeySystemAccess: mediaKeySystemAccess,
                    keySystemOptions: options,
                    sessionStorage: sessionStorage
                });
            }));
        }
        // EXTERNAL MODULE: ./src/utils/bytes.ts
                var bytes = __webpack_require__(1), simple_set = __webpack_require__(59), PSSH_TO_INTEGER = Object(bytes.c)(Object(bytes.p)("pssh"), 0);
        // EXTERNAL MODULE: ./src/utils/simple_set.ts
                /**
 * As we observed on some browsers (IE and Edge), the initialization data on
 * some segments have sometimes duplicated PSSH when sent through an encrypted
 * event (but not when pushed to the source buffer).
 *
 * This function tries to guess if the initialization data contains only PSSHs
 * concatenated (as it is usually the case).
 * If that's the case, it will filter duplicated PSSHs from it.
 *
 * @param {Uint8Array} initData
 * @returns {Uint8Array}
 */
        function cleanEncryptedEvent(initData) {
            for (var resInitData = new Uint8Array(), currentHashes = new simple_set.a(), offset = 0; offset < initData.length; ) {
                if (initData.length < offset + 8 || Object(bytes.c)(initData, offset + 4) !== PSSH_TO_INTEGER) return log.a.warn("unrecognized initialization data. Use as is."), 
                initData;
                var len = Object(bytes.c)(new Uint8Array(initData), offset);
                if (offset + len > initData.length) return log.a.warn("unrecognized initialization data. Use as is."), 
                initData;
                var currentPSSH = initData.subarray(offset, offset + len), currentPSSHHash = hashBuffer(currentPSSH);
                currentHashes.test(currentPSSHHash) ? log.a.warn("Duplicated PSSH found in initialization data, removing it.") : (currentHashes.add(currentPSSHHash), 
                resInitData = Object(bytes.h)(resInitData, currentPSSH)), offset += len;
            }
            return offset !== initData.length ? (log.a.warn("unrecognized initialization data. Use as is."), 
            initData) : resInitData;
        }
        /**
 * Take out the two things we need on an encryptedEvent:
 *   - the initialization Data
 *   - the initialization Data type
 *
 * @param {MediaEncryptedEvent} encryptedEvent
 * @returns {Object}
 * @throws {EncryptedMediaError} - Throws if no initialization data is
 * encountered in the given event.
 */        function getInitData(encryptedEvent) {
            var initData = encryptedEvent.initData;
            if (null != initData) return {
                initData: cleanEncryptedEvent(new Uint8Array(initData)),
                initDataType: encryptedEvent.initDataType
            };
            var error = new Error("no init data found on media encrypted event.");
            throw new EncryptedMediaError.a("INVALID_ENCRYPTED_EVENT", error, !0);
        }
        // CONCATENATED MODULE: ./src/core/eme/utils/is_session_usable.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * If all key statuses attached to session are valid (either not
 * "expired" or "internal-error"), return true.
 * If not, return false.
 * @param {Uint8Array} initData
 * @param {MediaKeySession} loadedSession
 * @returns {MediaKeySession}
 */        function isSessionUsable(loadedSession) {
            if ("" === loadedSession.sessionId) return !1;
 // TODO TypeScript f*cked something up, normally there should be no need to
            // add this "as".
                        var keyStatusesMap = loadedSession.keyStatuses, keyStatuses = [];
            return keyStatusesMap.forEach(function(keyStatus) {
                keyStatuses.push(keyStatus);
            }), 0 < keyStatuses.length && !Object(array_includes.a)(keyStatuses, "expired") && !Object(array_includes.a)(keyStatuses, "internal-error") && (log.a.debug("EME: Reuse loaded session", loadedSession.sessionId), 
            !0);
        }
        // CONCATENATED MODULE: ./src/core/eme/create_session.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * If session creating fails, retry once session creation/loading.
 * Emit true, if it has succeeded to load, false if there is no data for the
 * given sessionId.
 * @param {string} sessionId
 * @param {MediaKeySession} session
 * @returns {Observable}
 */        function loadPersistentSession(sessionId, session) {
            return Object(defer.a)(function() {
                return log.a.debug("EME: Load persisted session", sessionId), Object(castToObservable.a)(session.load(sessionId));
            });
        }
        /**
 * Create a new Session on the given MediaKeys, corresponding to the given
 * initializationData.
 * If session creating fails, remove the oldest MediaKeySession loaded and
 * retry.
 *
 * /!\ This only creates new sessions.
 * It will fail if sessionsStore already has a MediaKeySession with
 * the given initializationData.
 * @param {Uint8Array} initData
 * @param {string|undefined} initDataType
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */        function create_session_createSession(initData, initDataType, mediaKeysInfos) {
            return Object(defer.a)(function() {
                var keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess, sessionsStore = mediaKeysInfos.sessionsStore, sessionStorage = mediaKeysInfos.sessionStorage, sessionTypes = mediaKeySystemAccess.getConfiguration().sessionTypes, hasPersistence = sessionTypes && Object(array_includes.a)(sessionTypes, "persistent-license"), sessionType = hasPersistence && sessionStorage && keySystemOptions.persistentLicense ? "persistent-license" : "temporary";
                log.a.debug("EME: Create a new " + sessionType + " session");
                var session = sessionsStore.createSession(initData, initDataType, sessionType);
 // Re-check for Dumb typescript
                                if (!hasPersistence || !sessionStorage || !keySystemOptions.persistentLicense) return Object(of.a)({
                    type: "created-session",
                    value: {
                        mediaKeySession: session,
                        sessionType: sessionType
                    }
                });
                var storedEntry = sessionStorage.get(initData, initDataType);
                if (!storedEntry) return Object(of.a)({
                    type: "created-session",
                    value: {
                        mediaKeySession: session,
                        sessionType: sessionType
                    }
                });
                /**
     * Helper function to close and restart the current persistent session
     * considered, and re-create it from scratch.
     * @returns {Observable}
     */                var recreatePersistentSession = function recreatePersistentSession() {
                    return log.a.info("EME: Removing previous persistent session."), null !== sessionStorage.get(initData, initDataType) && sessionStorage.delete(initData, initDataType), 
                    sessionsStore.deleteAndCloseSession(session).pipe(Object(map.a)(function() {
                        return {
                            type: "created-session",
                            value: {
                                mediaKeySession: sessionsStore.createSession(initData, initDataType, sessionType),
                                sessionType: sessionType
                            }
                        };
                    }));
                };
                return loadPersistentSession(storedEntry.sessionId, session).pipe(Object(mergeMap.a)(function(hasLoadedSession) {
                    return hasLoadedSession ? hasLoadedSession && isSessionUsable(session) ? (sessionStorage.add(initData, initDataType, session), 
                    log.a.info("EME: Succeeded to load persistent session."), Object(of.a)({
                        type: "loaded-persistent-session",
                        value: {
                            mediaKeySession: session,
                            sessionType: sessionType
                        }
                    })) : (// Unusable persistent session: recreate a new session from scratch.
                    log.a.warn("EME: Previous persistent session not usable anymore."), recreatePersistentSession()) : (log.a.warn("EME: No data stored for the loaded session"), 
                    sessionStorage.delete(initData, initDataType), Object(of.a)({
                        type: "created-session",
                        value: {
                            mediaKeySession: session,
                            sessionType: sessionType
                        }
                    }));
                }), Object(catchError.a)(function() {
                    return log.a.warn("EME: Unable to load persistent session."), recreatePersistentSession();
                }));
            });
        }
        // CONCATENATED MODULE: ./src/core/eme/get_session.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var MAX_SESSIONS = config.a.EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS;
        /**
 * Handle MediaEncryptedEvents sent by a HTMLMediaElement:
 * Either create a session, skip the event if it is already handled or
 * recuperate a previous session and returns it.
 * @param {Event} encryptedEvent
 * @param {Object} handledInitData
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */        function getSession(encryptedEvent, handledInitData, mediaKeysInfos) {
            return Object(defer.a)(function() {
                var _getInitData = getInitData(encryptedEvent), initData = _getInitData.initData, initDataType = _getInitData.initDataType;
                if (handledInitData.has(initData, initDataType)) return log.a.debug("EME: Init data already received. Skipping it."), 
                empty.a;
 // Already handled, quit
                                handledInitData.add(initData, initDataType);
                // possible previous loaded session with the same initialization data
                var previousLoadedSession = null, sessionsStore = mediaKeysInfos.sessionsStore, entry = sessionsStore.get(initData, initDataType);
                if (null != entry) {
                    if (isSessionUsable(previousLoadedSession = entry.session)) return log.a.debug("EME: Reuse loaded session", previousLoadedSession.sessionId), 
                    Object(of.a)({
                        type: "loaded-open-session",
                        value: {
                            mediaKeySession: previousLoadedSession,
                            sessionType: entry.sessionType,
                            initData: initData,
                            initDataType: initDataType
                        }
                    });
                    mediaKeysInfos.sessionStorage && mediaKeysInfos.sessionStorage.delete(new Uint8Array(initData), initDataType);
                }
                return (previousLoadedSession ? sessionsStore.deleteAndCloseSession(previousLoadedSession) : Object(of.a)(null)).pipe(Object(mergeMap.a)(function() {
                    var cleaningOldSessions$ = [], entries = sessionsStore.getAll().slice();
                    if (0 < MAX_SESSIONS && MAX_SESSIONS <= entries.length) for (var i = 0; i < MAX_SESSIONS - entries.length + 1; i++) cleaningOldSessions$.push(sessionsStore.deleteAndCloseSession(entries[i].session));
                    return Object(concat.a)(merge.a.apply(void 0, cleaningOldSessions$).pipe(Object(ignoreElements.a)()), create_session_createSession(initData, initDataType, mediaKeysInfos).pipe(Object(map.a)(function(evt) {
                        return {
                            type: evt.type,
                            value: {
                                mediaKeySession: evt.value.mediaKeySession,
                                sessionType: evt.value.sessionType,
                                initData: initData,
                                initDataType: initDataType
                            }
                        };
                    })));
                }));
            });
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
                var Subject = __webpack_require__(33);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/TimeoutError.js
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */        function TimeoutErrorImpl() {
            return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", 
            this;
        }
        TimeoutErrorImpl.prototype = /* */ Object.create(Error.prototype);
        var TimeoutError = TimeoutErrorImpl, scheduler_async = __webpack_require__(34), tslib_es6 = __webpack_require__(3);
        //# sourceMappingURL=TimeoutError.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/async.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isDate.js
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isDate(value) {
            return value instanceof Date && !isNaN(+value);
        }
        //# sourceMappingURL=isDate.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/OuterSubscriber.js
                var OuterSubscriber = __webpack_require__(23), subscribeToResult = __webpack_require__(22);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
        /** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function timeoutWith(due, withObservable, scheduler) {
            return void 0 === scheduler && (scheduler = scheduler_async.a), function(source) {
                var absoluteTimeout = isDate(due), waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
                return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
            };
        }
        var TimeoutWithOperator = /* */ function() {
            function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
                this.waitFor = waitFor, this.absoluteTimeout = absoluteTimeout, this.withObservable = withObservable, 
                this.scheduler = scheduler;
            }
            return TimeoutWithOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new timeoutWith_TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
            }, TimeoutWithOperator;
        }(), timeoutWith_TimeoutWithSubscriber = /* */ function(_super) {
            function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
                var _this = _super.call(this, destination) || this;
                return _this.absoluteTimeout = absoluteTimeout, _this.waitFor = waitFor, _this.withObservable = withObservable, 
                _this.scheduler = scheduler, _this.action = null, _this.scheduleTimeout(), _this;
            }
            return tslib_es6.a(TimeoutWithSubscriber, _super), TimeoutWithSubscriber.dispatchTimeout = function(subscriber) {
                var withObservable = subscriber.withObservable;
                subscriber._unsubscribeAndRecycle(), subscriber.add(Object(subscribeToResult.a)(subscriber, withObservable));
            }, TimeoutWithSubscriber.prototype.scheduleTimeout = function() {
                var action = this.action;
                action ? this.action = action.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
            }, TimeoutWithSubscriber.prototype._next = function(value) {
                this.absoluteTimeout || this.scheduleTimeout(), _super.prototype._next.call(this, value);
            }, TimeoutWithSubscriber.prototype._unsubscribe = function() {
                this.action = null, this.scheduler = null, this.withObservable = null;
            }, TimeoutWithSubscriber;
        }(OuterSubscriber.a), throwError = __webpack_require__(78);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeout.js
        /** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */
        function timeout(due, scheduler) {
            return void 0 === scheduler && (scheduler = scheduler_async.a), timeoutWith(due, Object(throwError.a)(new TimeoutError()), scheduler);
        }
        //# sourceMappingURL=timeout.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatMap.js
                var concatMap = __webpack_require__(148), mapTo = __webpack_require__(149), takeUntil = __webpack_require__(141), errors = __webpack_require__(17), constants = __webpack_require__(19), timer = __webpack_require__(147), backoff = __webpack_require__(65);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
                // CONCATENATED MODULE: ./src/utils/retry.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Simple debounce implementation.
 * @param {Function} fn
 * @param {Number} delay - delay in ms
 * @returns {Function}
 */
        function debounce(fn, delay) {
            var timer = 0;
            return function() {
                timer && clearTimeout(timer), timer = window.setTimeout(fn, delay);
            };
        }
        /**
 * Retry the given observable (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Observable} obs$
 * @param {Object} options - Configuration object.
 * This object contains the following properties:
 *
 *   - retryDelay {Number} - The initial delay, in ms.
 *     This delay will be fuzzed to fall under the range +-30% each time a new
 *     retry is done.
 *     Then, this delay will be multiplied by 2^(n-1), n being the counter of
 *     retry we performed (beginning at 1 for the first retry).
 *
 *   - totalRetry {Number} - The amount of time we should retry. 0
 *     means no retry, 1 means a single retry, Infinity means infinite retry
 *     etc.
 *     If the observable still fails after this number of retry, the error will
 *     be throwed through this observable.
 *
 *   - resetDelay {Number|undefined} - Delay in ms since a retry after which the
 *     counter of retry will be reset if the observable wasn't retried a new
 *     time. 0 / undefined means no delay will be applied.
 *
 *   - shouldRetry {Function|undefined} -  Function which will receive the
 *     observable error each time it fails, and should return a boolean. If this
 *     boolean is false, the error will be directly thrown (without anymore
 *     retry).
 *
 *   - onRetry {Function|undefined} - Function which will be triggered at
 *     each retry. Will receive two arguments:
 *       1. The observable error
 *       2. The current retry count, beginning at 1 for the first retry
 *
 *   - errorSelector {Function|undefined} - If and when the observable will
 *     definitely throw (without retrying), this function will be called with
 *     two arguments:
 *       1. The observable error
 *       2. The final retry count, beginning at 1 for the first retry
 *     The returned value will be what will be thrown by the observable.
 *
 * @returns {Observable}
 * TODO Take errorSelector out. Should probably be entirely managed in the
 * calling code via a catch (much simpler to use and to understand).
 */        function retryObsWithBackoff(obs$, options) {
            var debounceRetryCount, retryDelay = options.retryDelay, totalRetry = options.totalRetry, shouldRetry = options.shouldRetry, resetDelay = options.resetDelay, errorSelector = options.errorSelector, onRetry = options.onRetry, retryCount = 0;
            return null != resetDelay && 0 < resetDelay && (debounceRetryCount = debounce(function() {
                retryCount = 0;
            }, resetDelay)), obs$.pipe(Object(catchError.a)(function(error, source) {
                if (!(!shouldRetry || shouldRetry(error)) || retryCount++ >= totalRetry) throw errorSelector ? errorSelector(error, retryCount) : error;
                onRetry && onRetry(error, retryCount);
                var fuzzedDelay = Object(backoff.a)(retryDelay, retryCount);
                return Object(timer.a)(fuzzedDelay).pipe(Object(mergeMap.a)(function() {
                    return debounceRetryCount && debounceRetryCount(), source;
                }));
            }));
        }
        /**
 * Retry the given function (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Function} func
 * @param {Object} options - Configuration object. @see retryObsWithBackoff
 * @returns {Observable}
 */        
        // EXTERNAL MODULE: ./src/utils/rx-tryCatch.ts
        var rx_tryCatch = __webpack_require__(50), KEY_STATUS_ERRORS = {
            "internal-error": !0,
            expired: !1,
            released: !1,
            "output-restricted": !1,
            "output-downscaled": !1,
            "status-pending": !1
        }, KEY_STATUS_EXPIRED = "expired";
        // CONCATENATED MODULE: ./src/core/eme/types.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // Keys are the different key statuses possible.
        // Values are ``true`` if such key status defines an error
        /* tslint:disable no-object-literal-type-assertion */        
        /**
 * @param {Error|Object} error
 * @param {Boolean} fatal
 * @returns {Error|Object}
 */
        function licenseErrorSelector(error, fatal) {
            return Object(errors.a)(error) && error.type === constants.b.ENCRYPTED_MEDIA_ERROR ? (error.fatal = fatal, 
            error) : new EncryptedMediaError.a("KEY_LOAD_ERROR", error, fatal);
        }
        /**
 * listen to "message" events from session containing a challenge
 * blob and map them to licenses using the getLicense method from
 * selected keySystem.
 * @param {MediaKeySession} session
 * @param {Object} keySystem
 * @param {Subject} errorStream
 * @returns {Observable}
 */        function handleSessionEvents(session, keySystem) {
            log.a.debug("EME: Handle message events", session);
            var sessionWarningSubject$ = new Subject.a(), getLicenseRetryOptions = {
                totalRetry: 2,
                retryDelay: 200,
                errorSelector: function errorSelector(error) {
                    return licenseErrorSelector(error, !0);
                },
                onRetry: function onRetry(error) {
                    return sessionWarningSubject$.next({
                        type: "warning",
                        value: licenseErrorSelector(error, !1)
                    });
                }
            }, keyErrors = Object(events.f)(session).pipe(Object(map.a)(function(error) {
                throw new EncryptedMediaError.a("KEY_ERROR", error, !0);
            })), keyStatusesChanges = Object(events.h)(session).pipe(Object(mergeMap.a)(function(keyStatusesEvent) {
                log.a.debug("EME: keystatuseschange event", session, keyStatusesEvent);
                // find out possible errors associated with this event
                var warnings = [];
                session.keyStatuses.forEach(function(keyStatus, keyId) {
                    // Hack present because the order of the arguments has changed in spec
                    // and is not the same between some versions of Edge and Chrome.
                    if (keyStatus === KEY_STATUS_EXPIRED || keyId === KEY_STATUS_EXPIRED) {
                        var throwOnLicenseExpiration = keySystem.throwOnLicenseExpiration, error = new EncryptedMediaError.a("KEY_STATUS_CHANGE_ERROR", "expired", !1);
                        if (!1 !== throwOnLicenseExpiration) throw error;
                        warnings.push({
                            type: "warning",
                            value: error
                        });
                    }
                    if (KEY_STATUS_ERRORS[keyId]) throw new EncryptedMediaError.a("KEY_STATUS_CHANGE_ERROR", keyId, !0);
                    if (KEY_STATUS_ERRORS[keyStatus]) throw new EncryptedMediaError.a("KEY_STATUS_CHANGE_ERROR", keyStatus, !0);
                });
                var warnings$ = warnings.length ? of.a.apply(void 0, warnings) : empty.a, handledKeyStatusesChange$ = Object(rx_tryCatch.a)(function() {
                    return keySystem && keySystem.onKeyStatusesChange ? Object(castToObservable.a)(keySystem.onKeyStatusesChange(keyStatusesEvent, session)) : empty.a;
                }).pipe().pipe(Object(catchError.a)(function(error) {
                    throw new EncryptedMediaError.a("KEY_STATUS_CHANGE_ERROR", error, !0);
                }), Object(map.a)(function(licenseObject) {
                    return {
                        type: "key-status-change",
                        value: {
                            license: licenseObject
                        }
                    };
                }));
                return Object(concat.a)(warnings$, handledKeyStatusesChange$);
            })), keyMessages$ = Object(events.g)(session).pipe(Object(mergeMap.a)(function(messageEvent) {
                var message = new Uint8Array(messageEvent.message), messageType = messageEvent.messageType || "license-request";
                return log.a.debug("EME: Event message type " + messageType, session, messageEvent), 
                retryObsWithBackoff(Object(defer.a)(function() {
                    var getLicense = keySystem.getLicense(message, messageType);
                    return Object(castToObservable.a)(getLicense).pipe(timeout(1e4), Object(catchError.a)(function(error) {
                        throw error instanceof TimeoutError ? new EncryptedMediaError.a("KEY_LOAD_TIMEOUT", null, !1) : error;
                    }));
                }), getLicenseRetryOptions).pipe(Object(map.a)(function(license) {
                    return {
                        type: messageType,
                        value: {
                            license: license
                        }
                    };
                }));
            })), sessionUpdates = Object(merge.a)(keyMessages$, keyStatusesChanges).pipe(Object(concatMap.a)(function(evt) {
                if ("warning" === evt.type) return Object(of.a)(evt);
                var license = evt.value.license;
                return null == license ? (log.a.info("EME: No license given, skipping session.update"), 
                empty.a) : (log.a.debug("EME: Update session", evt), Object(castToObservable.a)(session.update(license)).pipe(Object(catchError.a)(function(error) {
                    throw new EncryptedMediaError.a("KEY_UPDATE_ERROR", error, !0);
                }), Object(mapTo.a)({
                    type: evt.type,
                    value: {
                        session: session,
                        license: license
                    }
                })));
            })), sessionEvents = Object(merge.a)(sessionUpdates, keyErrors, sessionWarningSubject$);
            return session.closed ? sessionEvents.pipe(Object(takeUntil.a)(Object(castToObservable.a)(session.closed))) : sessionEvents;
        }
        // CONCATENATED MODULE: ./src/core/eme/media_keys_infos_store.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Store the MediaKeys infos attached to a media element.
 * @class MediaKeysInfosStore
 */        var MediaKeysInfosStore = 
        /* */
        function() {
            function MediaKeysInfosStore() {
                this._state = new WeakMap();
            }
            var _proto = MediaKeysInfosStore.prototype;
            return _proto.setState = function setState(mediaElement, state) {
                this._state.set(mediaElement, state);
            }, _proto.getState = function getState(mediaElement) {
                return this._state.get(mediaElement) || null;
            }, _proto.clearState = function clearState(mediaElement) {
                this._state.set(mediaElement, null);
            }, MediaKeysInfosStore;
        }();
        // CONCATENATED MODULE: ./src/core/eme/set_server_certificate.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Call the setServerCertificate API with the given certificate.
 * Complete when worked, throw when failed.
 *
 * TODO Manage success?
 * From the spec:
 *   - setServerCertificate resolves with true if everything worked
 *   - it resolves with false if the CDM does not support server
 *     certificates.
 *
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */        function setServerCertificate(mediaKeys, serverCertificate) {
            return Object(defer.a)(function() {
                return Object(castToObservable.a)(mediaKeys.setServerCertificate(serverCertificate)).pipe(Object(catchError.a)(function(error) {
                    throw log.a.warn("EME: mediaKeys.setServerCertificate returned an error", error), 
                    new EncryptedMediaError.a("LICENSE_SERVER_CERTIFICATE_ERROR", error, !0);
                }));
            });
        }
        /**
 * Call the setCertificate API. If it fails just emit the error as warning
 * and complete.
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */        function trySettingServerCertificate(mediaKeys, serverCertificate) {
            return "function" == typeof mediaKeys.setServerCertificate ? (log.a.debug("EME: Setting server certificate on the MediaKeys"), 
            setServerCertificate(mediaKeys, serverCertificate).pipe(Object(ignoreElements.a)(), Object(catchError.a)(function(error) {
                return error.fatal = !1, Object(of.a)({
                    type: "warning",
                    value: error
                });
            }))) : (log.a.warn("EME: Could not set the server certificate. mediaKeys.setServerCertificate is not a function"), 
            empty.a);
        }
        // CONCATENATED MODULE: ./src/core/eme/utils/init_data_store.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Memorize initialization data with straightforward methods.
 * @class InitDataStore
 */        var init_data_store_InitDataStore = 
        /* */
        function() {
            function InitDataStore() {
                this._namedTypeData = {}, this._unnamedTypeData = new simple_set.a();
            }
            /**
   * Returns true if this instance has the given initData stored.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {boolean}
   */            var _proto = InitDataStore.prototype;
            return _proto.has = function has(initData, initDataType) {
                return initDataType ? !!this._namedTypeData[initDataType] && this._namedTypeData[initDataType].test(hashBuffer(initData)) : this._unnamedTypeData.test(hashBuffer(initData));
            }, 
            /**
   * Add initialization data to this memory.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   */
            _proto.add = function add(initData, initDataType) {
                this.has(initData, initDataType) || (initDataType ? (this._namedTypeData[initDataType] || (this._namedTypeData[initDataType] = new simple_set.a()), 
                this._namedTypeData[initDataType].add(hashBuffer(initData))) : this._unnamedTypeData.add(hashBuffer(initData)));
            }, 
            /**
   * Remove the initialization data from this memory.
   * Returns true if this instance had the given initData stored.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {boolean}
   */
            _proto.remove = function remove(initData, initDataType) {
                if (initDataType) {
                    if (!this._namedTypeData[initDataType]) return !1;
                    var _hashed = hashBuffer(initData), simpleSet = this._namedTypeData[initDataType];
                    return !!simpleSet.test(_hashed) && (simpleSet.remove(_hashed), !0);
                }
                var hashed = hashBuffer(initData);
                return !!this._unnamedTypeData.test(hashed) && (this._unnamedTypeData.remove(hashed), 
                !0);
            }, InitDataStore;
        }();
        // CONCATENATED MODULE: ./src/core/eme/index.ts
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "default", function() {
            return EMEManager;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearEMESession", function() {
            return clearEMESession;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disposeEME", function() {
            return disposeEME;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentKeySystem", function() {
            return getCurrentKeySystem;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        var attachedMediaKeysInfos = new MediaKeysInfosStore();
        /**
 * Clear EME ressources that should be cleared when the current content stops
 * its playback.
 * @returns {Observable}
 */        function clearEMESession(mediaElement) {
            return Object(defer.a)(function() {
                if (Object(compat.n)()) return disposeMediaKeys(mediaElement, attachedMediaKeysInfos).pipe(Object(ignoreElements.a)());
                var currentState = attachedMediaKeysInfos.getState(mediaElement);
                return currentState && currentState.keySystemOptions.closeSessionsOnStop ? currentState.sessionsStore.closeAllSessions().pipe(Object(ignoreElements.a)()) : empty.a;
            });
        }
        /**
 * EME abstraction and event handler used to communicate with the Content-
 * Description-Module (CDM).
 *
 * The EME handler can be given one or multiple systems and will choose the
 * appropriate one supported by the user's browser.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems
 * @returns {Observable}
 */        function EMEManager(mediaElement, keySystemsConfigs) {
            // Keep track of all initialization data handled here.
            // This is to avoid handling multiple times the same encrypted events.
            var handledInitData = new init_data_store_InitDataStore();
            /* Catch "encrypted" event and create MediaKeys */            return Object(combineLatest.a)(Object(events.b)(mediaElement), getMediaKeysInfos(mediaElement, keySystemsConfigs, attachedMediaKeysInfos)).pipe(
            /* Attach server certificate and create/reuse MediaKeySession */
            Object(mergeMap.a)(function(_ref, i) {
                var encryptedEvent = _ref[0], mediaKeysInfos = _ref[1];
                log.a.debug("EME: encrypted event received", encryptedEvent);
                var keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeys = mediaKeysInfos.mediaKeys, serverCertificate = keySystemOptions.serverCertificate, session$ = getSession(encryptedEvent, handledInitData, mediaKeysInfos).pipe(Object(map.a)(function(evt) {
                    return {
                        type: evt.type,
                        value: {
                            initData: evt.value.initData,
                            initDataType: evt.value.initDataType,
                            mediaKeySession: evt.value.mediaKeySession,
                            sessionType: evt.value.sessionType,
                            keySystemOptions: mediaKeysInfos.keySystemOptions,
                            sessionStorage: mediaKeysInfos.sessionStorage
                        }
                    };
                }));
                return 0 === i ? Object(merge.a)(null != serverCertificate ? Object(concat.a)(trySettingServerCertificate(mediaKeys, serverCertificate), session$) : session$, attachMediaKeys(mediaKeysInfos, mediaElement, attachedMediaKeysInfos).pipe(Object(ignoreElements.a)())) : session$;
            }), 
            /* Trigger license request and manage MediaKeySession events */
            Object(mergeMap.a)(function(sessionInfosEvt) {
                if ("warning" === sessionInfosEvt.type) return Object(of.a)(sessionInfosEvt);
                var _sessionInfosEvt$valu = sessionInfosEvt.value, initData = _sessionInfosEvt$valu.initData, initDataType = _sessionInfosEvt$valu.initDataType, mediaKeySession = _sessionInfosEvt$valu.mediaKeySession, sessionType = _sessionInfosEvt$valu.sessionType, keySystemOptions = _sessionInfosEvt$valu.keySystemOptions, sessionStorage = _sessionInfosEvt$valu.sessionStorage;
                return Object(merge.a)(handleSessionEvents(mediaKeySession, keySystemOptions), // only perform generate request on new sessions
                "created-session" === sessionInfosEvt.type ? generateKeyRequest(mediaKeySession, initData, initDataType).pipe(Object(tap.a)(function() {
                    "persistent-license" === sessionType && null != sessionStorage && sessionStorage.add(initData, initDataType, mediaKeySession);
                }), Object(ignoreElements.a)()) : empty.a).pipe(Object(filter.a)(function(sessionEvent) {
                    return "warning" === sessionEvent.type;
                }));
            }));
        }
        /**
 * Free up all ressources taken by the EME management.
 */        function disposeEME(mediaElement) {
            disposeMediaKeys(mediaElement, attachedMediaKeysInfos).subscribe(noop.a);
        }
        /**
 * Returns the name of the current key system used.
 * @returns {string}
 */        function getCurrentKeySystem(mediaElement) {
            var currentState = attachedMediaKeysInfos.getState(mediaElement);
            return currentState && currentState.keySystemOptions.type;
        }
        /***/    }, 
    /* 87 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), _utils_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Manifest loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 */
        function regularManifestLoader(url, ignoreProgressEvents) {
            return Object(_utils_request__WEBPACK_IMPORTED_MODULE_1__.a)({
                url: url,
                responseType: "document",
                ignoreProgressEvents: ignoreProgressEvents
            });
        }
        /**
 * Generate a manifest loader for the application
 * @param {Function} [customManifestLoader]
 * @returns {Function}
 */        
        /* harmony default export */ __webpack_exports__.a = function manifestPreLoader(options) {
            return function(url) {
                var customManifestLoader = options.customManifestLoader, ignoreProgressEvents = options.ignoreProgressEvents;
                return customManifestLoader ? rxjs__WEBPACK_IMPORTED_MODULE_0__.a.create(function(obs) {
                    var hasFinished = !1, hasFallbacked = !1, abort = customManifestLoader(url, {
                        reject: function reject(err) {
                            void 0 === err && (err = {}), hasFallbacked || (hasFinished = !0, obs.error(err));
                        },
                        resolve: function resolve(_args) {
                            hasFallbacked || (hasFinished = !0, obs.next({
                                type: "response",
                                value: {
                                    responseData: _args.data,
                                    size: _args.size,
                                    duration: _args.duration
                                }
                            }), obs.complete());
                        },
                        fallback: function fallback() {
                            hasFallbacked = !0, regularManifestLoader(url).subscribe(obs);
                        }
                    });
                    return function() {
                        hasFinished || hasFallbacked || "function" != typeof abort || abort();
                    };
                }) : regularManifestLoader(url, ignoreProgressEvents);
            };
        };
    }, 
    /* 88 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* unused harmony export stringFromCharCode */
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Creates a new string from the given array of char codes.
 *
 * @param {Uint8Array} args
 * @returns {string}
 */
        function stringFromCharCode(args) {
            for (var ret = "", i = 0; i < args.length; i += 16e3) {
                var subArray = args.subarray(i, i + 16e3);
                ret += String.fromCharCode.apply(null, subArray);
            }
            return ret;
        }
        /**
 * Creates a string from the given buffer as UTF-8 encoding.
 * @param {BufferSource} [data]
 * @returns {string}
 * @throws {Error}
 * @export
 */        function stringFromUTF8(data) {
            if (!data) return "";
            var uint8 = new Uint8Array(data);
 // If present, strip off the UTF-8 BOM.
                        239 === uint8[0] && 187 === uint8[1] && 191 === uint8[2] && (uint8 = uint8.subarray(3));
 // http://stackoverflow.com/a/13691499
                        var utf8 = stringFromCharCode(uint8), escaped = escape(utf8);
 // This converts each character in the string to an escape sequence.  If the
            // character is in the ASCII range, it is not converted; otherwise it is
            // converted to a URI escape sequence.
            // Example: "\x67\x35\xe3\x82\xac" -> "g#%E3%82%AC"
            // TODO "escape" is deprecated, provide a ponyfill?
                        // Decode the escaped sequence.  This will interpret UTF-8 sequences into the
            // correct character.
            // Example: "g#%E3%82%AC" -> "g#€"
            return decodeURIComponent(escaped);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return stringFromUTF8;
        });
    }, 
    /* 89 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getCueBlocks;
        });
        /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */        function getCueBlocks(linified, headerOffset) {
            for (var cueBlocks = [], i = headerOffset; i < linified.length; i++) 
            //
            if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__.c)(linified, i)) {
                var endOfCue = Object(_utils__WEBPACK_IMPORTED_MODULE_0__.a)(linified, i);
                cueBlocks.push(linified.slice(i, endOfCue)), i = endOfCue;
            } else if (linified[i]) 
            // continue incrementing i until either:
            //   - empty line
            //   - end
            for (;linified[i]; ) i++;
            return cueBlocks;
        }
        /***/    }, 
    /* 90 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns global parameters from a TTML Document
 * @param {Element} tt - <tt> node
 * @throws Error - Throws if the spacing style is invalid.
 * @returns {Object}
 */
        function getParameters(tt) {
            var parsedFrameRate = tt.getAttribute("ttp:frameRate"), parsedSubFrameRate = tt.getAttribute("ttp:subFramRate"), parsedTickRate = tt.getAttribute("ttp:tickRate"), parsedFrameRateMultiplier = tt.getAttribute("ttp:frameRateMultiplier"), parsedSpaceStyle = tt.getAttribute("xml:space");
            if (parsedSpaceStyle && "default" !== parsedSpaceStyle && "preserve" !== parsedSpaceStyle) throw new Error("Invalid spacing style");
            var nbFrameRate = Number(parsedFrameRate) || 30, nbSubFrameRate = Number(parsedSubFrameRate) || 1, nbTickRate = Number(parsedTickRate) || 0, tickRate = nbTickRate, frameRate = nbFrameRate, subFrameRate = null != nbSubFrameRate ? nbSubFrameRate : 1, spaceStyle = parsedSpaceStyle || "default";
            if (0 === nbTickRate && (tickRate = parsedFrameRate ? nbFrameRate * nbSubFrameRate : 1), 
            parsedFrameRateMultiplier) {
                var multiplierResults = /^(\d+) (\d+)$/g.exec(parsedFrameRateMultiplier);
                if (multiplierResults) frameRate = nbFrameRate * (Number(multiplierResults[1]) / Number(multiplierResults[2]));
            }
            return {
                tickRate: tickRate,
                frameRate: frameRate,
                subFrameRate: subFrameRate,
                spaceStyle: spaceStyle
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getParameters;
        });
    }, 
    /* 91 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return seekAndLoadOnMediaEvents;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(153), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(150), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(103), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(92), rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(57), rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(149), rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(146), _compat__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(8), _log__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(0);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Set the initial time given as soon as possible on the media element.
 * Emit when done.
 * @param {HMTLMediaElement} mediaElement
 * @param {number|Function} startTime - Initial starting position. As seconds
 * or as a function returning seconds.
 * @returns {Observable}
 */
        function doInitialSeek(mediaElement, startTime) {
            return Object(_compat__WEBPACK_IMPORTED_MODULE_8__.e)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function() {
                _log__WEBPACK_IMPORTED_MODULE_9__.a.info("Stream: Set initial time", startTime), 
                // reset playbackRate to 1 in case we were at 0 (from a stalled
                // retry for instance)
                mediaElement.playbackRate = 1, mediaElement.currentTime = "function" == typeof startTime ? startTime() : startTime;
            }), // equivalent to a sane shareReplay:
            // https://github.com/ReactiveX/rxjs/issues/3336
            // XXX TODO Replace it when that issue is resolved
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(function() {
                return new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(1);
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)());
        }
        /**
 * Returns two Observables:
 *
 *   - seek$: when subscribed, will seek to the wanted started time as soon as
 *     it can. Emit and complete when done.
 *
 *   - load$: when subscribed, will play if and only if the `mustAutoPlay`
 *     option is set as soon as it can. Emit and complete when done.
 *     When this observable emits, it also means that the content is `loaded`
 *     and can begin to play the current content.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {number|Function} startTime - Initial starting position. As seconds
 * or as a function returning seconds.
 * @param {boolean} autoPlay - Whether the player should auto-play
 * @returns {object}
 */        function seekAndLoadOnMediaEvents(mediaElement, startTime, mustAutoPlay) {
            return {
                seek$: doInitialSeek(mediaElement, startTime),
                load$: Object(_compat__WEBPACK_IMPORTED_MODULE_8__.b)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function() {
                    return _log__WEBPACK_IMPORTED_MODULE_9__.a.info("Stream: canplay event");
                }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(function() {
                    return mustAutoPlay ? Object(_compat__WEBPACK_IMPORTED_MODULE_8__.k)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.a)("autoplay"), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.a)(function(error) {
                        if ("NotAllowedError" === error.name) 
                        // auto-play was probably prevented.
                        return _log__WEBPACK_IMPORTED_MODULE_9__.a.warn("Stream: Media element can't play. It may be due to browser auto-play policies."), 
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)("autoplay-blocked");
                        throw error;
                    })) : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)("loaded");
                }), // equivalent to a sane shareReplay:
                // https://github.com/ReactiveX/rxjs/issues/3336
                // XXX TODO Replace it when that issue is resolved
                Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(function() {
                    return new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(1);
                }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)())
            };
        }
        /***/    }, 
    /* 92 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return refCount;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function refCount() {
            return function refCountOperatorFunction(source) {
                return source.lift(new RefCountOperator(source));
            };
        }
        var RefCountOperator = /* */ function() {
            function RefCountOperator(connectable) {
                this.connectable = connectable;
            }
            return RefCountOperator.prototype.call = function(subscriber, source) {
                var connectable = this.connectable;
                connectable._refCount++;
                var refCounter = new RefCountSubscriber(subscriber, connectable), subscription = source.subscribe(refCounter);
                return refCounter.closed || (refCounter.connection = connectable.connect()), subscription;
            }, RefCountOperator;
        }(), RefCountSubscriber = /* */ function(_super) {
            function RefCountSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                return _this.connectable = connectable, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(RefCountSubscriber, _super), RefCountSubscriber.prototype._unsubscribe = function() {
                var connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    var refCount = connectable._refCount;
                    if (refCount <= 0) this.connection = null; else if (connectable._refCount = refCount - 1, 
                    1 < refCount) this.connection = null; else {
                        var connection = this.connection, sharedConnection = connectable._connection;
                        this.connection = null, !sharedConnection || connection && sharedConnection !== connection || sharedConnection.unsubscribe();
                    }
                } else this.connection = null;
            }, RefCountSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 93 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return createEMEManager;
        });
        /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42), _compat___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8), _compat_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12), _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(80), _features__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10), _log__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(0);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create EMEManager if possible (has the APIs and configuration).
 * Else, return an Observable throwing at the next encrypted event encountered.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems
 * @returns {Observable}
 */
        function createEMEManager(mediaElement, keySystems) {
            return null == _features__WEBPACK_IMPORTED_MODULE_4__.a.emeManager ? Object(_compat_events__WEBPACK_IMPORTED_MODULE_2__.b)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                throw _log__WEBPACK_IMPORTED_MODULE_5__.a.error("Stream: Encrypted event but EME feature not activated"), 
                new _errors__WEBPACK_IMPORTED_MODULE_3__.a("MEDIA_IS_ENCRYPTED_ERROR", null, !0);
            })) : keySystems && keySystems.length ? Object(_compat___WEBPACK_IMPORTED_MODULE_1__.d)() ? (_log__WEBPACK_IMPORTED_MODULE_5__.a.debug("Stream: Creating EMEManager"), 
            _features__WEBPACK_IMPORTED_MODULE_4__.a.emeManager(mediaElement, keySystems)) : Object(_compat_events__WEBPACK_IMPORTED_MODULE_2__.b)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                throw _log__WEBPACK_IMPORTED_MODULE_5__.a.error("Stream: Encrypted event but no EME API available"), 
                new _errors__WEBPACK_IMPORTED_MODULE_3__.a("MEDIA_IS_ENCRYPTED_ERROR", null, !0);
            })) : Object(_compat_events__WEBPACK_IMPORTED_MODULE_2__.b)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                throw _log__WEBPACK_IMPORTED_MODULE_5__.a.error("Stream: Ciphered media and no keySystem passed"), 
                new _errors__WEBPACK_IMPORTED_MODULE_3__.a("MEDIA_IS_ENCRYPTED_ERROR", null, !0);
            }));
        }
        /***/    }, 
    /* 94 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return MediaErrorManager;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136), rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57), _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28), _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns an observable which throws the right MediaError as soon an "error"
 * event is received through the media element.
 * @see MediaError
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
        function MediaErrorManager(mediaElement) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(mediaElement, "error").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(function() {
                var errorDetail;
                switch (mediaElement.error && mediaElement.error.code) {
                  case 1:
                    errorDetail = "MEDIA_ERR_ABORTED";
                    break;

                  case 2:
                    errorDetail = "MEDIA_ERR_NETWORK";
                    break;

                  case 3:
                    errorDetail = "MEDIA_ERR_DECODE";
                    break;

                  case 4:
                    errorDetail = "MEDIA_ERR_SRC_NOT_SUPPORTED";
                    break;

                  default:
                    errorDetail = "MEDIA_ERR_UNKNOWN";
                }
                throw _log__WEBPACK_IMPORTED_MODULE_3__.a.error("Stream: Media element MEDIA_ERR(" + errorDetail + ")"), 
                new _errors__WEBPACK_IMPORTED_MODULE_2__.a(errorDetail, null, !0);
            }));
        }
        /***/    }, 
    /* 95 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var rxjs_operators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(150), rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(152), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(140), _compat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8), _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2), _log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0), _utils_ranges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(16), DISCONTINUITY_THRESHOLD = _config__WEBPACK_IMPORTED_MODULE_5__.a.DISCONTINUITY_THRESHOLD;
        /* harmony import */        
        /* harmony default export */ __webpack_exports__.a = 
        /**
 * Receive "stalling" events from the clock, try to get out of it, and re-emit
 * them for the player if the stalling status changed.
 * @param {HTMLMediaElement} mediaElement
 * @param {Observable} timings$
 * @returns {Observable}
 */
        function StallingManager(mediaElement, timings$) {
            return timings$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.a)(function(timing) {
                if (timing.stalled) {
                    // Perform various checks to try to get out of the stalled state:
                    //   1. is it a browser bug? -> force seek at the same current time
                    //   2. is it a short discontinuity? -> Seek at the beginning of the
                    //                                      next range
                    var buffered = timing.buffered, currentTime = timing.currentTime, nextRangeGap = Object(_utils_ranges__WEBPACK_IMPORTED_MODULE_7__.d)(buffered, currentTime);
                    // Discontinuity check in case we are close a buffer but still
                    // calculate a stalled state. This is useful for some
                    // implementation that might drop an injected segment, or in
                    // case of small discontinuity in the stream.
                    if (Object(_compat__WEBPACK_IMPORTED_MODULE_4__.h)(timing.currentTime, timing.currentRange, timing.state, !!timing.stalled)) _log__WEBPACK_IMPORTED_MODULE_6__.a.warn("StallingManager: After freeze seek", currentTime, timing.currentRange), 
                    mediaElement.currentTime = currentTime; else if (nextRangeGap < DISCONTINUITY_THRESHOLD) {
                        var seekTo = currentTime + nextRangeGap + 1 / 60;
                        _log__WEBPACK_IMPORTED_MODULE_6__.a.warn("StallingManager: Discontinuity seek", currentTime, nextRangeGap, seekTo), 
                        mediaElement.currentTime = seekTo;
                    }
                }
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function(timing) {
                return timing.stalled;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(function(wasStalled, isStalled) {
                return !wasStalled && !isStalled || !!wasStalled && !!isStalled && wasStalled.reason === isStalled.reason;
            }));
        };
    }, 
    /* 96 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return NetworkError;
        });
        /* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19), _errorMessage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
        /* harmony import */        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error linked to network interactions (requests).
 *
 * @class NetworkError
 * @extends Error
 */        var NetworkError = 
        /* */
        function(_Error) {
            /**
   * @param {string} code
   * @param {Error} requestError
   * @param {Boolean} [fatal]
   */
            function NetworkError(code, requestError, fatal) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_assertThisInitialized(_this)), NetworkError.prototype), 
                _this.name = "NetworkError", _this.type = _constants__WEBPACK_IMPORTED_MODULE_0__.b.NETWORK_ERROR, 
                _this.xhr = requestError.xhr, _this.url = requestError.url, _this.status = requestError.status, 
                _this.errorType = requestError.type, _this.reason = requestError, _this.code = _constants__WEBPACK_IMPORTED_MODULE_0__.a.hasOwnProperty(code) ? _constants__WEBPACK_IMPORTED_MODULE_0__.a[code] : "", 
                _this.fatal = !!fatal, _this.message = Object(_errorMessage__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, _this.reason), 
                _this;
            }
            /**
   * Returns true if the NetworkError is due to the given http error code
   * @param {number} httpErrorCode
   * @returns {Boolean}
   */            return _inheritsLoose(NetworkError, _Error), NetworkError.prototype.isHttpError = function isHttpError(httpErrorCode) {
                return this.errorType === _constants__WEBPACK_IMPORTED_MODULE_0__.c.ERROR_HTTP_CODE && this.status === httpErrorCode;
            }, NetworkError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 97 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return OtherError;
        });
        /* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19), _errorMessage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
        /* harmony import */        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @class OtherError
 * @extends Error
 */        var OtherError = 
        /* */
        function(_Error) {
            /**
   * @param {string} code
   * @param {Error|null} [reason]
   * @param {Boolean} [fatal]
   */
            function OtherError(code, reason, fatal) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_assertThisInitialized(_this)), OtherError.prototype), 
                _this.name = "OtherError", _this.type = _constants__WEBPACK_IMPORTED_MODULE_0__.b.OTHER_ERROR, 
                _this.reason = reason, _this.code = _constants__WEBPACK_IMPORTED_MODULE_0__.a.hasOwnProperty(code) ? _constants__WEBPACK_IMPORTED_MODULE_0__.a[code] : "", 
                _this.fatal = !!fatal, _this.message = Object(_errorMessage__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, _this.reason), 
                _this;
            }
            return _inheritsLoose(OtherError, _Error), OtherError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 98 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
                var mergeMap = __webpack_require__(57);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/identity.js
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */        function identity(x) {
            return x;
        }
        //# sourceMappingURL=identity.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeAll.js
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
        function mergeAll(concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), Object(mergeMap.a)(identity, concurrent);
        }
        //# sourceMappingURL=mergeAll.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mergeAll;
        });
    }, 
    /* 99 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parseTimestamp.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse a single webvtt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */        function parseTimestamp(timestampString) {
            var splittedTS = timestampString.split(":").reverse();
            if (splittedTS[2] || splittedTS[1]) {
                var hours = splittedTS[2] ? parseInt(splittedTS[2], 10) : 0, minutes = parseInt(splittedTS[1], 10), seconds = parseFloat(splittedTS[0].replace(",", "."));
                if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) return;
                return 60 * hours * 60 + 60 * minutes + seconds;
            }
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parseCueBlock.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse the settings part of a cue, into key-value object.
 * @param {string} settingsString
 * @returns {Object}
 */
        function parseSettings(settingsString) {
            return settingsString.split(/ |\t/).reduce(function(acc, setting) {
                var splittedSetting = setting.split(":");
                return 2 === splittedSetting.length && (acc[splittedSetting[0]] = splittedSetting[1]), 
                acc;
            }, {});
        }
        /**
 * Parse the line containing the timestamp and settings in a cue.
 * The returned object has the following properties:
 *   - start {Number}: start of the cue, in seconds
 *   - end {Number}: end of the cue, in seconds
 *   - settings {Object}: settings for the cue as a key-value object.
 * @param {string} timeString
 * @returns {Object|null}
 */        function parseTimeAndSettings(timeString) {
            /**
   * RegExp for the timestamps + settings line.
   *
   * Capture groups:
   *   1 -> start timestamp
   *   2 -> end timestamp
   *   3 - settings
   * @type {RegExp}
   */
            var matches = timeString.match(/^([\d:.]+)[ |\t]+-->[ |\t]+([\d:.]+)[ |\t]*(.*)$/);
            if (!matches) return null;
            var start = parseTimestamp(matches[1]), end = parseTimestamp(matches[2]);
            return null == start || null == end ? null : {
                start: start,
                end: end,
                settings: parseSettings(matches[3])
            };
        }
        /**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - header {string|undefined}: The optional cue identifier
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */        function parseCueBlock(cueLines, timeOffset) {
            var timeString, payload, header, timingRegexp = /-->/;
            if (timingRegexp.test(cueLines[0])) timeString = cueLines[0], payload = cueLines.slice(1, cueLines.length); else {
                if (!timingRegexp.test(cueLines[1])) 
                // not a cue
                return null;
                header = cueLines[0], timeString = cueLines[1], payload = cueLines.slice(2, cueLines.length);
            }
            if (!timeString) return null;
            var timeAndSettings = parseTimeAndSettings(timeString);
            return timeAndSettings ? {
                start: timeAndSettings.start + timeOffset,
                end: timeAndSettings.end + timeOffset,
                settings: timeAndSettings.settings,
                payload: payload,
                header: header
            } : null;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return parseCueBlock;
        });
    }, 
    /* 100 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
                var regexps = __webpack_require__(29);
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/time_parsing.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parses a TTML time into seconds.
 * @param {string} text
 * @param {Object} ttParams
 * @returns {Number|undefined}
 */        
        /**
 * Parses a TTML time in frame format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
        function parseFramesTime(ttParams, text) {
            // 75f or 75.5f
            // (We cast as we're sure the regexp is respected here)
            var results = regexps.g.exec(text);
            return Number(results[1]) / ttParams.frameRate;
        }
        /**
 * Parses a TTML time in tick format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */        function parseTickTime(ttParams, text) {
            // 50t or 50.5t
            // (We cast as we're sure the regexp is respected here)
            var results = regexps.i.exec(text);
            return Number(results[1]) / ttParams.tickRate;
        }
        /**
 * Parses a TTML colon formatted time containing frames
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */        function parseColonTimeWithFrames(ttParams, text) {
            // 01:02:43:07 ("07" is frames) or 01:02:43:07.1 (subframes)
            // (We cast as we're sure the regexp is respected here)
            var results = regexps.e.exec(text), hours = Number(results[1]), minutes = Number(results[2]), seconds = Number(results[3]), frames = Number(results[4]);
            return (seconds += (frames += (Number(results[5]) || 0) / ttParams.subFrameRate) / ttParams.frameRate) + 60 * minutes + 3600 * hours;
        }
        /**
 * Parses a TTML time with a given regex. Expects regex to be some
 * sort of a time-matcher to match hours, minutes, seconds and milliseconds
 *
 * @param {RegExp} regex
 * @param {string} text
 * @returns {number|null}
 */        function parseTimeFromRegExp(regex, text) {
            var results = regex.exec(text);
            if (null === results || "" === results[0]) return null;
 // This capture is optional, but will still be in the array as undefined,
            // default to 0.
                        var hours = Number(results[1]) || 0, minutes = Number(results[2]) || 0, seconds = Number(results[3]) || 0;
            return (Number(results[4]) || 0) / 1e3 + seconds + 60 * minutes + 3600 * hours;
        }
        /* harmony default export */        var time_parsing = function parseTime(text, ttParams) {
            return regexps.e.test(text) ? parseColonTimeWithFrames(ttParams, text) : regexps.d.test(text) ? parseTimeFromRegExp(regexps.d, text) : regexps.f.test(text) ? parseTimeFromRegExp(regexps.f, text) : regexps.g.test(text) ? parseFramesTime(ttParams, text) : regexps.i.test(text) ? parseTickTime(ttParams, text) : regexps.h.test(text) ? parseTimeFromRegExp(regexps.h, text) : void 0;
        };
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/getTimeDelimiters.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get start and end time of an element.
 * @param {Element} element
 * @param {Object} ttParams
 * @returns {Object}
 */
        function getTimeDelimiters(element, ttParams) {
            var beginAttr = element.getAttribute("begin"), durationAttr = element.getAttribute("dur"), endAttr = element.getAttribute("end"), start = beginAttr ? time_parsing(beginAttr, ttParams) : null, duration = durationAttr ? time_parsing(durationAttr, ttParams) : null, parsedEnd = endAttr ? time_parsing(endAttr, ttParams) : null;
            if (null == start || null == parsedEnd && null == duration) throw new Error("Invalid text cue");
 // Huh? Is TypeScript that dumb here?
                        return {
                start: start,
                end: null == parsedEnd ? start + duration : parsedEnd
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getTimeDelimiters;
        });
    }, 
    /* 101 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/findEndOfCueBlock.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the first line that is not apart of the given cue block.
 * The index given can be anywhere in a known cue block.
 *
 * This function is extra-resilient due to observed real-life malformed
 * subtitles.
 * Basically, it allows some deviation from the specification as long as the
 * intent is pretty clear.
 * @param {Array<string>} linified - Whole srt. Line by line.
 * @param {number} startIndex - Index in `linified` of the first line within the
 * block.
 * @returns {number}
 */        function findEndOfCueBlock(linified, startIndex) {
            // continue incrementing i until either:
            //   - an empty line
            //   - the end
            for (var firstEmptyLineIndex = startIndex + 1; linified[firstEmptyLineIndex]; ) firstEmptyLineIndex++;
            return firstEmptyLineIndex;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/getCueBlocks.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get cue blocks from a srt file.
 * @param {Array.<string>} linified - Whole srt file. Each new element in this
 * array is a new line.
 * @returns {Array.<Array.<string>>}
 */
        function getCueBlocks(linified) {
            for (var cueBlocks = [], i = 0; i < linified.length; i++) if (linified[i]) {
                var endOfCue = findEndOfCueBlock(linified, i), cueBlockCandidate = linified.slice(i, endOfCue);
                0 < cueBlockCandidate.length && (1 === cueBlockCandidate.length ? 0 <= cueBlockCandidate[0].indexOf("--\x3e") && cueBlocks.push(cueBlockCandidate) : (0 <= cueBlockCandidate[1].indexOf("--\x3e") || 0 <= cueBlockCandidate[0].indexOf("--\x3e")) && cueBlocks.push(cueBlockCandidate)), 
                i = endOfCue;
            }
            return cueBlocks;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getCueBlocks;
        });
    }, 
    /* 102 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/parseTimestamp.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse a single srt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */        function parseTimestamp(timestampString) {
            var splittedTS = timestampString.split(":");
            if (splittedTS[2]) {
                var hours = parseInt(splittedTS[0], 10), minutes = parseInt(splittedTS[1], 10), seconds = parseFloat(splittedTS[2].replace(",", "."));
                if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) return;
                return 60 * hours * 60 + 60 * minutes + seconds;
            }
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/parseCue.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */
        function parseCueBlock(cueLines, timeOffset) {
            if (0 === cueLines.length) return null;
            var startTimeString, endTimeString, payload = [];
            // normally in srt, the timing is at second position.
            // We still authorize to put it in the first position for resilience
            if (cueLines[1] && cueLines[1].indexOf("--\x3e")) {
                var _cueLines$1$split$map = cueLines[1].split("--\x3e").map(function(s) {
                    return s.trim();
                });
                startTimeString = _cueLines$1$split$map[0], endTimeString = _cueLines$1$split$map[1], 
                payload = cueLines.slice(2, cueLines.length);
            }
            if (!startTimeString || !endTimeString) {
                // Try to see if we find them in the first position
                var _cueLines$0$split$map = cueLines[0].split("--\x3e").map(function(s) {
                    return s.trim();
                });
                startTimeString = _cueLines$0$split$map[0], endTimeString = _cueLines$0$split$map[1], 
                payload = cueLines.slice(1, cueLines.length);
            }
            if (!startTimeString || !endTimeString) 
            // if the time is still not found, exit
            return null;
            var start = parseTimestamp(startTimeString), end = parseTimestamp(endTimeString);
            return null == start || null == end ? null : {
                start: start + timeOffset,
                end: end + timeOffset,
                payload: payload
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return parseCueBlock;
        });
    }, 
    /* 103 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(3), Subject = __webpack_require__(33), Observable = __webpack_require__(9), Subscriber = __webpack_require__(7), Subscription = __webpack_require__(15), refCount = __webpack_require__(92), connectableProto = /* */ function(_super) {
            function ConnectableObservable(source, subjectFactory) {
                var _this = _super.call(this) || this;
                return _this.source = source, _this.subjectFactory = subjectFactory, _this._refCount = 0, 
                _this._isComplete = !1, _this;
            }
            return tslib_es6.a(ConnectableObservable, _super), ConnectableObservable.prototype._subscribe = function(subscriber) {
                return this.getSubject().subscribe(subscriber);
            }, ConnectableObservable.prototype.getSubject = function() {
                var subject = this._subject;
                return subject && !subject.isStopped || (this._subject = this.subjectFactory()), 
                this._subject;
            }, ConnectableObservable.prototype.connect = function() {
                var connection = this._connection;
                return connection || (this._isComplete = !1, (connection = this._connection = new Subscription.a()).add(this.source.subscribe(new ConnectableObservable_ConnectableSubscriber(this.getSubject(), this))), 
                connection.closed ? (this._connection = null, connection = Subscription.a.EMPTY) : this._connection = connection), 
                connection;
            }, ConnectableObservable.prototype.refCount = function() {
                return Object(refCount.a)()(this);
            }, ConnectableObservable;
        }(Observable.a).prototype, connectableObservableDescriptor = {
            operator: {
                value: null
            },
            _refCount: {
                value: 0,
                writable: !0
            },
            _subject: {
                value: null,
                writable: !0
            },
            _connection: {
                value: null,
                writable: !0
            },
            _subscribe: {
                value: connectableProto._subscribe
            },
            _isComplete: {
                value: connectableProto._isComplete,
                writable: !0
            },
            getSubject: {
                value: connectableProto.getSubject
            },
            connect: {
                value: connectableProto.connect
            },
            refCount: {
                value: connectableProto.refCount
            }
        }, ConnectableObservable_ConnectableSubscriber = /* */ function(_super) {
            function ConnectableSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                return _this.connectable = connectable, _this;
            }
            return tslib_es6.a(ConnectableSubscriber, _super), ConnectableSubscriber.prototype._error = function(err) {
                this._unsubscribe(), _super.prototype._error.call(this, err);
            }, ConnectableSubscriber.prototype._complete = function() {
                this.connectable._isComplete = !0, this._unsubscribe(), _super.prototype._complete.call(this);
            }, ConnectableSubscriber.prototype._unsubscribe = function() {
                var connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    var connection = connectable._connection;
                    connectable._refCount = 0, connectable._subject = null, connectable._connection = null, 
                    connection && connection.unsubscribe();
                }
            }, ConnectableSubscriber;
        }(Subject.b);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
                Subscriber.a;
        /* unused harmony export MulticastOperator */
        /** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
        function multicast(subjectOrSubjectFactory, selector) {
            return function multicastOperatorFunction(source) {
                var subjectFactory;
                if (subjectFactory = "function" == typeof subjectOrSubjectFactory ? subjectOrSubjectFactory : function subjectFactory() {
                    return subjectOrSubjectFactory;
                }, "function" == typeof selector) return source.lift(new MulticastOperator(subjectFactory, selector));
                var connectable = Object.create(source, connectableObservableDescriptor);
                return connectable.source = source, connectable.subjectFactory = subjectFactory, 
                connectable;
            };
        }
        //# sourceMappingURL=ConnectableObservable.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/multicast.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return multicast;
        });
        var MulticastOperator = /* */ function() {
            function MulticastOperator(subjectFactory, selector) {
                this.subjectFactory = subjectFactory, this.selector = selector;
            }
            return MulticastOperator.prototype.call = function(subscriber, source) {
                var selector = this.selector, subject = this.subjectFactory(), subscription = selector(subject).subscribe(subscriber);
                return subscription.add(source.subscribe(subject)), subscription;
            }, MulticastOperator;
        }();
        //# sourceMappingURL=multicast.js.map
        /***/    }, 
    /* 104 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
                var of = __webpack_require__(64), defer = __webpack_require__(134), tslib_es6 = __webpack_require__(3), Subscriber = __webpack_require__(7);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/pairwise.js
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function pairwise() {
            return function(source) {
                return source.lift(new PairwiseOperator());
            };
        }
        var PairwiseOperator = /* */ function() {
            function PairwiseOperator() {}
            return PairwiseOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new pairwise_PairwiseSubscriber(subscriber));
            }, PairwiseOperator;
        }(), pairwise_PairwiseSubscriber = /* */ function(_super) {
            function PairwiseSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.hasPrev = !1, _this;
            }
            return tslib_es6.a(PairwiseSubscriber, _super), PairwiseSubscriber.prototype._next = function(value) {
                this.hasPrev ? this.destination.next([ this.prev, value ]) : this.hasPrev = !0, 
                this.prev = value;
            }, PairwiseSubscriber;
        }(Subscriber.a), map = __webpack_require__(42), filter = __webpack_require__(137), startWith = __webpack_require__(138), switchMap = __webpack_require__(117), tap = __webpack_require__(150), log = __webpack_require__(0);
        __webpack_exports__.a = function speedManager(mediaElement, speed$, clock$, _ref) {
            var forcePause$, _ref$pauseWhenStalled = _ref.pauseWhenStalled;
            forcePause$ = void 0 === _ref$pauseWhenStalled || _ref$pauseWhenStalled ? clock$.pipe(pairwise()).pipe(Object(map.a)(function(_ref2) {
                var prevTiming = _ref2[0], isStalled = _ref2[1].stalled, wasStalled = prevTiming.stalled;
                if (!wasStalled != !isStalled || // xor
                wasStalled && isStalled && wasStalled.reason !== isStalled.reason) return !wasStalled;
            }), Object(filter.a)(function(val) {
                return null != val;
            }), Object(startWith.a)(!1)) : Object(of.a)(!1);
            return forcePause$.pipe(Object(switchMap.a)(function(shouldForcePause) {
                return shouldForcePause ? Object(defer.a)(function() {
                    return log.a.info("SpeedManager: Pause playback to build buffer"), mediaElement.playbackRate = 0, 
                    Object(of.a)(0);
                }) : speed$.pipe(Object(tap.a)(function(speed) {
                    log.a.info("SpeedManager: Resume playback speed", speed), mediaElement.playbackRate = speed;
                }));
            }));
        };
    }, 
    /* 105 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(3), Scheduler = /* */ function() {
            function Scheduler(SchedulerAction, now) {
                void 0 === now && (now = Scheduler.now), this.SchedulerAction = SchedulerAction, 
                this.now = now;
            }
            return Scheduler.prototype.schedule = function(work, delay, state) {
                return void 0 === delay && (delay = 0), new this.SchedulerAction(this, work).schedule(state, delay);
            }, Scheduler.now = function() {
                return Date.now();
            }, Scheduler;
        }();
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Scheduler.js
                //# sourceMappingURL=Scheduler.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return AsyncScheduler_AsyncScheduler;
        });
        /** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
        var AsyncScheduler_AsyncScheduler = /* */ function(_super) {
            function AsyncScheduler(SchedulerAction, now) {
                void 0 === now && (now = Scheduler.now);
                var _this = _super.call(this, SchedulerAction, function() {
                    return AsyncScheduler.delegate && AsyncScheduler.delegate !== _this ? AsyncScheduler.delegate.now() : now();
                }) || this;
                return _this.actions = [], _this.active = !1, _this.scheduled = void 0, _this;
            }
            return tslib_es6.a(AsyncScheduler, _super), AsyncScheduler.prototype.schedule = function(work, delay, state) {
                return void 0 === delay && (delay = 0), AsyncScheduler.delegate && AsyncScheduler.delegate !== this ? AsyncScheduler.delegate.schedule(work, delay, state) : _super.prototype.schedule.call(this, work, delay, state);
            }, AsyncScheduler.prototype.flush = function(action) {
                var actions = this.actions;
                if (this.active) actions.push(action); else {
                    var error;
                    this.active = !0;
                    do {
                        if (error = action.execute(action.state, action.delay)) break;
                    } while (action = actions.shift());
                    if (this.active = !1, error) {
                        for (;action = actions.shift(); ) action.unsubscribe();
                        throw error;
                    }
                }
            }, AsyncScheduler;
        }(Scheduler);
        //# sourceMappingURL=AsyncScheduler.js.map
        /***/    }, 
    /* 106 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(3), Action_Action = /* */ function(_super) {
            function Action(scheduler, work) {
                return _super.call(this) || this;
            }
            return tslib_es6.a(Action, _super), Action.prototype.schedule = function(state, delay) {
                return void 0 === delay && (delay = 0), this;
            }, Action;
        }(__webpack_require__(15).a);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
                //# sourceMappingURL=Action.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return AsyncAction_AsyncAction;
        });
        /** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
        var AsyncAction_AsyncAction = /* */ function(_super) {
            function AsyncAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this.pending = !1, _this;
            }
            return tslib_es6.a(AsyncAction, _super), AsyncAction.prototype.schedule = function(state, delay) {
                if (void 0 === delay && (delay = 0), this.closed) return this;
                this.state = state;
                var id = this.id, scheduler = this.scheduler;
                return null != id && (this.id = this.recycleAsyncId(scheduler, id, delay)), this.pending = !0, 
                this.delay = delay, this.id = this.id || this.requestAsyncId(scheduler, this.id, delay), 
                this;
            }, AsyncAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), setInterval(scheduler.flush.bind(scheduler, this), delay);
            }, AsyncAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
                if (void 0 === delay && (delay = 0), null !== delay && this.delay === delay && !1 === this.pending) return id;
                clearInterval(id);
            }, AsyncAction.prototype.execute = function(state, delay) {
                if (this.closed) return new Error("executing a cancelled action");
                this.pending = !1;
                var error = this._execute(state, delay);
                if (error) return error;
                !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
            }, AsyncAction.prototype._execute = function(state, delay) {
                var errored = !1, errorValue = void 0;
                try {
                    this.work(state);
                } catch (e) {
                    errored = !0, errorValue = !!e && e || new Error(e);
                }
                if (errored) return this.unsubscribe(), errorValue;
            }, AsyncAction.prototype._unsubscribe = function() {
                var id = this.id, scheduler = this.scheduler, actions = scheduler.actions, index = actions.indexOf(this);
                this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== index && actions.splice(index, 1), 
                null != id && (this.id = this.recycleAsyncId(scheduler, id, null)), this.delay = null;
            }, AsyncAction;
        }(Action_Action);
        //# sourceMappingURL=AsyncAction.js.map
        /***/    }, 
    /* 107 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // ugly but working webpack workaround to be able to import the library in
        // CommonJS mode.
        // TODO investigate
        /* tslint:disable no-var-requires */        module.exports = __webpack_require__(124).default;
    }, 
    /* 108 */ 
    /* 109 */
    /***/ , 
    /* 109 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return concat;
        });
        /* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31), _of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64), _from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35), _operators_concatAll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(110);
        /* harmony import */        
        /** PURE_IMPORTS_START _util_isScheduler,_of,_from,_operators_concatAll PURE_IMPORTS_END */
        function concat() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            return 1 === observables.length || 2 === observables.length && Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.a)(observables[1]) ? Object(_from__WEBPACK_IMPORTED_MODULE_2__.a)(observables[0]) : Object(_operators_concatAll__WEBPACK_IMPORTED_MODULE_3__.a)()(_of__WEBPACK_IMPORTED_MODULE_1__.a.apply(void 0, observables));
        }
        //# sourceMappingURL=concat.js.map
        /***/    }, 
    /* 110 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return concatAll;
        });
        /* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98);
        /** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */        function concatAll() {
            return Object(_mergeAll__WEBPACK_IMPORTED_MODULE_0__.a)(1);
        }
        //# sourceMappingURL=concatAll.js.map
        /***/    }, 
    /* 111 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
        /* harmony import */        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * Image SourceBuffer implementation.
 * @class ImageSourceBuffer
 */        var ImageSourceBuffer = 
        /* */
        function(_AbstractSourceBuffer) {
            function ImageSourceBuffer() {
                return _AbstractSourceBuffer.apply(this, arguments) || this;
            }
            _inheritsLoose(ImageSourceBuffer, _AbstractSourceBuffer);
            var _proto = ImageSourceBuffer.prototype;
            /**
   * @param {Object} data
   */            return _proto._append = function _append(data) {
                _log__WEBPACK_IMPORTED_MODULE_0__.a.debug("ImageSourceBuffer: appending new data.");
                var start = data.start, end = data.end, timescale = data.timescale;
                this.buffered.insert(start / timescale, null == end ? Number.MAX_VALUE : end / timescale);
            }, 
            /**
   * @param {Number} from
   * @param {Number} to
   */
            _proto._remove = function _remove(from, to) {
                _log__WEBPACK_IMPORTED_MODULE_0__.a.info("ImageSourceBuffer: ignored image data remove order", from, to);
 // TODO once a better strategy for image cleaning has been set (surely done
                // when we will work for live thumbnails), restore this implementation.
                // log.debug("ImageSourceBuffer: removing image data", from, to);
                // this.buffered.remove(from, to);
                        }, _proto._abort = function _abort() {
                _log__WEBPACK_IMPORTED_MODULE_0__.a.debug("ImageSourceBuffer: aborting image source buffer");
            }, ImageSourceBuffer;
        }(__webpack_require__(85).a);
        /* harmony default export */        __webpack_exports__.default = ImageSourceBuffer;
    }, 
    /* 112 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _utils_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * @param {UInt8Array} buf
 * @returns {Object}
 */        
        /* harmony default export */ __webpack_exports__.default = function parseBif(buf) {
            var pos = 0, length = buf.length, fileFormat = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.f)(buf.subarray(pos, pos + 8)), minorVersion = buf[pos += 8], majorVersion = buf[pos += 1], patchVersion = buf[pos += 1], increVersion = buf[pos += 1];
            pos += 1;
            var version = [ minorVersion, majorVersion, patchVersion, increVersion ].join("."), imageCount = buf[pos] + Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos + 1);
            pos += 4;
            var timescale = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos);
            pos += 4;
            var format = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.f)(buf.subarray(pos, pos + 4));
            pos += 4;
            var width = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.n)(buf, pos);
            pos += 2;
            var height = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.n)(buf, pos), aspectRatio = [ buf[pos += 2], buf[pos + 1] ].join(":"), isVod = 1 === buf[pos += 2];
            pos += 1, // bytes 0x1F to 0x40 is unused data for now
            pos = 64;
            var currentImage, thumbs = [], currentTs = 0;
            if (!imageCount) throw new Error("bif: no images to parse");
            for (;pos < length; ) {
                var currentImageIndex = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos);
                pos += 4;
                var currentImageOffset = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos);
                if (pos += 4, currentImage) {
                    var index = currentImage.index, duration = timescale, ts = currentTs, data = buf.subarray(currentImage.offset, currentImageOffset);
                    thumbs.push({
                        index: index,
                        duration: duration,
                        ts: ts,
                        data: data
                    }), currentTs += timescale;
                }
                if (4294967295 === currentImageIndex) break;
                currentImage = {
                    index: currentImageIndex,
                    offset: currentImageOffset
                };
            }
            return {
                fileFormat: fileFormat,
                version: version,
                imageCount: imageCount,
                timescale: timescale,
                format: format,
                width: width,
                height: height,
                aspectRatio: aspectRatio,
                isVod: isVod,
                thumbs: thumbs
            };
        };
    }, 
    /* 113 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseVTTStringToVTTCues;
        });
        /* harmony import */ var _compat_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), _utils_array_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13), _getCueBlocks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89), _parseCueBlock__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99), _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        // Simple VTT to ICompatVTTCue parser:
        // Just parse cues and associated settings.
        // Does not take into consideration STYLE and REGION blocks.
        /**
 * Parse whole WEBVTT file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} vttStr
 * @param {Number} timeOffset
 * @returns {Array.<ICompatVTTCue|TextTrackCue>}
 */
        function parseVTTStringToVTTCues(vttStr, timeOffset) {
            // WEBVTT authorize CRLF, LF or CR as line terminators
            var lines = vttStr.split(/\r\n|\n|\r/);
            if (!/^WEBVTT($| |\t)/.test(lines[0])) throw new Error("Can't parse WebVTT: Invalid file.");
            for (var firstLineAfterHeader = Object(_utils__WEBPACK_IMPORTED_MODULE_4__.b)(lines), cueBlocks = Object(_getCueBlocks__WEBPACK_IMPORTED_MODULE_2__.a)(lines, firstLineAfterHeader), cues = [], i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(_parseCueBlock__WEBPACK_IMPORTED_MODULE_3__.a)(cueBlocks[i], timeOffset);
                if (null != cueObject) {
                    var nativeCue = toNativeCue(cueObject);
                    null != nativeCue && (Object(_compat_index__WEBPACK_IMPORTED_MODULE_0__.i)(nativeCue) && setSettingsOnCue(cueObject.settings, nativeCue), 
                    cues.push(nativeCue));
                }
            }
            return cues;
        }
        /**
 * @param {Object} cue Object
 * @returns {TextTrackCue|ICompatVTTCue|null}
 */        function toNativeCue(cueObj) {
            var start = cueObj.start, end = cueObj.end, text = cueObj.payload.join("\n");
            return Object(_compat_index__WEBPACK_IMPORTED_MODULE_0__.j)(start, end, text);
        }
        /**
 * Add the corresponding settings on the given cue.
 * /!\ Mutates the cue given.
 * @param {Object} settings - settings for the cue, as a key-value object.
 * @param {ICompatVTTCue|TextTrackCue} cue
 */        function setSettingsOnCue(settings, cue) {
            if (!settings.vertical || "rl" !== settings.vertical && "lr" !== settings.vertical || (cue.vertical = settings.vertical), 
            settings.line) {
                /**
     * Capture groups:
     *   1 -> percentage position
     *   2 -> optional decimals from percentage position
     *   3 -> optional follow-up of the string indicating alignment value
     *   4 -> alignment value
     * @type {RegExp}
     */
                var percentageMatches = settings.line.match(/^(\d+(\.\d+)?)%(,([a-z]+))?/);
                if (percentageMatches) cue.line = Number(percentageMatches[1]), cue.snapToLines = !1, 
                Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)([ "start", "center", "end" ], percentageMatches[4]) && (cue.lineAlign = percentageMatches[4]); else {
                    /**
       * Capture groups:
       *   1 -> line number
       *   2 -> optional follow-up of the string indicating alignment value
       *   3 -> alignment value
       * @type {RegExp}
       */
                    var lineMatches = settings.line.match(/^(-?\d+)(,([a-z]+))?/);
                    lineMatches && (cue.line = Number(lineMatches[1]), cue.snapToLines = !0, Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)([ "start", "center", "end" ], lineMatches[3]) && (cue.lineAlign = lineMatches[3]));
                }
            }
            if (settings.position) {
                var positionArr = /^([\d\.]+)%(?:,(line-left|line-right|center))?$/.exec(settings.position);
                if (positionArr && 2 <= positionArr.length) {
                    var position = parseInt(positionArr[1], 10);
                    isNaN(position) || (cue.position = position, null != positionArr[2] && (cue.positionAlign = positionArr[2]));
                }
            }
            settings.size && (cue.size = settings.size), settings.align && Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)([ "start", "center", "end", "left" ], settings.align) && (cue.align = settings.align);
        }
        /***/    }, 
    /* 114 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var array_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11), array_find__WEBPACK_IMPORTED_MODULE_0___default = /* */ __webpack_require__.n(array_find__WEBPACK_IMPORTED_MODULE_0__), object_assign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6), object_assign__WEBPACK_IMPORTED_MODULE_1___default = /* */ __webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_1__), _compat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8), _getParameters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90), _getParentElementsByTagName__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(60), _getTimeDelimiters__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(100), _nodes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(83), _regexps__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(29), _style__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(58), WANTED_STYLE_ATTRIBUTES = [ "extent", "writingMode", "origin", "align" ], TEXT_ALIGN_TO_LIGN_ALIGN = {
            left: "start",
            center: "center",
            right: "end",
            start: "start",
            end: "end"
        }, TEXT_ALIGN_TO_POSITION_ALIGN = {
            left: "line-left",
            center: "center",
            right: "line-right"
        };
        /* harmony import */        
        /**
 * Parses an Element into a TextTrackCue or VTTCue.
 * /!\ Mutates the given cueElement Element
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Object} paragraphStyle
 * @param {Object} params
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {TextTrackCue|null}
 */
        function parseCue(paragraph, offset, _styles, _regions, paragraphStyle, params, shouldTrimWhiteSpace) {
            // Disregard empty elements:
            // TTML allows for empty elements like <div></div>.
            // If paragraph has neither time attributes, nor
            // non-whitespace text, don't try to make a cue out of it.
            if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent || "")) return null;
            var _getTimeDelimiters = Object(_getTimeDelimiters__WEBPACK_IMPORTED_MODULE_5__.a)(paragraph, params), start = _getTimeDelimiters.start, end = _getTimeDelimiters.end, text = generateTextContent(paragraph, shouldTrimWhiteSpace), cue = Object(_compat__WEBPACK_IMPORTED_MODULE_2__.j)(start + offset, end + offset, text);
            return cue ? (Object(_compat__WEBPACK_IMPORTED_MODULE_2__.i)(cue) && addStyle(cue, paragraphStyle), 
            cue) : null;
        }
        /**
 * Generate text to display for a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Boolean} shouldTrimWhiteSpaceForParagraph
 * @returns {string}
 */        function generateTextContent(paragraph, shouldTrimWhiteSpaceForParagraph) {
            /**
   * Recursive function, taking a node in argument and returning the
   * corresponding string.
   * @param {Node} node - the node in question
   * @returns {string}
   */
            return function loop(node, shouldTrimWhiteSpaceFromParent) {
                for (var childNodes = node.childNodes, text = "", i = 0; i < childNodes.length; i++) {
                    var currentNode = childNodes[i];
                    if ("#text" === currentNode.nodeName) {
                        var textContent = currentNode.textContent || "";
                        if (shouldTrimWhiteSpaceFromParent) {
                            // 1. Trim leading and trailing whitespace.
                            // 2. Collapse multiple spaces into one.
                            var trimmed = textContent.trim();
                            textContent = trimmed = trimmed.replace(/\s+/g, " ");
                        }
 // DOM Parser turns HTML escape caracters into caracters,
                        // that may be misinterpreted by VTTCue API (typically, less-than sign
                        // and greater-than sign can be interpreted as HTML tags signs).
                        // Original escaped caracters must be conserved.
                                                text += textContent.replace(/&|\u0026/g, "&amp;").replace(/<|\u003C/g, "&lt;").replace(/>|\u2265/g, "&gt;").replace(/\u200E/g, "&lrm;").replace(/\u200F/g, "&rlm;").replace(/\u00A0/g, "&nbsp;");
                    } else if ("br" === currentNode.nodeName) text += "\n"; else if ("span" === currentNode.nodeName && currentNode.nodeType === Node.ELEMENT_NODE && 0 < currentNode.childNodes.length) {
                        var spaceAttribute = currentNode.getAttribute("xml:space");
                        text += loop(currentNode, spaceAttribute ? "default" === spaceAttribute : shouldTrimWhiteSpaceFromParent);
                    }
                }
                return text;
            }(paragraph, shouldTrimWhiteSpaceForParagraph);
        }
        /**
 * Adds applicable style properties to a cue.
 * /!\ Mutates cue argument.
 * @param {VTTCue} cue
 * @param {Object} style
 */        function addStyle(cue, style) {
            var extent = style.extent;
            if (extent) {
                var results = _regexps__WEBPACK_IMPORTED_MODULE_7__.c.exec(extent);
                null != results && (
                // Use width value of the extent attribute for size.
                // Height value is ignored.
                cue.size = Number(results[1]));
            }
            // let isVerticalText = true;
            switch (style.writingMode) {
              case "tb":
              case "tblr":
                cue.vertical = "lr";
                break;

              case "tbrl":
                cue.vertical = "rl";
            }
            var origin = style.origin;
            if (origin) _regexps__WEBPACK_IMPORTED_MODULE_7__.c.exec(origin);
            var align = style.align;
            align && ("center" === (cue.align = align) && ("center" !== cue.align && (
            // Workaround for a Chrome bug http://crbug.com/663797
            // Chrome does not support align = "center"
            cue.align = "middle"), cue.position = "auto"), cue.positionAlign = TEXT_ALIGN_TO_POSITION_ALIGN[align] || "", 
            cue.lineAlign = TEXT_ALIGN_TO_LIGN_ALIGN[align] || "");
        }
        /* harmony default export */        __webpack_exports__.default = 
        /**
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
        function parseTTMLStringToVTT(str, timeOffset) {
            var ret = [], xml = new DOMParser().parseFromString(str, "text/xml");
            if (xml) {
                var tt = xml.getElementsByTagName("tt")[0];
                if (!tt) throw new Error("invalid XML");
                for (var body = Object(_nodes__WEBPACK_IMPORTED_MODULE_6__.a)(tt), styleNodes = Object(_nodes__WEBPACK_IMPORTED_MODULE_6__.c)(tt), regionNodes = Object(_nodes__WEBPACK_IMPORTED_MODULE_6__.b)(tt), paragraphNodes = Object(_nodes__WEBPACK_IMPORTED_MODULE_6__.d)(tt), params = Object(_getParameters__WEBPACK_IMPORTED_MODULE_3__.a)(tt), styles = [], i = 0; i <= styleNodes.length - 1; i++) {
                    // TODO styles referencing other styles
                    var styleNode = styleNodes[i];
                    if (styleNode instanceof Element) {
                        var styleID = styleNode.getAttribute("xml:id");
                        null != styleID && styles.push({
                            id: styleID,
                            style: Object(_style__WEBPACK_IMPORTED_MODULE_8__.b)(styleNode)
                        });
                    }
                }
 // construct regions array based on the xml as an optimization
                                for (var regions = [], _i = 0; _i <= regionNodes.length - 1; _i++) {
                    var regionNode = regionNodes[_i];
                    if (regionNode instanceof Element) {
                        var regionID = regionNode.getAttribute("xml:id");
                        null != regionID && function() {
                            var regionStyle = Object(_style__WEBPACK_IMPORTED_MODULE_8__.b)(regionNode), associatedStyle = regionNode.getAttribute("style");
                            if (associatedStyle) {
                                var style = array_find__WEBPACK_IMPORTED_MODULE_0___default()(styles, function(x) {
                                    return x.id === associatedStyle;
                                });
                                style && (regionStyle = object_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, style.style, regionStyle));
                            }
                            regions.push({
                                id: regionID,
                                style: regionStyle
                            });
                        }();
                    }
                }
 // Computing the style takes a lot of ressources.
                // To avoid too much re-computation, let's compute the body style right
                // now and do the rest progressively.
                                for (var bodyStyle = body ? Object(_style__WEBPACK_IMPORTED_MODULE_8__.a)(WANTED_STYLE_ATTRIBUTES, [ body ], styles, regions) : Object(_style__WEBPACK_IMPORTED_MODULE_8__.a)(WANTED_STYLE_ATTRIBUTES, [], styles, regions), shouldTrimWhiteSpaceOnBody = "default" === (body ? body.getAttribute("xml:space") : void 0) || "default" === params.spaceStyle, _i2 = 0; _i2 < paragraphNodes.length; _i2++) {
                    var paragraph = paragraphNodes[_i2];
                    if (paragraph instanceof Element) {
                        var divs = Object(_getParentElementsByTagName__WEBPACK_IMPORTED_MODULE_4__.a)(paragraph, "div"), paragraphStyle = object_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, bodyStyle, Object(_style__WEBPACK_IMPORTED_MODULE_8__.a)(WANTED_STYLE_ATTRIBUTES, [ paragraph ].concat(divs), styles, regions)), paragraphSpaceAttribute = paragraph.getAttribute("xml:space"), cue = parseCue(paragraph, timeOffset, 0, 0, paragraphStyle, params, paragraphSpaceAttribute ? "default" === paragraphSpaceAttribute : shouldTrimWhiteSpaceOnBody);
                        cue && ret.push(cue);
                    }
                }
            }
            return ret;
        };
    }, 
    /* 115 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14), HTML_ENTITIES = /&#([0-9]+);/g, BR = /<br>/gi, STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i, PARAG = /\s*<p class=([^>]+)>(.*)/i, START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
        /* harmony import */        
        /**
 * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.
 * @param {Array.<Object>} cuesArray - Objects containing the start, end and
 * text.
 * @returns {Array.<VTTCue>}
 */
        function createCuesFromArray(cuesArray) {
            for (var nativeCues = [], i = 0; i < cuesArray.length; i++) {
                var _cuesArray$i = cuesArray[i], start = _cuesArray$i.start, end = _cuesArray$i.end, text = _cuesArray$i.text;
                if (text && null != end) {
                    var cue = Object(_compat__WEBPACK_IMPORTED_MODULE_0__.j)(start, end, text);
                    null != cue && nativeCues.push(cue);
                }
            }
            return nativeCues;
        }
        /**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */        function getClassNameByLang(str) {
            for (var m, ruleRe = /\.(\S+)\s*{([^}]*)}/gi, langs = {}; m = ruleRe.exec(str); ) {
                var name = m[1], lang = getCSSProperty(m[2], "lang");
                null != name && null != lang && (langs[lang] = name);
            }
            return langs;
        }
        /**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */        function getCSSProperty(str, name) {
            var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
            return matches ? matches[1] : null;
        }
        /**
 * Decode HMTL formatting into a string.
 * @param {string} text
 * @returns {string}
 */        function decodeEntities(text) {
            return text.replace(BR, "\n").replace(HTML_ENTITIES, function(_, $1) {
                return String.fromCharCode($1);
            });
        }
        /**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 * @returns {Array.<VTTCue|TextTrackCue>}
 */        
        /* harmony default export */ __webpack_exports__.default = function parseSami(smi, timeOffset, lang) {
            var up, to, syncOpen = /<sync[ >]/gi, syncClose = /<sync[ >]|<\/body>/gi, subs = [], styleMatches = smi.match(STYLE), css = styleMatches ? styleMatches[1] : "";
            // FIXME Is that wanted?
            // previously written as let to = SyncClose.exec(smi); but never used
            syncClose.exec(smi);
            var langs = getClassNameByLang(css), klass = lang && langs[lang];
            for (Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__.b)(!!klass, "sami: could not find lang " + lang + " in CSS"); up = syncOpen.exec(smi), 
            to = syncClose.exec(smi), up || to; ) {
                if (!up || !to || up.index >= to.index) throw new Error("parse error");
                var str = smi.slice(up.index, to.index), tim = str.match(START);
                if (!tim) throw new Error("parse error (sync time attribute)");
                var start = +tim[1];
                if (isNaN(start)) throw new Error("parse error (sync time attribute NaN)");
                appendToSubs(str.split("\n"), start / 1e3);
            }
            return createCuesFromArray(subs);
            function appendToSubs(lines, start) {
                for (var m, i = lines.length; 0 <= --i; ) if (m = lines[i].match(PARAG)) {
                    var _m = m, kl = _m[1], txt = _m[2];
                    klass === kl && ("&nbsp;" === txt ? subs[subs.length - 1].end = start : subs.push({
                        text: decodeEntities(txt),
                        start: start + timeOffset
                    }));
                }
            }
        };
    }, 
    /* 116 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseSRTStringToVTTCues;
        });
        /* harmony import */ var _compat_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), _getCueBlocks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(101), _parseCue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(102);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        // srt to VTTCue parser, Done for fun.
        // Heavily inspired from the WebVTT implementation
        /**
 * Parse whole srt file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
        function parseSRTStringToVTTCues(srtStr, timeOffset) {
            for (
            // Even if srt only authorize CRLF, we will also take LF or CR as line
            // terminators for resilience
            var lines = srtStr.split(/\r\n|\n|\r/), cueBlocks = Object(_getCueBlocks__WEBPACK_IMPORTED_MODULE_1__.a)(lines), cues = [], i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(_parseCue__WEBPACK_IMPORTED_MODULE_2__.a)(cueBlocks[i], timeOffset);
                if (cueObject) {
                    var nativeCue = toNativeCue(cueObject);
                    nativeCue && cues.push(nativeCue);
                }
            }
            return cues;
        }
        /**
 * @param {Object} cue Object
 * @returns {TextTrackCue|VTTCue|null}
 */        function toNativeCue(cueObj) {
            var start = cueObj.start, end = cueObj.end, text = cueObj.payload.join("\n");
            return Object(_compat_index__WEBPACK_IMPORTED_MODULE_0__.j)(start, end, text);
        }
        /***/    }, 
    /* 117 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return switchMap;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23), _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22), _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(42), _observable_from__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
        function switchMap(project, resultSelector) {
            return "function" == typeof resultSelector ? function(source) {
                return source.pipe(switchMap(function(a, i) {
                    return Object(_observable_from__WEBPACK_IMPORTED_MODULE_5__.a)(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_4__.a)(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }));
            } : function(source) {
                return source.lift(new SwitchMapOperator(project));
            };
        }
        var SwitchMapOperator = /* */ function() {
            function SwitchMapOperator(project) {
                this.project = project;
            }
            return SwitchMapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
            }, SwitchMapOperator;
        }(), SwitchMapSubscriber = /* */ function(_super) {
            function SwitchMapSubscriber(destination, project) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.index = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SwitchMapSubscriber, _super), SwitchMapSubscriber.prototype._next = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (error) {
                    return void this.destination.error(error);
                }
                this._innerSub(result, value, index);
            }, SwitchMapSubscriber.prototype._innerSub = function(result, value, index) {
                var innerSubscription = this.innerSubscription;
                innerSubscription && innerSubscription.unsubscribe();
                var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__.a(this, void 0, void 0);
                this.destination.add(innerSubscriber), this.innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__.a)(this, result, value, index, innerSubscriber);
            }, SwitchMapSubscriber.prototype._complete = function() {
                var innerSubscription = this.innerSubscription;
                innerSubscription && !innerSubscription.closed || _super.prototype._complete.call(this), 
                this.unsubscribe();
            }, SwitchMapSubscriber.prototype._unsubscribe = function() {
                this.innerSubscription = null;
            }, SwitchMapSubscriber.prototype.notifyComplete = function(innerSub) {
                this.destination.remove(innerSub), this.innerSubscription = null, this.isStopped && _super.prototype._complete.call(this);
            }, SwitchMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, SwitchMapSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 118 */
    /***/ function(module, exports, __webpack_require__) {
        var pSlice = Array.prototype.slice, objectKeys = __webpack_require__(122), isArguments = __webpack_require__(123), deepEqual = module.exports = function(actual, expected, opts) {
            // 7.1. All identical values are equivalent, as determined by ===.
            return opts || (opts = {}), actual === expected || (actual instanceof Date && expected instanceof Date ? actual.getTime() === expected.getTime() : !actual || !expected || "object" != typeof actual && "object" != typeof expected ? opts.strict ? actual === expected : actual == expected : objEquiv(actual, expected, opts));
        };
        function isUndefinedOrNull(value) {
            return null == value;
        }
        function isBuffer(x) {
            return !(!x || "object" != typeof x || "number" != typeof x.length) && ("function" == typeof x.copy && "function" == typeof x.slice && !(0 < x.length && "number" != typeof x[0]));
        }
        function objEquiv(a, b, opts) {
            var i, key;
            if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return !1;
            // an identical 'prototype' property.
                        if (a.prototype !== b.prototype) return !1;
            //~~~I've managed to break Object.keys through screwy arguments passing.
            //   Converting to array solves the problem.
                        if (isArguments(a)) return !!isArguments(b) && (a = pSlice.call(a), 
            b = pSlice.call(b), deepEqual(a, b, opts));
            if (isBuffer(a)) {
                if (!isBuffer(b)) return !1;
                if (a.length !== b.length) return !1;
                for (i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
                return !0;
            }
            try {
                var ka = objectKeys(a), kb = objectKeys(b);
            } catch (e) {
                //happens when one is a string literal and the other isn't
                return !1;
            }
            // having the same number of owned properties (keys incorporates
            // hasOwnProperty)
                        if (ka.length != kb.length) return !1;
            //the same set of keys (although not necessarily the same order),
                        //~~~cheap key test
            for (ka.sort(), kb.sort(), i = ka.length - 1; 0 <= i; i--) if (ka[i] != kb[i]) return !1;
            //equivalent values for every corresponding key, and
            //~~~possibly expensive deep test
                        for (i = ka.length - 1; 0 <= i; i--) if (key = ka[i], !deepEqual(a[key], b[key], opts)) return !1;
            return typeof a == typeof b;
        }
        /***/    }, 
    /* 119 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14), HTML_ENTITIES = /&#([0-9]+);/g, BR = /<br>/gi, STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i, PARAG = /\s*<p class=([^>]+)>(.*)/i, START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // __VERY__ simple SAMI parser, based on ugly-but-working REGEXP:
        //   - the text, start and end times are correctly parsed.
        //   - only text for the given language is parsed.
        //   - only the CSS style associated to the P element is set.
        //   - we should be safe for any XSS.
        // The language indicated to the parser should be present in the CSS and the
        // corresponding Class should be on the P elements. If we fail to find the
        // language in a "lang" property of a CSS class, the parser will throw.
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */        
        /**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */
        function getClassNameByLang(str) {
            for (var m, ruleRe = /\.(\S+)\s*{([^}]*)}/gi, langs = {}; m = ruleRe.exec(str); ) {
                var name = m[1], lang = getCSSProperty(m[2], "lang");
                null != name && null != lang && (langs[lang] = name);
            }
            return langs;
        }
        /**
 * Returns the rules defined for the P element.
 * Empty string if not found.
 * @param {string} str - The entire styling part.
 * @returns {string}
 */        function getPCSSRules(str) {
            var rule = /p\s*{([^}]*)}/gi.exec(str);
            return rule ? rule[1] : "";
        }
        /**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */        function getCSSProperty(str, name) {
            var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
            return matches ? matches[1] : null;
        }
        /**
 * @param {string} text
 * @returns {string}
 */        function decodeEntities(text) {
            return text.replace(HTML_ENTITIES, function(_, $1) {
                return String.fromCharCode($1);
            });
        }
        /**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 */        
        /* harmony default export */ __webpack_exports__.default = function parseSami(smi, timeOffset, lang) {
            var up, to, syncOpen = /<sync[ >]/gi, syncClose = /<sync[ >]|<\/body>/gi, subs = [], styleMatches = smi.match(STYLE), css = styleMatches ? styleMatches[1] : "";
            // FIXME Is that wanted?
            // previously written as let to = SyncClose.exec(smi); but never used
            syncClose.exec(smi);
            var langs = getClassNameByLang(css), pCSS = getPCSSRules(css), klass = lang && langs[lang];
            for (Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__.b)(!!klass, "sami: could not find lang " + lang + " in CSS"); up = syncOpen.exec(smi), 
            to = syncClose.exec(smi), up || to; ) {
                if (!up || !to || up.index >= to.index) throw new Error("parse error");
                var str = smi.slice(up.index, to.index), tim = str.match(START);
                if (!tim) throw new Error("parse error (sync time attribute)");
                var start = +tim[1];
                if (isNaN(start)) throw new Error("parse error (sync time attribute NaN)");
                appendToSubs(str.split("\n"), start / 1e3);
            }
            return subs;
            function appendToSubs(lines, start) {
                for (var i = lines.length; 0 <= --i; ) {
                    var paragraphInfos = lines[i].match(PARAG);
                    if (paragraphInfos) {
                        var className = paragraphInfos[1], txt = paragraphInfos[2];
                        if (klass === className) if ("&nbsp;" === txt) subs[subs.length - 1].end = start; else {
                            var wrapperEl = document.createElement("DIV");
                            wrapperEl.className = "rxp-texttrack-region";
                            var divEl = document.createElement("DIV");
                            divEl.className = "rxp-texttrack-div", divEl.style.position = "absolute", divEl.style.bottom = "0", 
                            divEl.style.width = "100%", divEl.style.color = "#fff", divEl.style.textShadow = "-1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000";
                            var pEl = document.createElement("div");
                            pEl.className = "rxp-texttrack-p", pCSS && (pEl.style.cssText = pCSS);
                            for (var textEls = txt.split(BR), j = 0; j < textEls.length; j++) {
                                j && pEl.appendChild(document.createElement("BR"));
                                var spanEl = document.createElement("SPAN");
                                spanEl.className = "rxp-texttrack-span", spanEl.textContent = decodeEntities(textEls[j]), 
                                pEl.appendChild(spanEl);
                            }
                            divEl.appendChild(pEl), wrapperEl.appendChild(divEl), subs.push({
                                element: wrapperEl,
                                start: start + timeOffset,
                                end: -1
                            });
                        }
                    }
                }
            }
        };
    }, 
    /* 120 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseSRTStringToHTML;
        });
        /* harmony import */ var _getCueBlocks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101), _parseCue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(102);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        // Parse SRT subtitles into HTML.
        // Done for fun. Understand <b>, <i>, <u> and <font color="#ff0000" /> type
        // of tags.
        /**
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
        function parseSRTStringToHTML(srtStr, timeOffset) {
            for (
            // Even if srt only authorize CRLF, we will also take LF or CR as line
            // terminators for resilience
            var lines = srtStr.split(/\r\n|\n|\r/), cueBlocks = Object(_getCueBlocks__WEBPACK_IMPORTED_MODULE_0__.a)(lines), cues = [], i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(_parseCue__WEBPACK_IMPORTED_MODULE_1__.a)(cueBlocks[i], timeOffset);
                if (null != cueObject) {
                    var htmlCue = toHTML(cueObject);
                    null != htmlCue && cues.push(htmlCue);
                }
            }
            return cues;
        }
        /**
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object|null}
 */        function toHTML(cueObj) {
            var start = cueObj.start, end = cueObj.end, payload = cueObj.payload, pEl = document.createElement("div");
            pEl.className = "rxp-texttrack-p", pEl.style.fontSize = "28px", pEl.style.position = "absolute", 
            pEl.style.bottom = "5%", pEl.style.width = "100%", pEl.style.textAlign = "center", 
            pEl.style.color = "#fff", pEl.style.textShadow = "-1px -1px 2px #000,1px -1px 2px #000,-1px 1px 2px #000,1px 1px 2px #000";
            for (var i = 0; i < payload.length; i++) {
                i && pEl.appendChild(document.createElement("br"));
                var span = generateSpansFromSRTText(payload[i]);
                pEl.appendChild(span);
            }
            return {
                start: start,
                end: end,
                element: pEl
            };
        }
        /**
 * Take a single srt line and convert it into a span with the right style while
 * avoiding XSS.
 * What we do is set a whitelist of authorized tags, and recreate the
 * corresponding tag from scratch.
 * Supported tags:
 *   - <b>: make content bold
 *   - <i>: make content italic
 *   - <u>: draw underline on content
 *   - <font color="x">: add color x to the content
 * @param {string} text
 * @returns {HTMLElement}
 */        function generateSpansFromSRTText(text) {
            var secureDiv = document.createElement("div");
            secureDiv.innerHTML = text;
            return function _loop(node) {
                var childNodes = node.childNodes, span = document.createElement("span");
                span.className = "rxp-texttrack-span";
                for (var i = 0; i < childNodes.length; i++) {
                    var currentNode = childNodes[i];
                    if ("#text" === currentNode.nodeName) {
                        for (var linifiedText = currentNode.wholeText.split("\n"), line = 0; line < linifiedText.length; line++) if (line && span.appendChild(document.createElement("br")), 
                        0 < linifiedText[line].length) {
                            var textNode = document.createTextNode(linifiedText[line]);
                            span.appendChild(textNode);
                        }
                    } else if ("B" === currentNode.nodeName) {
                        var spanChild = _loop(currentNode);
                        spanChild.style.fontWeight = "bold", span.appendChild(spanChild);
                    } else if ("I" === currentNode.nodeName) {
                        var _spanChild = _loop(currentNode);
                        _spanChild.style.fontStyle = "italic", span.appendChild(_spanChild);
                    } else if ("U" === currentNode.nodeName) {
                        var _spanChild2 = _loop(currentNode);
                        _spanChild2.style.textDecoration = "underline", span.appendChild(_spanChild2);
                    } else if ("FONT" === currentNode.nodeName && null != currentNode.color) {
                        // TODO loop through attributes to find color?
                        var _spanChild3 = _loop(currentNode);
                        _spanChild3.style.color = currentNode.color, span.appendChild(_spanChild3);
                    } else {
                        var _spanChild4 = _loop(currentNode);
                        span.appendChild(_spanChild4);
                    }
                }
                return span;
            }(secureDiv);
        }
        /***/    }, 
    /* 121 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return StreamDirectFile;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(135), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(144), _compat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8), _errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(28), _log__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0), _create_eme_manager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(93), _events_generators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(30), _initial_seek_and_play__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(91), _media_error_manager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(94), _speed_manager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(104), _stalling_manager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(95);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * calculate initial time as a position in seconds.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object|undefined} startAt
 * @returns {number}
 */
        function getDirectFileInitialTime(mediaElement, startAt) {
            if (!startAt) return 0;
            if (null != startAt.position) return startAt.position;
            if (null != startAt.wallClockTime) return startAt.wallClockTime;
            if (null != startAt.fromFirstPosition) return startAt.fromFirstPosition;
            var duration = mediaElement.duration;
            if (!duration || !isFinite(duration)) return _log__WEBPACK_IMPORTED_MODULE_7__.a.warn("startAt.fromLastPosition set but no known duration, beginning at 0."), 
            0;
            if (startAt.fromLastPosition) return Math.max(0, duration + startAt.fromLastPosition);
            if (null == startAt.percentage) return 0;
            var percentage = startAt.percentage;
            return 100 <= percentage ? duration : percentage <= 0 ? 0 : duration * (+percentage / 100);
        }
        /**
 * Launch a Stream in "Directfile mode".
 * @param {Object} directfileOptions
 * @returns {Observable}
 */        function StreamDirectFile(_ref) {
            var autoPlay = _ref.autoPlay, clock$ = _ref.clock$, keySystems = _ref.keySystems, mediaElement = _ref.mediaElement, speed$ = _ref.speed$, startAt = _ref.startAt, url = _ref.url;
            Object(_compat__WEBPACK_IMPORTED_MODULE_5__.c)(mediaElement), _log__WEBPACK_IMPORTED_MODULE_7__.a.debug("Stream: Calculating initial time");
            var initialTime = function initialTime() {
                return getDirectFileInitialTime(mediaElement, startAt);
            };
            _log__WEBPACK_IMPORTED_MODULE_7__.a.debug("Stream: Initial time calculated:", initialTime);
            var _seekAndLoadOnMediaEv = Object(_initial_seek_and_play__WEBPACK_IMPORTED_MODULE_10__.a)(mediaElement, initialTime, autoPlay), seek$ = _seekAndLoadOnMediaEv.seek$, load$ = _seekAndLoadOnMediaEv.load$, emeManager$ = Object(_create_eme_manager__WEBPACK_IMPORTED_MODULE_8__.a)(mediaElement, keySystems), errorManager$ = Object(_media_error_manager__WEBPACK_IMPORTED_MODULE_11__.a)(mediaElement), speedManager$ = Object(_speed_manager__WEBPACK_IMPORTED_MODULE_12__.a)(mediaElement, speed$, clock$, {
                pauseWhenStalled: !0
            }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_9__.a.speedChanged)), stallingManager$ = Object(_stalling_manager__WEBPACK_IMPORTED_MODULE_13__.a)(mediaElement, clock$).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_9__.a.stalled)), loadedEvent$ = load$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(function(evt) {
                if ("autoplay-blocked" !== evt) return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_9__.a.loaded());
                var error = new _errors__WEBPACK_IMPORTED_MODULE_6__.a("MEDIA_ERR_BLOCKED_AUTOPLAY", null, !1);
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_9__.a.warning(error), _events_generators__WEBPACK_IMPORTED_MODULE_9__.a.loaded());
            })), linkURL$ = Object(_compat__WEBPACK_IMPORTED_MODULE_5__.l)(mediaElement, url).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)()), initialSeek$ = seek$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)());
 // Create EME Manager, an observable which will manage every EME-related
            // issue.
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(loadedEvent$, initialSeek$, emeManager$, errorManager$, speedManager$, stallingManager$, linkURL$);
        }
        /***/    }, 
    /* 122 */
    /***/ function(module, exports) {
        function shim(obj) {
            var keys = [];
            for (var key in obj) keys.push(key);
            return keys;
        }
        /***/        (module.exports = "function" == typeof Object.keys ? Object.keys : shim).shim = shim;
    }, 
    /* 123 */
    /***/ function(module, exports) {
        var supportsArgumentsClass = "[object Arguments]" == function() {
            return Object.prototype.toString.call(arguments);
        }();
        function supported(object) {
            return "[object Arguments]" == Object.prototype.toString.call(object);
        }
        function unsupported(object) {
            return object && "object" == typeof object && "number" == typeof object.length && Object.prototype.hasOwnProperty.call(object, "callee") && !Object.prototype.propertyIsEnumerable.call(object, "callee") || !1;
        }
        (exports = module.exports = supportsArgumentsClass ? supported : unsupported).supported = supported, 
        exports.unsupported = unsupported;
    }, 
    /* 124 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/deep-equal/index.js
        var deep_equal = __webpack_require__(118), deep_equal_default = /* */ __webpack_require__.n(deep_equal), object_assign = __webpack_require__(6), object_assign_default = /* */ __webpack_require__.n(object_assign), Subject = __webpack_require__(33), ReplaySubject = __webpack_require__(153), tslib_es6 = __webpack_require__(3), ObjectUnsubscribedError = __webpack_require__(40), BehaviorSubject_BehaviorSubject = /* */ function(_super) {
            function BehaviorSubject(_value) {
                var _this = _super.call(this) || this;
                return _this._value = _value, _this;
            }
            return tslib_es6.a(BehaviorSubject, _super), Object.defineProperty(BehaviorSubject.prototype, "value", {
                get: function() {
                    return this.getValue();
                },
                enumerable: !0,
                configurable: !0
            }), BehaviorSubject.prototype._subscribe = function(subscriber) {
                var subscription = _super.prototype._subscribe.call(this, subscriber);
                return subscription && !subscription.closed && subscriber.next(this._value), subscription;
            }, BehaviorSubject.prototype.getValue = function() {
                if (this.hasError) throw this.thrownError;
                if (this.closed) throw new ObjectUnsubscribedError.a();
                return this._value;
            }, BehaviorSubject.prototype.next = function(value) {
                _super.prototype.next.call(this, this._value = value);
            }, BehaviorSubject;
        }(Subject.a), merge = __webpack_require__(135), empty = __webpack_require__(27), combineLatest = __webpack_require__(145), concat = __webpack_require__(109), of = __webpack_require__(64), takeUntil = __webpack_require__(141), map = __webpack_require__(42), distinctUntilChanged = __webpack_require__(140), take = __webpack_require__(142), multicast = __webpack_require__(103);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/publish.js
        /** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */
        function publish(selector) {
            return selector ? Object(multicast.a)(function() {
                return new Subject.a();
            }, selector) : Object(multicast.a)(new Subject.a());
        }
        //# sourceMappingURL=publish.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
                var filter = __webpack_require__(137), share = __webpack_require__(152), startWith = __webpack_require__(138), mapTo = __webpack_require__(149), Subscriber = __webpack_require__(7);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/share.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/skipWhile.js
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function skipWhile(predicate) {
            return function(source) {
                return source.lift(new SkipWhileOperator(predicate));
            };
        }
        var SkipWhileOperator = /* */ function() {
            function SkipWhileOperator(predicate) {
                this.predicate = predicate;
            }
            return SkipWhileOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new skipWhile_SkipWhileSubscriber(subscriber, this.predicate));
            }, SkipWhileOperator;
        }(), skipWhile_SkipWhileSubscriber = /* */ function(_super) {
            function SkipWhileSubscriber(destination, predicate) {
                var _this = _super.call(this, destination) || this;
                return _this.predicate = predicate, _this.skipping = !0, _this.index = 0, _this;
            }
            return tslib_es6.a(SkipWhileSubscriber, _super), SkipWhileSubscriber.prototype._next = function(value) {
                var destination = this.destination;
                this.skipping && this.tryCallPredicate(value), this.skipping || destination.next(value);
            }, SkipWhileSubscriber.prototype.tryCallPredicate = function(value) {
                try {
                    var result = this.predicate(value, this.index++);
                    this.skipping = Boolean(result);
                } catch (err) {
                    this.destination.error(err);
                }
            }, SkipWhileSubscriber;
        }(Subscriber.a), switchMapTo = __webpack_require__(151), mergeMapTo = __webpack_require__(143), catchError = __webpack_require__(146), config = __webpack_require__(2), log = __webpack_require__(0), eventemitter = __webpack_require__(36), noop = __webpack_require__(20), utils_ranges = __webpack_require__(16), warnOnce = __webpack_require__(45), fullscreen = __webpack_require__(54), events = __webpack_require__(12), constants = __webpack_require__(19), features = __webpack_require__(10), eme = __webpack_require__(86), timer = __webpack_require__(147), mergeMap = __webpack_require__(57), tap = __webpack_require__(150), switchMap = __webpack_require__(117);
        // CONCATENATED MODULE: ./src/utils/rx-throttle.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Throttle an asynchronous function returning an Observable to drop calls done
 * before a previous one has finished or failed.
 *
 * @example
 * ```js
 * const fn = (time) => Observable.timer(time);
 * const throttled = throttle(fn);
 *
 * const Obs1 = throttled(2000); // -> call fn(2000) and returns its Observable
 * const Obs2 = throttled(1000); // -> won't do anything, Obs2 is an empty
 *                               //    observable (it directly completes)
 * setTimeout(() => {
 *   const Obs3 = throttled(1000); // -> will call fn(1000)
 * }, 2001);
 * ```
 *
 * @param {Function} func
 * @returns {Function} - Function taking in argument the arguments you want
 * to give your function, and returning an Observable.
 */
        function throttle(func) {
            var isPending = !1;
            return function() {
                return isPending ? empty.a : (isPending = !0, func.apply(void 0, arguments).pipe(Object(tap.a)(noop.a, function() {
                    return isPending = !1;
                }, function() {
                    return isPending = !1;
                })));
            };
        }
        // EXTERNAL MODULE: ./node_modules/array-find/find.js
                var array_find_find = __webpack_require__(11), find_default = /* */ __webpack_require__.n(array_find_find), EWMA = 
        /* */
        function() {
            /**
   * @param {number} halfLife
   */
            function EWMA(halfLife) {
                // (half-life = log(1/2) / log(Decay Factor)
                this._alpha = Math.exp(Math.log(.5) / halfLife), this._lastEstimate = 0, this._totalWeight = 0;
            }
            /**
   * @param {number} weight
   * @param {number} value
   */            var _proto = EWMA.prototype;
            return _proto.addSample = function addSample(weight, value) {
                var adjAlpha = Math.pow(this._alpha, weight), newEstimate = value * (1 - adjAlpha) + adjAlpha * this._lastEstimate;
                isNaN(newEstimate) || (this._lastEstimate = newEstimate, this._totalWeight += weight);
            }, 
            /**
   * @returns {number} value
   */
            _proto.getEstimate = function getEstimate() {
                var zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);
                return this._lastEstimate / zeroFactor;
            }, EWMA;
        }(), ABR_MINIMUM_TOTAL_BYTES = config.a.ABR_MINIMUM_TOTAL_BYTES, ABR_MINIMUM_CHUNK_SIZE = config.a.ABR_MINIMUM_CHUNK_SIZE, ABR_FAST_EMA = config.a.ABR_FAST_EMA, ABR_SLOW_EMA = config.a.ABR_SLOW_EMA, bandwidth_estimator_BandwidthEstimator = 
        /* */
        function() {
            function BandwidthEstimator() {
                /**
     * A fast-moving average.
     * @private
     */
                this._fastEWMA = new EWMA(ABR_FAST_EMA), 
                /**
     * A slow-moving average.
     * @private
     */
                this._slowEWMA = new EWMA(ABR_SLOW_EMA), 
                /**
     * Number of bytes sampled.
     * @private
     */
                this._bytesSampled = 0;
            }
            /**
   * Takes a bandwidth sample.
   * @param {number} durationMs - The amount of time, in milliseconds, for a
   *   particular request.
   * @param {number} numBytes - The total number of bytes transferred in that
   *   request.
   */            var _proto = BandwidthEstimator.prototype;
            return _proto.addSample = function addSample(durationInMs, numberOfBytes) {
                if (!(numberOfBytes < ABR_MINIMUM_CHUNK_SIZE)) {
                    var bandwidth = 8e3 * numberOfBytes / durationInMs, weight = durationInMs / 1e3;
                    this._bytesSampled += numberOfBytes, this._fastEWMA.addSample(weight, bandwidth), 
                    this._slowEWMA.addSample(weight, bandwidth);
                }
            }, 
            /**
   * Get estimate of the bandwidth, in bits per seconds.
   * @returns {Number|undefined}
   */
            _proto.getEstimate = function getEstimate() {
                if (!(this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES)) // Take the minimum of these two estimates.  This should have the effect of
                // adapting down quickly, but up more slowly.
                return Math.min(this._fastEWMA.getEstimate(), this._slowEWMA.getEstimate());
            }, 
            /**
   * Reset the bandwidth estimation.
   */
            _proto.reset = function reset() {
                this._fastEWMA = new EWMA(ABR_FAST_EMA), this._slowEWMA = new EWMA(ABR_SLOW_EMA), 
                this._bytesSampled = 0;
            }, BandwidthEstimator;
        }(), array_find_index = __webpack_require__(61), array_find_index_default = /* */ __webpack_require__.n(array_find_index);
        // CONCATENATED MODULE: ./src/core/abr/filterByBitrate.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get only representations lower than a given bitrate.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Array.<Object>}
 */
        function filterByBitrate(representations, bitrate) {
            var firstSuperiorBitrate = array_find_index_default()(representations, function(representation) {
                return representation.bitrate > bitrate;
            });
            return -1 === firstSuperiorBitrate ? representations : representations.slice(0, firstSuperiorBitrate);
        }
        // CONCATENATED MODULE: ./src/core/abr/filterByWidth.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Filter representations based on their width:
 *   - the highest width considered will be the one linked to the first
 *     representation which has a superior width to the one given.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} width
 * @returns {Array.<Object>}
 */        function filterByWidth(representations, width) {
            var sortedRepsByWidth = representations.slice().sort(function(a, b) {
                return (a.width || 0) - (b.width || 0);
            }), repWithMaxWidth = find_default()(sortedRepsByWidth, function(representation) {
                return (representation.width || 0) >= width;
            });
            if (repWithMaxWidth) {
                var maxWidth = repWithMaxWidth.width || 0;
                return representations.filter(function(representation) {
                    return (representation.width || 0) <= maxWidth;
                });
            }
            return representations;
        }
        // CONCATENATED MODULE: ./src/core/abr/fromBitrateCeil.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Array.<Representation>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Representation}
 */        function fromBitrateCeil(representations, bitrate) {
            var tooHighIndex = array_find_index_default()(representations, function(representation) {
                return representation.bitrate > bitrate;
            });
            return -1 === tooHighIndex ? representations[representations.length - 1] : representations[tooHighIndex - 1];
        }
        // CONCATENATED MODULE: ./src/core/abr/representation_chooser.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var ABR_REGULAR_FACTOR = config.a.ABR_REGULAR_FACTOR, ABR_STARVATION_DURATION_DELTA = config.a.ABR_STARVATION_DURATION_DELTA, ABR_STARVATION_FACTOR = config.a.ABR_STARVATION_FACTOR, ABR_STARVATION_GAP = config.a.ABR_STARVATION_GAP, OUT_OF_STARVATION_GAP = config.a.OUT_OF_STARVATION_GAP;
        /**
 * Get the pending request starting with the asked segment position.
 * @param {Object} requests
 * @param {number} position
 * @returns {IRequestInfo|undefined}
 */        function getConcernedRequest(requests, neededPosition) {
            for (var currentRequestIds = Object.keys(requests), len = currentRequestIds.length, i = 0; i < len; i++) {
                var request = requests[currentRequestIds[i]];
                if (null != request && 0 < request.duration) if (neededPosition < request.time + request.duration && -.3 < neededPosition - request.time) return request;
            }
        }
        /**
 * Estimate the __VERY__ recent bandwidth based on a single unfinished request.
 * Useful when the current bandwidth seemed to have fallen quickly.
 *
 * @param {Object} request
 * @returns {number|undefined}
 */        function estimateRequestBandwidth(request) {
            if (!(request.progress.length < 2)) {
                for (// try to infer quickly the current bitrate based on the
                // progress events
                var ewma1 = new EWMA(2), progress = request.progress, i = 1; i < progress.length; i++) {
                    var bytesDownloaded = progress[i].size - progress[i - 1].size, timeElapsed = progress[i].timestamp - progress[i - 1].timestamp, reqBitrate = 8 * bytesDownloaded / (timeElapsed / 1e3);
                    ewma1.addSample(timeElapsed / 1e3, reqBitrate);
                }
                return ewma1.getEstimate();
            }
        }
        /**
 * Filter representations given through filters options.
 * @param {Array.<Representation>} representations
 * @param {Object} filters - Filter Object.
 * _Can_ contain each of the following properties:
 *   - bitrate {Number} - max bitrate authorized (included).
 *   - width {Number} - max width authorized (included).
 * @returns {Array.<Representation>}
 */        function getFilteredRepresentations(representations, filters) {
            var _representations = representations;
            return null != filters.bitrate && (_representations = filterByBitrate(_representations, filters.bitrate)), 
            null != filters.width && (_representations = filterByWidth(_representations, filters.width)), 
            _representations;
        }
        /**
 * Estimate remaining time for a pending request from a progress event.
 * @param {Object} lastProgressEvent
 * @param {number} bandwidthEstimate
 * @returns {number}
 */        function estimateRemainingTime(lastProgressEvent, bandwidthEstimate) {
            var remainingData = 8 * (lastProgressEvent.totalSize - lastProgressEvent.size);
            return Math.max(remainingData / bandwidthEstimate, 0);
        }
        /**
 * Check if the request for the most needed segment is too slow.
 * If that's the case, re-calculate the bandwidth urgently based on
 * this single request.
 * @param {Object} pendingRequests - Current pending requests.
 * @param {Object} clock - Informations on the current playback.
 * @param {Number} lastEstimatedBitrate - Last bitrate estimation emitted.
 * @returns {Number|undefined}
 */        function estimateStarvationModeBitrate(pendingRequests, clock, lastEstimatedBitrate) {
            var concernedRequest = getConcernedRequest(pendingRequests, clock.currentTime + clock.bufferGap);
            if (concernedRequest) {
                var chunkDuration = concernedRequest.duration, now = performance.now(), lastProgressEvent = concernedRequest.progress ? concernedRequest.progress[concernedRequest.progress.length - 1] : null, bandwidthEstimate = estimateRequestBandwidth(concernedRequest);
                if (null != lastProgressEvent && null != bandwidthEstimate) {
                    var remainingTime = 1.2 * estimateRemainingTime(lastProgressEvent, bandwidthEstimate);
 // if this remaining time is reliable and is not enough to avoid buffering
                                        if ((now - lastProgressEvent.timestamp) / 1e3 <= remainingTime && remainingTime > clock.bufferGap / clock.speed) return bandwidthEstimate;
                }
                var requestElapsedTime = (now - concernedRequest.requestTimestamp) / 1e3, currentBitrate = clock.downloadBitrate;
                if (!(null == currentBitrate || requestElapsedTime <= (1.5 * chunkDuration + 1) / clock.speed)) {
                    // calculate a reduced bitrate from the current one
                    var reducedBitrate = .7 * currentBitrate;
                    return null == lastEstimatedBitrate || reducedBitrate < lastEstimatedBitrate ? reducedBitrate : void 0;
                }
            }
        }
        /**
 * Returns true if, based on the current requests, it seems that the ABR should
 * switch immediately if a lower bitrate is more adapted.
 * Returns false if it estimates that you have time before switching to a lower
 * bitrate.
 * @param {Object} pendingRequests
 * @param {Object} clock
 */        function shouldDirectlySwitchToLowBitrate(pendingRequests, clock) {
            var nextNeededPosition = clock.currentTime + clock.bufferGap, requests = Object.values(pendingRequests).filter(function(a) {
                return !!a;
            }).sort(function(a, b) {
                return a.time - b.time;
            }), nextNeededRequest = find_default()(requests, function(r) {
                return r.time + r.duration > nextNeededPosition;
            });
            if (!nextNeededRequest) return !0;
            var now = performance.now(), lastProgressEvent = nextNeededRequest.progress ? nextNeededRequest.progress[nextNeededRequest.progress.length - 1] : null, bandwidthEstimate = estimateRequestBandwidth(nextNeededRequest);
            if (null == lastProgressEvent || null == bandwidthEstimate) return !0;
            var remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate);
            return !((now - lastProgressEvent.timestamp) / 1e3 <= 1.2 * remainingTime && remainingTime < clock.bufferGap / clock.speed + ABR_STARVATION_GAP);
        }
        /**
 * Choose the right representation based on multiple parameters given, such as:
 *   - the current user's bandwidth
 *   - the max bitrate authorized
 *   - the size of the video element
 *
 * Those parameters can be set through different subjects and methods.
 * The subjects (undocumented here are):
 *
 *   - manualBitrate$ {Subject}: Set the bitrate manually, if no representation
 *     is found with the given bitrate. An immediately inferior one will be
 *     taken instead. If still, none are found, the representation with the
 *     minimum bitrate will be taken.
 *     Set it to a negative value to go into automatic bitrate mode.
 *
 *   - maxBitrate$ {Subject}: Set the maximum automatic bitrate. If the manual
 *     bitrate is not set / set to a negative value, this will be the maximum
 *     switch-able bitrate. If no representation is found inferior or equal to
 *     this bitrate, the representation with the minimum bitrate will be taken.
 *
 * @class RepresentationChooser
 */        var representation_chooser_RepresentationChooser = 
        /* */
        function() {
            /**
   * @param {Object} options
   */
            function RepresentationChooser(options) {
                this._dispose$ = new Subject.a(), this.manualBitrate$ = new BehaviorSubject_BehaviorSubject(null != options.manualBitrate ? options.manualBitrate : -1), 
                this.maxAutoBitrate$ = new BehaviorSubject_BehaviorSubject(null != options.maxAutoBitrate ? options.maxAutoBitrate : Infinity), 
                this.estimator = new bandwidth_estimator_BandwidthEstimator(), this._currentRequests = {}, 
                this._initialBitrate = options.initialBitrate || 0, this._limitWidth$ = options.limitWidth$, 
                this._throttle$ = options.throttle$, this._reEstimate$ = new Subject.a();
            }
            /**
   * @param {Observable} clock$
   * @param {Array.<Object>} representations
   * @returns {Observable}
   */            var _proto = RepresentationChooser.prototype;
            return _proto.get$ = function get$(clock$, representations) {
                var _this = this;
                if (!representations.length) throw new Error("ABRManager: no representation choice given");
                if (1 === representations.length) return Object(of.a)({
                    bitrate: void 0,
                    representation: representations[0],
                    manual: !1,
                    urgent: !0
                });
                var manualBitrate$ = this.manualBitrate$, maxAutoBitrate$ = this.maxAutoBitrate$, _initialBitrate = this._initialBitrate, _deviceEventsArray = [];
                this._limitWidth$ && _deviceEventsArray.push(this._limitWidth$.pipe(Object(map.a)(function(width) {
                    return {
                        width: width
                    };
                }))), this._throttle$ && _deviceEventsArray.push(this._throttle$.pipe(Object(map.a)(function(bitrate) {
                    return {
                        bitrate: bitrate
                    };
                })));
                // Emit restrictions on the pools of available representations to choose
                // from.
                var lastEstimatedBitrate, deviceEvents$ = _deviceEventsArray.length ? combineLatest.a.apply(void 0, _deviceEventsArray).pipe(Object(map.a)(function(args) {
                    return object_assign_default.a.apply(void 0, [ {} ].concat(args));
                })) : Object(of.a)({});
 // Store the last client's bitrate generated by our estimation algorithms.
                                return manualBitrate$.pipe(Object(switchMap.a)(function(manualBitrate) {
                    if (0 <= manualBitrate) 
                    // -- MANUAL mode --
                    return Object(of.a)({
                        bitrate: void 0,
                        representation: fromBitrateCeil(representations, manualBitrate) || representations[0],
                        manual: !0,
                        urgent: !0
                    });
 // -- AUTO mode --
                                        var inStarvationMode = !1;
 // == buffer gap too low == panic mode
                                        return Object(combineLatest.a)(clock$, maxAutoBitrate$, deviceEvents$, _this._reEstimate$.pipe(Object(startWith.a)(null))).pipe(Object(map.a)(function(_ref) {
                        var newBitrateCeil, bandwidthEstimate, nextEstimate, clock = _ref[0], maxAutoBitrate = _ref[1], deviceEvents = _ref[2], bufferGap = clock.bufferGap;
                        // If in starvation mode, check if a quick new estimate can be done
                        // from the last requests.
                        // If so, cancel previous estimations and replace it by the new one
                        if (// check if should get in/out of starvation mode
                        bufferGap + clock.currentTime < clock.duration - ABR_STARVATION_DURATION_DELTA ? !inStarvationMode && bufferGap <= ABR_STARVATION_GAP ? (log.a.info("ABR: enter starvation mode."), 
                        inStarvationMode = !0) : inStarvationMode && OUT_OF_STARVATION_GAP <= bufferGap && (log.a.info("ABR: exit starvation mode."), 
                        inStarvationMode = !1) : inStarvationMode && (log.a.info("ABR: exit starvation mode."), 
                        inStarvationMode = !1), inStarvationMode && null != (bandwidthEstimate = estimateStarvationModeBitrate(_this._currentRequests, clock, lastEstimatedBitrate))) {
                            log.a.info("ABR: starvation mode emergency estimate:", bandwidthEstimate), _this.estimator.reset();
                            var currentBitrate = clock.downloadBitrate;
                            newBitrateCeil = null == currentBitrate ? Math.min(bandwidthEstimate, maxAutoBitrate) : Math.min(bandwidthEstimate, maxAutoBitrate, currentBitrate);
                        }
 // if newBitrateCeil is not yet defined, do the normal estimation
                                                null == newBitrateCeil && (nextEstimate = null != (bandwidthEstimate = _this.estimator.getEstimate()) ? inStarvationMode ? bandwidthEstimate * ABR_STARVATION_FACTOR : bandwidthEstimate * ABR_REGULAR_FACTOR : null != lastEstimatedBitrate ? inStarvationMode ? lastEstimatedBitrate * ABR_STARVATION_FACTOR : lastEstimatedBitrate * ABR_REGULAR_FACTOR : _initialBitrate, 
                        newBitrateCeil = Math.min(nextEstimate, maxAutoBitrate));
                        1 < clock.speed && (newBitrateCeil /= clock.speed);
                        var chosenRepresentation = fromBitrateCeil(getFilteredRepresentations(representations, deviceEvents), newBitrateCeil) || representations[0], urgent = function() {
                            return null == clock.downloadBitrate || (chosenRepresentation.bitrate >= clock.downloadBitrate ? !inStarvationMode : shouldDirectlySwitchToLowBitrate(_this._currentRequests, clock));
                        }();
                        return {
                            bitrate: bandwidthEstimate,
                            representation: chosenRepresentation,
                            manual: !1,
                            urgent: urgent
                        };
                    }), Object(tap.a)(function(_ref2) {
                        var bitrate = _ref2.bitrate;
                        null != bitrate && (lastEstimatedBitrate = bitrate);
                    }), Object(takeUntil.a)(_this._dispose$));
                }));
            }, 
            /**
   * Add a bandwidth estimate by giving:
   *   - the duration of the request, in s
   *   - the size of the request in bytes
   * @param {number} duration
   * @param {number} size
   */
            _proto.addEstimate = function addEstimate(duration, size) {
                null != duration && null != size && (this.estimator.addSample(duration, size), this._reEstimate$.next());
            }, 
            /**
   * Add informations about a new pending request.
   * This can be useful if the network bandwidth drastically changes to infer
   * a new bandwidth through this single request.
   * @param {string|number} id
   * @param {Object} payload
   */
            _proto.addPendingRequest = function addPendingRequest(id, payload) {
                if (this._currentRequests[id]) log.a.warn("ABR: request already added."); else {
                    var _payload$value = payload.value, time = _payload$value.time, duration = _payload$value.duration, requestTimestamp = _payload$value.requestTimestamp;
                    this._currentRequests[id] = {
                        time: time,
                        duration: duration,
                        requestTimestamp: requestTimestamp,
                        progress: []
                    };
                }
            }, 
            /**
   * Add progress informations to a pending request.
   * Progress objects are a key part to calculate the bandwidth from a single
   * request, in the case the user's bandwidth changes drastically while doing
   * it.
   * @param {string|number} id
   * @param {Object} progress
   */
            _proto.addRequestProgress = function addRequestProgress(id, progress) {
                var request = this._currentRequests[id];
                request ? request.progress.push(progress.value) : log.a.warn("ABR: progress for a request not added");
            }, 
            /**
   * Remove a request previously set as pending through the addPendingRequest
   * method.
   * @param {string|number} id
   */
            _proto.removePendingRequest = function removePendingRequest(id) {
                this._currentRequests[id] || log.a.warn("ABR: can't remove unknown request"), delete this._currentRequests[id];
            }, 
            /**
   * Free up the resources used by the RepresentationChooser.
   */
            _proto.dispose = function dispose() {
                this._dispose$.next(), this._dispose$.complete(), this._reEstimate$.next(), this._reEstimate$.complete(), 
                this.manualBitrate$.complete(), this.maxAutoBitrate$.complete();
            }, RepresentationChooser;
        }(), defaultChooserOptions = {
            limitWidth: {},
            throttle: {},
            initialBitrates: {},
            manualBitrates: {},
            maxAutoBitrates: {}
        }, abr_createChooser = function createChooser(type, options) {
            return new representation_chooser_RepresentationChooser({
                limitWidth$: options.limitWidth[type],
                throttle$: options.throttle[type],
                initialBitrate: options.initialBitrates[type],
                manualBitrate: options.manualBitrates[type],
                maxAutoBitrate: options.maxAutoBitrates[type]
            });
        }, abr_ABRManager = 
        /* */
        function() {
            /**
   * @param {Observable} requests$ - Emit requests infos as they begin, progress
   * and end.
   * Allows to know if a request take too much time to be finished in
   * emergency times (e.g. when the user's bandwidth falls very quickly).
   *
   * The items emitted are Observables which each emit infos about a SINGLE
   * request. These infos are under the form of objects with the following keys:
   *   - type {string}: the buffer type (example: "video")
   *
   *   - event {string}: Wether the request started, is progressing or has
   *     ended. Should be either one of these three strings:
   *       1. "requestBegin": The request has just begun.
   *
   *       2. "progress": Informations about the request progress were received
   *          (basically the amount of bytes currently received).
   *
   *       2. "requestEnd": The request just ended (successfully/on error/was
   *          canceled)
   *
   *     Note that it should ALWAYS happen in the following order:
   *     1 requestBegin -> 0+ progress -> 1 requestEnd
   *
   *     Also note that EVERY requestBegin should eventually be followed by a
   *     requestEnd at some point. If that's not the case, a memory leak
   *     can happen.
   *
   *   - value {Object|undefined}: The value depends on the type of event
   *     received:
   *       - for "requestBegin" events, it should be an object with the
   *         following keys:
   *           - id {number|String}: The id of this particular request.
   *           - duration {number}: duration, in seconds of the asked segment.
   *           - time {number}: The start time, in seconds of the asked segment.
   *           - requestTimestamp {number}: the timestamp at which the request
   *             was sent, in ms.
   *
   *       - for "progress" events, it should be an object with the following
   *         keys:
   *           - id {number|String}: The id of this particular request.
   *           - size {number}: amount currently downloaded, in bytes
   *           - timestamp {number}: timestamp at which the progress event was
   *             received, in ms
   *         Those events SHOULD be received in order (that is, in increasing
   *         order for both size and timestamp).
   *
   *       - for "requestEnd" events:
   *           - id {number|String}: The id of this particular request.
   *
   * @param {Observable} metrics$ - Emit each times the network downloaded
   * a new segment for a given buffer type. Allows to obtain informations about
   * the user's bitrate.
   *
   * The items emitted are object with the following keys:
   *   - type {string}: the buffer type (example: "video")
   *   - value {Object}:
   *     - duration {number}: duration of the request, in seconds.
   *     - size {number}: size of the downloaded chunks, in bytes.
   *
   * @param {Object|undefined} options
   */
            function ABRManager(requests$, metrics$, options) {
                var _this = this;
                void 0 === options && (options = defaultChooserOptions), 
                // Subject emitting and completing on dispose.
                // Used to clean up every created observables.
                this._dispose$ = new Subject.a(), // Will contain every RepresentationChooser attached to the ABRManager,
                // by type ("audio"/"video" etc.)
                this._choosers = {}, // -- OPTIONS --
                // Will contain options used when (lazily) instantiating a
                // RepresentationChooser
                this._chooserInstanceOptions = {
                    initialBitrates: options.initialBitrates || {},
                    manualBitrates: options.manualBitrates || {},
                    maxAutoBitrates: options.maxAutoBitrates || {},
                    throttle: options.throttle || {},
                    limitWidth: options.limitWidth || {}
                }, metrics$.pipe(Object(takeUntil.a)(this._dispose$)).subscribe(function(_ref) {
                    var type = _ref.type, value = _ref.value, chooser = _this._lazilyCreateChooser(type), duration = value.duration, size = value.size;
                    chooser.addEstimate(duration, size);
                }), requests$.pipe(// requests$ emits observables which are subscribed to
                Object(mergeMap.a)(function(request$) {
                    return request$;
                }), Object(takeUntil.a)(this._dispose$)).subscribe(function(request) {
                    var type = request.type, value = request.value, chooser = _this._lazilyCreateChooser(type);
                    switch (request.event) {
                      case "requestBegin":
                        // use the id of the segment as in any case, we should only have at
                        // most one active download for the same segment.
                        // This might be not optimal if this changes however. The best I think
                        // for now is to just throw/warn in DEV mode when two pending ids
                        // are identical
                        chooser.addPendingRequest(value.id, request);
                        break;

                      case "requestEnd":
                        chooser.removePendingRequest(value.id);
                        break;

                      case "progress":
                        chooser.addRequestProgress(value.id, request);
                    }
                });
            }
            /**
   * Take type and an array of the available representations, spit out an
   * observable emitting the best representation (given the network/buffer
   * state).
   * @param {string} type
   * @param {Observable<Object>} clock$
   * @param {Array.<Representation>|undefined} representations
   * @returns {Observable}
   */            var _proto = ABRManager.prototype;
            return _proto.get$ = function get$(type, clock$, representations) {
                return void 0 === representations && (representations = []), this._lazilyCreateChooser(type).get$(clock$, representations);
            }, 
            /**
   * Set manually the bitrate for a given type.
   *
   * The given number will act as a ceil.
   * If no representation is found with the given bitrate, we will consider:
   *   1. The representation just lower than it
   *   2. If no representation is found in the previous step, the representation
   *   with the lowest bitrate.
   *
   * @param {string} type
   * @param {number} bitrate
   */
            _proto.setManualBitrate = function setManualBitrate(type, bitrate) {
                log.a.info("ABR: Setting manual bitrate");
                var chooser = this._choosers[type];
                chooser ? chooser.manualBitrate$.next(bitrate) : 
                // if no chooser yet, store as a chooser option for when it will be
                // effectively instantiated
                this._chooserInstanceOptions.initialBitrates[type] = bitrate;
            }, 
            /**
   * Set a maximum bitrate a given type will be able to automatically switch to.
   * The chooser for the given type can still emit higher bitrates with the
   * setManualBitrate method.
   * @param {string} supportedBufferTypes
   * @param {number} bitrate
   */
            _proto.setMaxAutoBitrate = function setMaxAutoBitrate(type, bitrate) {
                log.a.info("ABR: Setting maximum auto bitrate");
                var chooser = this._choosers[type];
                chooser ? chooser.maxAutoBitrate$.next(bitrate) : 
                // if no chooser yet, store as a chooser option for when it will be
                // effectively instantiated
                this._chooserInstanceOptions.maxAutoBitrates[type] = bitrate;
            }, 
            /**
   * Returns the set (and active) manual bitrate for the given type.
   * @param {string} supportedBufferTypes
   * @returns {number|undefined}
   */
            _proto.getManualBitrate = function getManualBitrate(type) {
                var chooser = this._choosers[type];
                return chooser ? chooser.manualBitrate$.getValue() : this._chooserInstanceOptions.manualBitrates[type];
            }, 
            /**
   * Returns the set (and active) maximum auto bitrate for the given type.
   * @param {string} supportedBufferTypes
   * @returns {number|undefined}
   */
            _proto.getMaxAutoBitrate = function getMaxAutoBitrate(type) {
                var chooser = this._choosers[type];
                return chooser ? chooser.maxAutoBitrate$.getValue() : this._chooserInstanceOptions.maxAutoBitrates[type];
            }, 
            /**
   * Clean every ressources linked to the ABRManager.
   * The ABRManager is unusable after calling this method.
   */
            _proto.dispose = function dispose() {
                var _this2 = this;
                log.a.debug("ABR: Freeing up ressources"), Object.keys(this._choosers).forEach(function(type) {
                    _this2._choosers[type].dispose();
                }), this._chooserInstanceOptions = defaultChooserOptions, this._choosers = {}, this._dispose$.next(), 
                this._dispose$.complete();
            }, 
            /**
   * If it doesn't exist, create a RepresentationChooser under the
   * _choosers[bufferType] property.
   * @param {string} bufferType
   * @returns {Object}
   */
            _proto._lazilyCreateChooser = function _lazilyCreateChooser(bufferType) {
                return this._choosers[bufferType] || (log.a.debug("ABR: Creating new buffer for ", bufferType), 
                this._choosers[bufferType] = abr_createChooser(bufferType, this._chooserInstanceOptions)), 
                this._choosers[bufferType];
            }, ABRManager;
        }(), utils_id = __webpack_require__(21), utils_languages = __webpack_require__(84), compat = __webpack_require__(8), MediaError = __webpack_require__(28), manifest_representation = 
        /* */
        function() {
            /**
   * @constructor
   * @param {Object} args
   */
            function Representation(args) {
                var nId = Object(utils_id.a)();
                this.id = null == args.id ? nId : args.id, this.bitrate = args.bitrate, this.codec = args.codecs, 
                null != args.height && (this.height = args.height), null != args.width && (this.width = args.width), 
                null != args.mimeType && (this.mimeType = args.mimeType), args.contentProtections && (this.contentProtections = args.contentProtections), 
                args.frameRate && (this.frameRate = args.frameRate), this.index = args.index;
            }
            /**
   * @returns {string}
   */            return Representation.prototype.getMimeTypeString = function getMimeTypeString() {
                return this.mimeType + ';codecs="' + this.codec + '"';
            }, Representation;
        }(), SUPPORTED_ADAPTATIONS_TYPE = [ "audio", "video", "text", "image" ], adaptation_Adaptation = 
        /* */
        function() {
            /**
   * @constructor
   * @param {Object} args
   */
            function Adaptation(args, warning$, representationFilter) {
                var _this = this, nId = Object(utils_id.a)();
                this.id = null == args.id ? nId : "" + args.id, this.type = args.type;
                var hadRepresentations = !!args.representations.length, argsRepresentations = filterSupportedRepresentations(args.type, args.representations);
                if (hadRepresentations && 0 === argsRepresentations.length) {
                    log.a.warn("Incompatible codecs for adaptation", args);
                    var error = new MediaError.a("MANIFEST_INCOMPATIBLE_CODECS_ERROR", null, !1);
                    warning$.next(error);
                }
                null != args.language && (this.language = args.language), null != args.normalizedLanguage && (this.normalizedLanguage = args.normalizedLanguage), 
                null != args.closedCaption && (this.isClosedCaption = args.closedCaption), null != args.audioDescription && (this.isAudioDescription = args.audioDescription), 
                this.representations = argsRepresentations.map(function(representation) {
                    return new manifest_representation(object_assign_default()({
                        rootId: _this.id
                    }, representation));
                }).sort(function(a, b) {
                    return a.bitrate - b.bitrate;
                }).filter(function(representation) {
                    return null == representationFilter || representationFilter(representation, {
                        bufferType: _this.type,
                        language: _this.language,
                        normalizedLanguage: _this.normalizedLanguage,
                        isClosedCaption: _this.isClosedCaption,
                        isAudioDescription: _this.isAudioDescription
                    });
                }), // for manuallyAdded adaptations (not in the manifest)
                this.manuallyAdded = !!args.manuallyAdded;
            }
            /**
   * @returns {Array.<Number>}
   */            var _proto = Adaptation.prototype;
            return _proto.getAvailableBitrates = function getAvailableBitrates() {
                return this.representations.map(function(representation) {
                    return representation.bitrate;
                });
            }, 
            /**
   * @param {Number|string} wantedId
   * @returns {Representation}
   */
            _proto.getRepresentation = function getRepresentation(wantedId) {
                return find_default()(this.representations, function(_ref) {
                    var id = _ref.id;
                    return wantedId === id;
                });
            }, 
            /**
   * @param {Number} bitrate
   * @returns {Array.<Representations>|null}
   */
            _proto.getRepresentationsForBitrate = function getRepresentationsForBitrate(bitrate) {
                return this.representations.filter(function(representation) {
                    return representation.bitrate === bitrate;
                }) || null;
            }, Adaptation;
        }();
        // CONCATENATED MODULE: ./src/core/abr/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * @param {string} adaptationType
 * @param {Array.<Object>} representations
 * @returns {Array.<Object>}
 */
        function filterSupportedRepresentations(adaptationType, representations) {
            return "audio" === adaptationType || "video" === adaptationType ? representations.filter(function(representation) {
                return Object(compat.f)(getCodec(representation));
            }) : representations;
 // TODO for the other types?
                        /**
   * Construct the codec string from given codecs and mimetype.
   * @param {Object} representation
   * @returns {string}
   */
            function getCodec(representation) {
                var _representation$codec = representation.codecs, codecs = void 0 === _representation$codec ? "" : _representation$codec, _representation$mimeT = representation.mimeType;
                return (void 0 === _representation$mimeT ? "" : _representation$mimeT) + ';codecs="' + codecs + '"';
            }
        }
        // EXTERNAL MODULE: ./src/utils/array-includes.ts
                var array_includes = __webpack_require__(13), period_Period = 
        /* */
        function() {
            /**
   * @constructor
   * @param {Object} args
   */
            function Period(args, warning$, representationFilter) {
                if (this.id = args.id, this.adaptations = Object.keys(args.adaptations).reduce(function(acc, type) {
                    if (args.adaptations[type]) {
                        var adaptationsForType = args.adaptations[type];
                        adaptationsForType && (acc[type] = adaptationsForType.filter(function(adaptation) {
                            return !!Object(array_includes.a)(SUPPORTED_ADAPTATIONS_TYPE, adaptation.type) || (log.a.info("not supported adaptation type", adaptation.type), 
                            warning$.next(new MediaError.a("MANIFEST_UNSUPPORTED_ADAPTATION_TYPE", null, !1)), 
                            !1);
                        }).map(function(adaptation) {
                            return new adaptation_Adaptation(adaptation, warning$, representationFilter);
                        }).filter(function(adaptation) {
                            return adaptation.representations.length;
                        }));
                    }
                    return acc;
                }, {}), !(this.adaptations.video && this.adaptations.video.length || this.adaptations.audio && this.adaptations.audio.length)) throw new MediaError.a("MANIFEST_PARSE_ERROR", null, !0);
                this.duration = args.duration, this.start = args.start, null != this.duration && null != this.start && (this.end = this.start + this.duration);
            }
            /**
   * @returns {Array.<Object>}
   */            var _proto = Period.prototype;
            return _proto.getAdaptations = function getAdaptations() {
                var adaptationsByType = this.adaptations;
                if (!adaptationsByType) return [];
                var adaptationsList = [];
                for (var adaptationType in adaptationsByType) if (adaptationsByType.hasOwnProperty(adaptationType)) {
                    var adaptations = adaptationsByType[adaptationType];
                    adaptationsList.push.apply(adaptationsList, adaptations);
                }
                return adaptationsList;
            }, 
            /**
   * @param {string} adaptationType
   * @returns {Array.<Object>}
   */
            _proto.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
                return this.adaptations[adaptationType] || [];
            }, 
            /**
   * @param {number|string} wantedId
   * @returns {Object|undefined}
   */
            _proto.getAdaptation = function getAdaptation(wantedId) {
                return find_default()(this.getAdaptations(), function(_ref) {
                    var id = _ref.id;
                    return wantedId === id;
                });
            }, Period;
        }(), static_StaticRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} infos
   */
            function StaticRepresentationIndex(infos) {
                this._media = infos.media;
            }
            /**
   * Static contents do not have any initialization segments.
   * Just return null.
   * @returns {null}
   */            var _proto = StaticRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return null;
            }, 
            /**
   * Returns the only Segment available here.
   * @returns {Array.<Object>}
   */
            _proto.getSegments = function getSegments() {
                return [ {
                    id: "0",
                    isInit: !1,
                    number: 0,
                    time: 0,
                    duration: Number.MAX_VALUE,
                    timescale: 1,
                    mediaURL: this._media
                } ];
            }, 
            /**
   * Returns first position in index.
   * @returns {undefined}
   */
            _proto.getFirstPosition = function getFirstPosition() {
                /* tslint:enable return-undefined */}, 
            /**
   * Returns last position in index.
   * @returns {undefined}
   */
            _proto.getLastPosition = function getLastPosition() {}, 
            /**
   * Returns false as a static file never need to be refreshed.
   * @returns {Boolean}
   */
            _proto.shouldRefresh = function shouldRefresh() {
                return !1;
            }, 
            /**
   * @returns {Number}
   */
            _proto.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }, _proto._addSegments = function _addSegments() {
                0;
            }, _proto._update = function _update() {
                log.a.warn("Tried to update a static RepresentationIndex");
            }, StaticRepresentationIndex;
        }(), manifest_Manifest = 
        /* */
        function() {
            /**
   * @constructor
   * @param {Object} args
   */
            function Manifest(args, warning$, options) {
                var _options$supplementar = options.supplementaryTextTracks, supplementaryTextTracks = void 0 === _options$supplementar ? [] : _options$supplementar, _options$supplementar2 = options.supplementaryImageTracks, supplementaryImageTracks = void 0 === _options$supplementar2 ? [] : _options$supplementar2, representationFilter = options.representationFilter, nId = Object(utils_id.a)();
                this.id = null == args.id ? nId : "" + args.id, this.transport = args.transportType || "", 
                this.periods = args.periods.map(function(period) {
                    return new period_Period(period, warning$, representationFilter);
                }), 
                /**
     * @deprecated It is here to ensure compatibility with the way the
     * v3.x.x manages adaptations at the Manifest level
     */
                this.adaptations = this.periods[0] && this.periods[0].adaptations || {}, this.minimumTime = args.minimumTime, 
                this.isLive = args.isLive, this.uris = args.uris, this.lifetime = args.lifetime, 
                this.suggestedPresentationDelay = args.suggestedPresentationDelay, this.availabilityStartTime = args.availabilityStartTime, 
                this.presentationLiveGap = args.presentationLiveGap, this.timeShiftBufferDepth = args.timeShiftBufferDepth, 
                // --------- private data
                this._duration = args.duration, supplementaryImageTracks.length && this.addSupplementaryImageAdaptations(supplementaryImageTracks, warning$), 
                supplementaryTextTracks.length && this.addSupplementaryTextAdaptations(supplementaryTextTracks, warning$);
            }
            /**
   * Returns Period encountered at the given time.
   * Returns undefined if there is no Period exactly at the given time.
   * @param {number} time
   * @returns {Period|undefined}
   */            var _proto = Manifest.prototype;
            return _proto.getPeriodForTime = function getPeriodForTime(time) {
                return find_default()(this.periods, function(period) {
                    return time >= period.start && (null == period.end || period.end > time);
                });
            }, 
            /**
   * Returns period coming just after a given period.
   * Returns undefined if not found.
   * @param {Period} period
   * @returns {Period|null}
   */
            _proto.getPeriodAfter = function getPeriodAfter(period) {
                var endOfPeriod = period.end;
                return null == endOfPeriod ? null : find_default()(this.periods, function(_period) {
                    return null == _period.end || endOfPeriod < _period.end;
                }) || null;
            }, 
            /**
   * @returns {Number}
   */
            _proto.getDuration = function getDuration() {
                return this._duration;
            }, 
            /**
   * @returns {string|undefined}
   */
            _proto.getUrl = function getUrl() {
                return this.uris[0];
            }, 
            /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */
            _proto.getAdaptations = function getAdaptations() {
                Object(warnOnce.a)("manifest.getAdaptations() is deprecated. Please use manifest.period[].getAdaptations() instead");
                var firstPeriod = this.periods[0];
                if (!firstPeriod) return [];
                var adaptationsByType = firstPeriod.adaptations, adaptationsList = [];
                for (var adaptationType in adaptationsByType) if (adaptationsByType.hasOwnProperty(adaptationType)) {
                    var adaptations = adaptationsByType[adaptationType];
                    adaptationsList.push.apply(adaptationsList, adaptations);
                }
                return adaptationsList;
            }, 
            /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */
            _proto.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
                Object(warnOnce.a)("manifest.getAdaptationsForType(type) is deprecated. Please use manifest.period[].getAdaptationsForType(type) instead");
                var firstPeriod = this.periods[0];
                return firstPeriod && firstPeriod.adaptations[adaptationType] || [];
            }, 
            /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */
            _proto.getAdaptation = function getAdaptation(wantedId) {
                /* tslint:disable:deprecation */
                return Object(warnOnce.a)("manifest.getAdaptation(id) is deprecated. Please use manifest.period[].getAdaptation(id) instead"), 
                find_default()(this.getAdaptations(), function(_ref) {
                    var id = _ref.id;
                    return wantedId === id;
                });
                /* tslint:enable:deprecation */            }, 
            /**
   * @param {number} delta
   */
            _proto.updateLiveGap = function updateLiveGap(delta) {
                this.isLive && (this.presentationLiveGap ? this.presentationLiveGap += delta : this.presentationLiveGap = delta);
            }, 
            /**
   * Update the current manifest properties
   * @param {Object} Manifest
   */
            _proto.update = function update(newManifest) {
                this._duration = newManifest.getDuration(), this.lifetime = newManifest.lifetime, 
                this.timeShiftBufferDepth = newManifest.timeShiftBufferDepth, this.availabilityStartTime = newManifest.availabilityStartTime, 
                this.suggestedPresentationDelay = newManifest.suggestedPresentationDelay, this.uris = newManifest.uris;
                for (var oldPeriods = this.periods, newPeriods = newManifest.periods, _loop = function _loop(_i) {
                    var oldPeriod = oldPeriods[_i], newPeriod = find_default()(newPeriods, function(a) {
                        return a.id === oldPeriod.id;
                    });
                    if (newPeriod) {
                        oldPeriod.start = newPeriod.start, oldPeriod.end = newPeriod.end, oldPeriod.duration = newPeriod.duration;
                        for (var oldAdaptations = oldPeriod.getAdaptations(), newAdaptations = newPeriod.getAdaptations(), _loop2 = function _loop2(j) {
                            var oldAdaptation = oldAdaptations[j], newAdaptation = find_default()(newAdaptations, function(a) {
                                return a.id === oldAdaptation.id;
                            });
                            if (newAdaptation) for (var oldRepresentations = oldAdaptations[j].representations, newRepresentations = newAdaptation.representations, _loop3 = function _loop3(k) {
                                var oldRepresentation = oldRepresentations[k], newRepresentation = find_default()(newRepresentations, function(representation) {
                                    return representation.id === oldRepresentation.id;
                                });
                                newRepresentation ? oldRepresentations[k].index._update(newRepresentation.index) : 
                                /* tslint:disable:max-line-length */
                                log.a.warn('manifest: representation "' + oldRepresentations[k].id + '" not found when merging.');
                            }, k = 0; k < oldRepresentations.length; k++) _loop3(k); else log.a.warn('manifest: adaptation "' + oldAdaptations[j].id + '" not found when merging.');
                        }, j = 0; j < oldAdaptations.length; j++) _loop2(j);
                    } else log.a.info("Period " + oldPeriod.id + " not found after update. Removing."), 
                    oldPeriods.splice(_i, 1), _i--;
                    i = _i;
                }, i = 0; i < oldPeriods.length; i++) _loop(i);
 // adding - perhaps - new Period[s]
                                if (newPeriods.length > oldPeriods.length) {
                    var lastOldPeriod = oldPeriods[oldPeriods.length - 1];
                    if (lastOldPeriod) for (var _i2 = 0; _i2 < newPeriods.length - 1; _i2++) {
                        var newPeriod = newPeriods[_i2];
                        newPeriod.start > lastOldPeriod.start && (log.a.info("Adding new period " + newPeriod.id), 
                        this.periods.push(newPeriod));
                    } else for (var _i3 = 0; _i3 < newPeriods.length - 1; _i3++) {
                        var _newPeriod = newPeriods[_i3];
                        log.a.info("Adding new period " + _newPeriod.id), this.periods.push(_newPeriod);
                    }
                }
            }, 
            /**
   * Get minimum position currently defined by the Manifest.
   * @returns {number}
   */
            _proto.getMinimumPosition = function getMinimumPosition() {
                return this.getCurrentPositionLimits()[0];
            }, 
            /**
   * Get maximum position currently defined by the Manifest.
   * @returns {number}
   */
            _proto.getMaximumPosition = function getMaximumPosition() {
                if (!this.isLive) return this.getDuration();
                var ast = this.availabilityStartTime || 0, plg = this.presentationLiveGap || 0;
                return Date.now() / 1e3 - ast - plg;
            }, 
            /**
   * Get minimum AND maximum positions currently defined by the manifest.
   * @returns {Array.<number>}
   */
            _proto.getCurrentPositionLimits = function getCurrentPositionLimits() {
                if (!this.isLive) return [ this.minimumTime || 0, this.getDuration() ];
                var ast = this.availabilityStartTime || 0, plg = this.presentationLiveGap || 0, tsbd = this.timeShiftBufferDepth || 0, max = Date.now() / 1e3 - ast - plg;
                return [ Math.min(max, Math.max(null != this.minimumTime ? this.minimumTime : 0, max - tsbd + 5)), max ];
            }, 
            /**
   * Add supplementary image Adaptation(s) to the manifest.
   * @param {Object|Array.<Object>} imageTracks
   */
            _proto.addSupplementaryImageAdaptations = function addSupplementaryImageAdaptations(imageTracks, warning$) {
                var newImageTracks = (Array.isArray(imageTracks) ? imageTracks : [ imageTracks ]).map(function(_ref2) {
                    var mimeType = _ref2.mimeType, url = _ref2.url, adaptationID = "gen-image-ada-" + Object(utils_id.a)(), representationID = "gen-image-rep-" + Object(utils_id.a)();
                    return new adaptation_Adaptation({
                        id: adaptationID,
                        type: "image",
                        manuallyAdded: !0,
                        representations: [ {
                            bitrate: 0,
                            id: representationID,
                            mimeType: mimeType,
                            index: new static_StaticRepresentationIndex({
                                media: url
                            })
                        } ]
                    }, warning$);
                });
                newImageTracks.length && (this.adaptations.image = this.adaptations.image ? this.adaptations.image.concat(newImageTracks) : newImageTracks);
            }, 
            /**
   * Add supplementary text Adaptation(s) to the manifest.
   * @param {Object|Array.<Object>} textTracks
   */
            _proto.addSupplementaryTextAdaptations = function addSupplementaryTextAdaptations(textTracks, warning$) {
                var newTextAdaptations = (Array.isArray(textTracks) ? textTracks : [ textTracks ]).reduce(function(allSubs, _ref3) {
                    var mimeType = _ref3.mimeType, codecs = _ref3.codecs, url = _ref3.url, language = _ref3.language, languages = _ref3.languages, closedCaption = _ref3.closedCaption, langsToMapOn = language ? [ language ] : languages || [];
                    return allSubs.concat(langsToMapOn.map(function(_language) {
                        var adaptationID = "gen-text-ada-" + Object(utils_id.a)(), representationID = "gen-text-rep-" + Object(utils_id.a)();
                        return new adaptation_Adaptation({
                            id: adaptationID,
                            type: "text",
                            language: _language,
                            normalizedLanguage: Object(utils_languages.a)(_language),
                            closedCaption: closedCaption,
                            manuallyAdded: !0,
                            representations: [ {
                                bitrate: 0,
                                id: representationID,
                                mimeType: mimeType,
                                codecs: codecs,
                                index: new static_StaticRepresentationIndex({
                                    media: url
                                })
                            } ]
                        }, warning$);
                    }));
                }, []);
                newTextAdaptations.length && (this.adaptations.text = this.adaptations.text ? this.adaptations.text.concat(newTextAdaptations) : newTextAdaptations);
            }, Manifest;
        }(), Observable = __webpack_require__(9), Subscription = __webpack_require__(15);
        // CONCATENATED MODULE: ./src/manifest/period.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/finalize.js
        /** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */
        function finalize(callback) {
            return function(source) {
                return source.lift(new FinallyOperator(callback));
            };
        }
        var FinallyOperator = /* */ function() {
            function FinallyOperator(callback) {
                this.callback = callback;
            }
            return FinallyOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new finalize_FinallySubscriber(subscriber, this.callback));
            }, FinallyOperator;
        }(), finalize_FinallySubscriber = /* */ function(_super) {
            function FinallySubscriber(destination, callback) {
                var _this = _super.call(this, destination) || this;
                return _this.add(new Subscription.a(callback)), _this;
            }
            return tslib_es6.a(FinallySubscriber, _super), FinallySubscriber;
        }(Subscriber.a), errors = __webpack_require__(17), RequestError = __webpack_require__(82), NetworkError = __webpack_require__(96), OtherError = __webpack_require__(97), castToObservable = __webpack_require__(18), rx_tryCatch = __webpack_require__(50), backoff = __webpack_require__(65);
        // CONCATENATED MODULE: ./src/core/pipelines/backoff.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Called on a pipeline's loader error.
 * Returns whether the loader request should be retried.
 * @param {Error} error
 * @returns {Boolean}
 */
        function shouldRetry(error) {
            return error instanceof RequestError.a && (error.type === constants.c.ERROR_HTTP_CODE ? 500 <= error.status || 404 === error.status : error.type === constants.c.TIMEOUT || error.type === constants.c.ERROR_EVENT);
        }
        /**
 * Returns true if we're pretty sure that the current error is due to the
 * user being offline.
 * @param {Error} error
 * @returns {Boolean}
 */        function isOfflineRequestError(error) {
            return error.type === constants.c.ERROR_EVENT && Object(compat.g)();
        }
        /**
 * Specific exponential backoff algorithm used for segments/manifest
 * downloading.
 *
 * The specificty here in comparaison to a "regular" backoff algorithm is
 * the separation between type of errors:
 *   - "offline" errors
 *   - other xhr errors
 * Both have their own counters which are resetted if the error type changes.
 * @param {Observable} obs$
 * @param {Object} options - Configuration options.
 * @returns {Observable}
 */        
        /* harmony default export */ var pipelines_backoff = function downloadingBackoff(obs$, options) {
            var baseDelay = options.baseDelay, maxDelay = options.maxDelay, maxRetryRegular = options.maxRetryRegular, maxRetryOffline = options.maxRetryOffline, onRetry = options.onRetry, retryCount = 0, ERROR_TYPES_REGULAR = 1, ERROR_TYPES_OFFLINE = 2, lastError = 0;
            return obs$.pipe(Object(catchError.a)(function(error, source) {
                if (!shouldRetry(error)) throw error;
                var currentError = error instanceof RequestError.a && isOfflineRequestError(error) ? ERROR_TYPES_OFFLINE : ERROR_TYPES_REGULAR;
                if (currentError !== lastError && (retryCount = 0, lastError = currentError), ++retryCount > (currentError === ERROR_TYPES_OFFLINE ? maxRetryOffline : maxRetryRegular)) throw error;
                onRetry && onRetry(error, retryCount);
                var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay), fuzzedDelay = Object(backoff.b)(delay);
                return Object(timer.a)(fuzzedDelay).pipe(Object(mergeMap.a)(function() {
                    return source;
                }));
            }));
        }, MAX_BACKOFF_DELAY_BASE = config.a.MAX_BACKOFF_DELAY_BASE, INITIAL_BACKOFF_DELAY_BASE = config.a.INITIAL_BACKOFF_DELAY_BASE;
        // CONCATENATED MODULE: ./src/core/pipelines/create_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * Generate a new error from the infos given.
 * @param {string} code
 * @param {Error} error
 * @param {Boolean} fatal - Whether the error is fatal to the content's
 * playback.
 * @returns {Error}
 */
        function errorSelector(code, error, fatal) {
            return Object(errors.a)(error) ? error : error instanceof RequestError.a ? new NetworkError.a(code, error, fatal) : new OtherError.a(code, error, fatal);
        }
        /**
 * Returns function allowing to download the wanted data through a
 * resolver -> loader pipeline.
 *
 * (The data can be for example: the manifest, audio and video segments, text,
 * images...)
 *
 * The function returned takes the initial data in arguments and returns an
 * Observable which will emit:
 *
 *   - each time a request begins (type "request").
 *     This is not emitted if the value is retrieved from a local js cache.
 *     This one emit the payload as a value.
 *
 *   - as the request progresses (type "progress").
 *
 *   - each time a request ends (type "metrics").
 *     This one contains informations about the metrics of the request.
 *
 *   - each time a minor request error is encountered (type "error").
 *     With the error as a value.
 *
 *   - Lastly, with the fetched data (type "response").
 *
 *
 * Each of these but "error" can be emitted at most one time.
 *
 * This observable will throw if, following the options given, the request and
 * possible retry all failed.
 *
 * This observable will complete after emitting the data.
 *
 * Type parameters:
 *   T: Argument given to the Net's loader
 *   U: ResponseType of the request
 *
 * @param {Object} transportPipeline
 * @param {Object} options
 * @returns {Function}
 */        function createLoader(transportPipeline, options) {
            var cache = options.cache, maxRetry = options.maxRetry, maxRetryOffline = options.maxRetryOffline, loader = transportPipeline.loader, resolver = null != transportPipeline.resolver ? transportPipeline.resolver : of.a.bind(Observable.a), retryErrorSubject = new Subject.a(), backoffOptions = {
                baseDelay: INITIAL_BACKOFF_DELAY_BASE,
                maxDelay: MAX_BACKOFF_DELAY_BASE,
                maxRetryRegular: maxRetry,
                maxRetryOffline: maxRetryOffline,
                onRetry: function onRetry(error) {
                    retryErrorSubject.next(errorSelector("PIPELINE_LOAD_ERROR", error, !1));
                }
            };
            /**
   * Call the transport's resolver - if it exists - with the given data.
   *
   * Throws with the right error if it fails.
   * @param {Object} resolverArgument
   * @returns {Observable}
   */
            function callResolver(resolverArgument) {
                return Object(rx_tryCatch.a)(resolver, resolverArgument).pipe().pipe(Object(catchError.a)(function(error) {
                    throw errorSelector("PIPELINE_RESOLVE_ERROR", error, !0);
                }));
            }
            /**
   * Load wanted data:
   *   - get it from cache if present
   *   - call the transport loader - with an exponential backoff - if not
   *
   * @param {Object} loaderArgument - Input given to the loader
   * @returns {Observable}
   */            function loadData(loaderArgument) {
                /**
     * Call the Pipeline's loader with an exponential Backoff.
     * @returns {Observable}
     */
                function startLoaderWithBackoff() {
                    var request$ = pipelines_backoff(Object(rx_tryCatch.a)(loader, loaderArgument), backoffOptions).pipe(Object(catchError.a)(function(error) {
                        throw errorSelector("PIPELINE_LOAD_ERROR", error, !0);
                    }), Object(tap.a)(function(arg) {
                        "response" === arg.type && cache && cache.add(loaderArgument, arg.value);
                    }));
                    return Object(concat.a)(Object(of.a)({
                        type: "request",
                        value: loaderArgument
                    }), request$);
                }
                var dataFromCache = cache ? cache.get(loaderArgument) : null;
                return null != dataFromCache ? Object(castToObservable.a)(dataFromCache).pipe(Object(map.a)(function(response) {
                    return {
                        type: "cache",
                        value: response
                    };
                }), Object(catchError.a)(startLoaderWithBackoff)) : startLoaderWithBackoff();
            }
            /**
   * Load the corresponding data.
   * @param {Object} pipelineInputData
   * @returns {Observable}
   */            return function startPipeline(pipelineInputData) {
                var pipeline$ = callResolver(pipelineInputData).pipe(Object(mergeMap.a)(function(resolverResponse) {
                    return loadData(resolverResponse).pipe(Object(mergeMap.a)(function(arg) {
                        // "cache": data taken from cache by the pipeline
                        // "data": the data is available but no request has been done
                        // "response": data received through a request
                        switch (arg.type) {
                          case "cache":
                          case "data":
                          case "response":
                            var response$ = Object(of.a)({
                                type: "response",
                                value: object_assign_default()({}, resolverResponse, {
                                    responseData: arg.value.responseData,
                                    sendingTime: "response" === arg.type ? arg.value.sendingTime : void 0,
                                    receivedTime: "response" === arg.type ? arg.value.receivedTime : void 0
                                })
                            }), metrics$ = "response" !== arg.type ? empty.a : Object(of.a)({
                                type: "metrics",
                                value: {
                                    size: arg.value.size,
                                    duration: arg.value.duration
                                }
                            });
                            return Object(concat.a)(response$, metrics$);

                          default:
                            return Object(of.a)(arg);
                        }
                    }));
                }), finalize(function() {
                    retryErrorSubject.complete();
                })), retryError$ = retryErrorSubject.pipe(Object(map.a)(function(error) {
                    return {
                        type: "error",
                        value: error
                    };
                }));
                return Object(merge.a)(pipeline$, retryError$);
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/create_parser.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create a function allowing to parse data from a transport pipeline's
 * parse function and to throw the right error if that function throws.
 *
 * Type parameters:
 *   - T : Parser's arguments
 *   - U ; Parser's response
 * @param {Object} transportPipeline
 * @returns {Function}
 */        function createParser(transportPipeline) {
            var parser = transportPipeline.parser;
            /**
   * Parse the given data and throw a formatted error if that call fails.
   * @param {*} parserArguments
   * @returns {Observable}
   */            return function parse(parserArguments) {
                return parser(parserArguments).pipe(Object(catchError.a)(function(error) {
                    throw Object(errors.a)(error) ? error : new OtherError.a("PIPELINE_PARSING_ERROR", error, !0);
                }));
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/manifest/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create function allowing to easily fetch and parse the manifest from its URL.
 *
 * @example
 * ```js
 * const manifestPipeline = createManifestPipeline(transport, options, warning$);
 * manifestPipeline(manifestURL)
 *  .subscribe(manifest => console.log("Manifest:", manifest));
 * ```
 *
 * @param {Object} transport
 * @param {Subject} warning$
 * @param {Array.<Object>|undefined} supplementaryTextTracks
 * @param {Array.<Object>|undefined} supplementaryImageTrack
 * @returns {Function}
 */        function createManifestPipeline(transport, pipelineOptions, warning$) {
            var loader = createLoader(transport.pipelines.manifest, pipelineOptions), parser = createParser(transport.pipelines.manifest);
            /**
   * Fetch and parse the manifest corresponding to the URL given.
   * @param {string} url - URL of the manifest
   * @returns {Observable}
   */
            return function fetchManifest(url) {
                return loader({
                    url: url
                }).pipe(Object(tap.a)(function(arg) {
                    "error" === arg.type && warning$.next(arg.value);
                }), Object(filter.a)(function(arg) {
                    return "response" === arg.type;
                }), Object(mergeMap.a)(function(_ref) {
                    var value = _ref.value, sendingTime = value.sendingTime;
                    return parser({
                        response: value,
                        url: url
                    }).pipe(Object(map.a)(function(_ref2) {
                        var parsedManifest = _ref2.manifest;
                        return {
                            manifest: new manifest_Manifest(parsedManifest, warning$, transport.options),
                            sendingTime: sendingTime
                        };
                    }));
                }), Object(share.a)());
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/segment/prioritized_segment_fetcher.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This function basically put in relation:
 *   - a SegmentFetcher, which will be used to perform the segment request
 *   - a prioritizer, which will handle the priority of a segment request
 *
 * and returns functions to fetch segments with a given priority.
 * @param {Object} prioritizer
 * @param {Object} fetcher
 * @returns {Object}
 */        function applyPrioritizerToSegmentFetcher(prioritizer, fetcher) {
            return {
                /**
     * Create a Segment request with a given priority.
     * @param {Object} content - content to request
     * @param {Number} priority - priority at which the content should be
     * requested.
     * @returns {Observable}
     */
                createRequest: function createRequest(content, priority) {
                    return void 0 === priority && (priority = 0), prioritizer.create(fetcher(content), priority);
                },
                /**
     * Update the priority of a pending request, created through createRequest.
     * @param {Observable} observable - the corresponding request
     * @param {Number} priority
     */
                updatePriority: function updatePriority(observable, priority) {
                    prioritizer.updatePriority(observable, priority);
                }
            };
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
                var defer = __webpack_require__(134), prioritizer_ObservablePrioritizer = 
        /* */
        function() {
            function ObservablePrioritizer() {
                this._pendingPriority = null, this._numberOfPendingObservables = 0, this._queue = [];
            }
            /**
   * Create a priorized Observable from a base Observable.
   *
   * When subscribed to, this Observable will have its priority compared to
   * all the already-running Observables created from this class.
   * Only if this number is inferior or equal to the priority of the
   * currently-running Observables will it be immediately started.
   * In the opposite case, we will wait for higher-priority Observables to
   * finish before starting it.
   *
   * Note that while this Observable is waiting for its turn, it is possible
   * to update its property through the updatePriority method, by providing
   * the Observable returned by this function and its new priority number.
   *
   * @param {Observable} obs
   * @param {number} priority
   * @returns {Observable}
   */            var _proto = ObservablePrioritizer.prototype;
            return _proto.create = function create(obs, priority) {
                var _this = this, pObs$ = Object(defer.a)(function() {
                    if (null == _this._pendingPriority || _this._pendingPriority >= priority) 
                    // Update the priority and start immediately the Observable
                    return _this._pendingPriority = priority, _this._startObservable(obs);
                    var trigger = new Subject.a();
                    return _this._queue.push({
                        observable: pObs$,
                        priority: priority,
                        trigger: trigger
                    }), trigger.pipe(Object(mergeMap.a)(function() {
                        return _this._startObservable(obs);
                    }));
                });
                return pObs$;
            }, 
            /**
   * Update the priority of an Observable created through the create method.
   *
   * Note that this will only have an effect on Observable which are not yet
   * started.
   * This means it will only have an effect on:
   *   - unsubscribed Observables
   *   - Observables waiting for Observables with an higher priority to
   *     finish
   *
   * @param {Observable} obs
   * @param {number} priority
   */
            _proto.updatePriority = function updatePriority(obs, priority) {
                var index = array_find_index_default()(this._queue, function(elt) {
                    return elt.observable === obs;
                });
                if (!(index < 0)) {
                    var queueElement = this._queue[index];
                    queueElement.priority = priority, (null == this._pendingPriority || this._pendingPriority >= priority) && (this._queue.splice(index, 1), 
                    queueElement.trigger.next(), queueElement.trigger.complete());
                }
            }, _proto._startObservable = function _startObservable(obs) {
                var _this2 = this;
                return this._numberOfPendingObservables++, obs.pipe(finalize(function onObservableFinish() {
                    if (_this2._numberOfPendingObservables--, !(0 < _this2._numberOfPendingObservables) && (_this2._pendingPriority = null, 
                    0 !== _this2._queue.length)) {
                        _this2._pendingPriority = _this2._queue.reduce(function(acc, elt) {
                            return null == acc || acc > elt.priority ? elt.priority : acc;
                        }, null);
                        for (var i = 0; i < _this2._queue.length; i++) {
                            var elt = _this2._queue[i];
                            elt.priority === _this2._pendingPriority && (_this2._queue.splice(i, 1), i--, elt.trigger.next(), 
                            elt.trigger.complete());
                        }
                    }
                }));
            }, ObservablePrioritizer;
        }();
        // CONCATENATED MODULE: ./src/core/pipelines/segment/prioritizer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create Observables which can be priorized between one another.
 *
 * With this class, you can create Observables with linked priority numbers.
 * The lower this number is, the more priority the resulting Observable will
 * have.
 *
 * Such Observable will then basically wait for pending Observables with more
 * priority to finish before "starting".
 *
 * You can also update the priority of an already-created Observable.
 * This will only have an effect if the Observable is currently "waiting" for
 * its turn (started observable won't be canceled if their priority were
 * lowered).
 *
 * ```js
 * const prioritizer = new ObservablePrioritizer();
 *
 * const observable1 = Observable.of(1);
 * const observable2 = Observable.of(2);
 * const observable3 = Observable.of(3);
 * const observable4 = Observable.of(4);
 * const observable5 = Observable.of(5);
 *
 * const pObservable1 = prioritizer.create(observable1, 4);
 * const pObservable2 = prioritizer.create(observable2, 2);
 * const pObservable3 = prioritizer.create(observable3, 1);
 * const pObservable4 = prioritizer.create(observable4, 3);
 * const pObservable5 = prioritizer.create(observable5, 2);
 *
 * // start every Observables at the same time
 * observableMerge(
 *   pObservable1,
 *   pObservable2,
 *   pObservable3,
 *   pObservable4,
 *   pObservable5
 * ).subscribe((i) => {
 *   // To spice things up, update pObservable1 priority to go before
 *   // pObservable4
 *   if (i === 5) { // if pObservable5 is currently emitting
 *     prioritizer.updatePriority(pObservable1, 1);
 *   }
 *   console.log(i);
 * });
 *
 * // Result:
 * // 3
 * // 2
 * // 5
 * // 1
 * // 4
 *
 * // Note: here "1" goes before "4" only because the former's priority has been
 * // updated before the latter was started.
 * // It would be the other way around if not.
 * ```
 *
 * @class ObservablePrioritizer
 */        
        // CONCATENATED MODULE: ./src/core/pipelines/segment/segment_fetcher.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create a function which will fetch segments.
 *
 * This function will:
 *   - only emit the resulting data
 *   - dispatch the other infos through the right subjects.
 *
 * @param {string} bufferType
 * @param {Object} transport
 * @param {Subject} network$ - Subject through which network metrics will be
 * sent, for the ABR.
 * @param {Subject} requests$ - Subject through which requests infos will be
 * sent, for the ABR.
 * @param {Subject} warning$ - Subject through which minor requests error will
 * be sent.
 * @param {Object} options
 * @returns {Function}
 */
        function createSegmentFetcher(bufferType, transport, network$, requests$, warning$, options) {
            var request$, id, segmentLoader = createLoader(transport[bufferType], options), segmentParser = createParser(transport[bufferType]);
            /**
   * Process a pipeline observable to adapt it to the Stream way:
   *   - use the network$ subject for network metrics (bandwitdh mesure)
   *   - use the requests subject for network requests and their progress
   *   - use the warning$ subject for retries' error messages
   *   - only emit the data
   * @param {string} pipelineType
   * @param {Observable} pipeline$
   * @returns {Observable}
   */
            return function fetchSegment(content) {
                return segmentLoader(content).pipe(Object(tap.a)(function(arg) {
                    switch (arg.type) {
                      case "error":
                        warning$.next(object_assign_default()(arg.value, {
                            pipelineType: bufferType
                        }));
                        break;

                      case "metrics":
                        var value = arg.value, size = value.size, duration = value.duration;
                        // unwrapping for TS
                        // format it for ABR Handling
                        null != size && null != duration && network$.next({
                            type: bufferType,
                            value: {
                                size: size,
                                duration: duration
                            }
                        });
                        break;

                      case "request":
                        var _value = arg.value, segment = _value && _value.segment;
 // format it for ABR Handling
                                                if (null != segment && null != segment.duration) {
                            request$ = new Subject.a(), requests$.next(request$);
                            var _duration = segment.duration / segment.timescale, time = segment.time / segment.timescale;
                            id = Object(utils_id.a)(), request$.next({
                                type: bufferType,
                                event: "requestBegin",
                                value: {
                                    duration: _duration,
                                    time: time,
                                    requestTimestamp: performance.now(),
                                    id: id
                                }
                            });
                        }
                        break;

                      case "progress":
                        var _value2 = arg.value;
                        null != _value2.totalSize && _value2.size < _value2.totalSize && null != id && null != request$ && request$.next({
                            type: bufferType,
                            event: "progress",
                            value: {
                                duration: _value2.duration,
                                size: _value2.size,
                                totalSize: _value2.totalSize,
                                timestamp: performance.now(),
                                id: id
                            }
                        });
                    }
                }), Object(filter.a)(function(arg) {
                    return "response" === arg.type;
                }), finalize(function() {
                    null != request$ && (null != id && request$.next({
                        type: bufferType,
                        event: "requestEnd",
                        value: {
                            id: id
                        }
                    }), request$.complete());
                }), Object(map.a)(function(response) {
                    return {
                        /**
         * Parse the loaded data.
         * @param {Object} [init]
         * @returns {Observable}
         */
                        parse: function parse(init) {
                            return segmentParser(object_assign_default()({
                                response: response.value,
                                init: init
                            }, content));
                        }
                    };
                }), Object(share.a)());
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/segment/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Interact with the networking pipelines to download segments and dispatch
 * the related events to the right subjects.
 *
 * @class SegmentPipelinesManager
 *
 * @example
 * ```js
 * const requests$ = new Subject();
 * const metrics$ = new Subject();
 * const warnings$ = new Subject();
 *
 * // 1 - create the manager
 * const segmentPipelinesManager =
 *   new SegmentPipelinesManager(transport, requests$, metrics$, warnings$);
 *
 * // Note:
 * // You can create an ABRManager with the same requests$ and metrics$ subjects.
 * // It will then be informed of when the SegmentPipelinesManager downloads
 * // segments and with which metrics.
 * // The format of those events is kept the same for ease of use.
 * const abrManager = new ABRManager(requests$, metrics$);
 *
 * // 2 - create a new pipeline with its own options
 * const pipeline = segmentPipelinesManager.createPipeline("audio", {
 *   maxRetry: Infinity,
 *   maxRetryOffline: Infinity,
 * });
 *
 * // 3 - load a segment with a given priority
 * pipeline.createRequest(myContent, 1)
 *
 *   // 4 - parse it
 *   .pipe(mergeMap(fetchedSegment => fetchedSegment.parse()))
 *
 *   // 5 - use it
 *   .subscribe((res) => console.log("audio segment downloaded:", res));
 * ```
 */        var segment_SegmentPipelinesManager = 
        /* */
        function() {
            /**
   * @param {Object} transport
   * @param {Subject} requestsInfos$
   * @param {Subject} metrics$
   * @param {Subject} warning
   */
            function SegmentPipelinesManager(transport, requestsInfos$, metrics$, warning) {
                this._transport = transport, this._metrics$ = metrics$, this._requestsInfos$ = requestsInfos$, 
                this._warning$ = warning, this._prioritizer = new prioritizer_ObservablePrioritizer();
            }
            /**
   * Create a segment pipeline, allowing to easily perform segment requests.
   * @param {string} bufferType
   * @param {Object} options
   * @returns {Object}
   */            return SegmentPipelinesManager.prototype.createPipeline = function createPipeline(bufferType, options) {
                var segmentFetcher = createSegmentFetcher(bufferType, this._transport, this._metrics$, this._requestsInfos$, this._warning$, options);
                return applyPrioritizerToSegmentFetcher(this._prioritizer, segmentFetcher);
            }, SegmentPipelinesManager;
        }(), create_eme_manager = __webpack_require__(93), compat_constants = __webpack_require__(24);
        // EXTERNAL MODULE: ./src/core/stream/create_eme_manager.ts
                // CONCATENATED MODULE: ./src/core/stream/create_media_source.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Set the media duration in the mediaSource.
 * @param {MediaSource} mediaSource
 * @param {number} duration
 */
        function setDurationToMediaSource(mediaSource, duration) {
            var newDuration = Infinity === duration ? Number.MAX_VALUE : duration;
            mediaSource.duration !== newDuration && (log.a.info("Stream: Setting duration", newDuration), 
            mediaSource.duration = newDuration);
        }
        /**
 * Dispose of ressources taken by the MediaSource:
 *   - Clear the MediaSource' SourceBuffers
 *   - Clear the mediaElement's src (stop the mediaElement)
 *   - Revoke MediaSource' URL
 * @param {HTMLMediaElement} mediaElement
 * @param {MediaSource|null|undefined} mediaSource
 * @param {string|null|undefined} mediaSourceURL
 */        function resetMediaSource(mediaElement, mediaSource, mediaSourceURL) {
            if (mediaSource && "closed" !== mediaSource.readyState) {
                for (var readyState = mediaSource.readyState, sourceBuffers = mediaSource.sourceBuffers, i = sourceBuffers.length - 1; 0 <= i; i--) {
                    var sourceBuffer = sourceBuffers[i];
                    try {
                        "open" === readyState && (log.a.info("Stream: Removing SourceBuffer from mediaSource", sourceBuffer), 
                        sourceBuffer.abort()), mediaSource.removeSourceBuffer(sourceBuffer);
                    } catch (e) {
                        log.a.warn("Stream: Error while disposing SourceBuffer", e);
                    }
                }
                sourceBuffers.length && log.a.warn("Stream: Not all SourceBuffers could have been removed.");
            }
            if (Object(compat.c)(mediaElement), mediaSourceURL) try {
                log.a.debug("Stream: Revoking previous URL"), URL.revokeObjectURL(mediaSourceURL);
            } catch (e) {
                log.a.warn("Stream: Error while revoking the media source URL", e);
            }
        }
        /**
 * Create, on subscription, a MediaSource instance and attach it to the given
 * mediaElement element's src attribute.
 *
 * Returns an Observable which emits the MediaSource when created and attached
 * to the mediaElement element.
 * This Observable never completes. It can throw if MediaSource is not
 * available in the current environment.
 *
 * On unsubscription, the mediaElement.src is cleaned, MediaSource sourceBuffers
 * and customBuffers are aborted and some minor cleaning is done.
 *
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        function createMediaSource(mediaElement) {
            return Observable.a.create(function(observer) {
                if (!compat_constants.c) throw new MediaError.a("MEDIA_SOURCE_NOT_SUPPORTED", null, !0);
 // make sure the media has been correctly reset
                                resetMediaSource(mediaElement, null, mediaElement.src || null), 
                log.a.info("Stream: Creating MediaSource");
                var mediaSource = new compat_constants.c(), objectURL = URL.createObjectURL(mediaSource);
                return log.a.info("Stream: Attaching MediaSource URL to the media element", objectURL), 
                mediaElement.src = objectURL, observer.next(mediaSource), function() {
                    resetMediaSource(mediaElement, mediaSource, objectURL);
                };
            });
        }
        /**
 * Create and open a new MediaSource object on the given media element.
 * Emit the MediaSource when done.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        function openMediaSource(mediaElement) {
            return createMediaSource(mediaElement).pipe(Object(mergeMap.a)(function(mediaSource) {
                return Object(events.n)(mediaSource).pipe(Object(take.a)(1), Object(mapTo.a)(mediaSource));
            }));
        }
        // EXTERNAL MODULE: ./src/core/stream/events_generators.ts
                var events_generators = __webpack_require__(30), DEFAULT_LIVE_GAP = config.a.DEFAULT_LIVE_GAP;
        // CONCATENATED MODULE: ./src/core/stream/get_initial_time.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * Returns the calculated initial time for the stream described by the given
 * manifest:
 *   1. if a start time is defined by user, calculate starting time from the
 *      manifest informations
 *   2. else if the media is live, use the live edge and suggested delays from
 *      it
 *   3. else returns the minimum time announced in the manifest
 * @param {Manifest} manifest
 * @param {Object} startAt
 * @returns {Number}
 */
        function getInitialTime(manifest, startAt) {
            if (startAt) {
                var _manifest$getCurrentP = manifest.getCurrentPositionLimits(), min = _manifest$getCurrentP[0], max = _manifest$getCurrentP[1];
                if (null != startAt.position) return Math.max(Math.min(startAt.position, max), min);
                if (null != startAt.wallClockTime) {
                    var position = manifest.isLive ? startAt.wallClockTime - (manifest.availabilityStartTime || 0) : startAt.wallClockTime;
                    return Math.max(Math.min(position, max), min);
                }
                if (null != startAt.fromFirstPosition) {
                    var fromFirstPosition = startAt.fromFirstPosition;
                    return fromFirstPosition <= 0 ? min : Math.min(min + fromFirstPosition, max);
                }
                if (null != startAt.fromLastPosition) {
                    var fromLastPosition = startAt.fromLastPosition;
                    return 0 <= fromLastPosition ? max : Math.max(min, max + fromLastPosition);
                }
                if (null != startAt.percentage) {
                    var percentage = startAt.percentage;
                    return 100 < percentage ? max : percentage < 0 ? min : min + (max - min) * (+percentage / 100);
                }
            }
            if (manifest.isLive) {
                var sgp = manifest.suggestedPresentationDelay;
                return manifest.getMaximumPosition() - (null == sgp ? DEFAULT_LIVE_GAP : sgp);
            }
            return manifest.getMinimumPosition();
        }
        // EXTERNAL MODULE: ./src/core/stream/media_error_manager.ts
                var media_error_manager = __webpack_require__(94), ignoreElements = __webpack_require__(144), OuterSubscriber = __webpack_require__(23), InnerSubscriber = __webpack_require__(37), subscribeToResult = __webpack_require__(22), from = __webpack_require__(35);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
        function exhaustMap(project, resultSelector) {
            return resultSelector ? function(source) {
                return source.pipe(exhaustMap(function(a, i) {
                    return Object(from.a)(project(a, i)).pipe(Object(map.a)(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }));
            } : function(source) {
                return source.lift(new ExhauseMapOperator(project));
            };
        }
        var SourceBufferAction, ExhauseMapOperator = /* */ function() {
            function ExhauseMapOperator(project) {
                this.project = project;
            }
            return ExhauseMapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new exhaustMap_ExhaustMapSubscriber(subscriber, this.project));
            }, ExhauseMapOperator;
        }(), exhaustMap_ExhaustMapSubscriber = /* */ function(_super) {
            function ExhaustMapSubscriber(destination, project) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.hasSubscription = !1, _this.hasCompleted = !1, 
                _this.index = 0, _this;
            }
            return tslib_es6.a(ExhaustMapSubscriber, _super), ExhaustMapSubscriber.prototype._next = function(value) {
                this.hasSubscription || this.tryNext(value);
            }, ExhaustMapSubscriber.prototype.tryNext = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.hasSubscription = !0, this._innerSub(result, value, index);
            }, ExhaustMapSubscriber.prototype._innerSub = function(result, value, index) {
                var innerSubscriber = new InnerSubscriber.a(this, void 0, void 0);
                this.destination.add(innerSubscriber), Object(subscribeToResult.a)(this, result, value, index, innerSubscriber);
            }, ExhaustMapSubscriber.prototype._complete = function() {
                this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe();
            }, ExhaustMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, ExhaustMapSubscriber.prototype.notifyError = function(err) {
                this.destination.error(err);
            }, ExhaustMapSubscriber.prototype.notifyComplete = function(innerSub) {
                this.destination.remove(innerSub), this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
            }, ExhaustMapSubscriber;
        }(OuterSubscriber.a), initialization_segment_cache = 
        /* */
        function() {
            function InitializationSegmentCache() {
                this._cache = new WeakMap();
            }
            /**
   * @param {Object} obj
   * @param {*} response
   */            var _proto = InitializationSegmentCache.prototype;
            return _proto.add = function add(_ref, response) {
                var representation = _ref.representation;
                _ref.segment.isInit && this._cache.set(representation, response);
            }, 
            /**
   * @param {Object} obj
   * @returns {*} response
   */
            _proto.get = function get(_ref2) {
                var representation = _ref2.representation;
                if (_ref2.segment.isInit) {
                    var value = this._cache.get(representation);
                    if (null != value) return value;
                }
                return null;
            }, InitializationSegmentCache;
        }(), sorted_list_SortedList = 
        /* */
        function() {
            /**
   * @param {Function} sortingFunction
   */
            function SortedList(sortingFunction) {
                this._array = [], this._sortingFn = sortingFunction;
            }
            /**
   * Returns the nth element. Throws if the index does not exist.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @throws Error - Throws if the given index is negative or superior to the
   * array's length.
   * @param {number} index
   * @returns {*}
   */            var _proto = SortedList.prototype;
            return _proto.get = function get(index) {
                if (index < 0 || index >= this._array.length) throw new Error("Invalid index.");
                return this._array[index];
            }, 
            /**
   * Find the first element corresponding to the given predicate.
   *
   * /!\ The returned element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @param {Function} fn
   * @returns {*}
   */
            _proto.find = function find(fn) {
                return find_default()(this._array, fn);
            }, 
            /**
   * Returns the index of the given element in the list.
   * -1 if not found.
   * @param {*} element
   * @returns {number}
   */
            _proto.indexOf = function indexOf(element) {
                return this._array.indexOf(element);
            }, 
            /**
   * Returns true if the List contains the given element.
   * @param {*} element
   * @returns {Boolean}
   */
            _proto.has = function has(element) {
                return Object(array_includes.a)(this._array, element);
            }, 
            /**
   * Returns the current length of the list.
   * @returns {number}
   */
            _proto.length = function length() {
                return this._array.length;
            }, 
            /**
   * Add a new element to the List at the right place for the List to stay
   * sorted.
   *
   * /!\ The added Element will share the same reference than the given
   * argument, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @param {...*} elements
   */
            _proto.add = function add() {
                for (var _len = arguments.length, elements = new Array(_len), _key = 0; _key < _len; _key++) elements[_key] = arguments[_key];
                elements.sort(this._sortingFn);
                for (var j = 0, i = 0; i < elements.length; i++) {
                    for (var element = elements[i], inserted = !1; !inserted && j < this._array.length; ) this._sortingFn(element, this._array[j]) < 0 ? (this._array.splice(j, 0, element), 
                    inserted = !0) : j++;
                    inserted || this._array.push(element);
                }
            }, 
            /**
   * Remove the first occurence of the given element.
   * Returns the index of the removed element. Undefined if not found.
   * @returns {number|undefined}
   */
            _proto.removeElement = function removeElement(element) {
                var indexOf = this._array.indexOf(element);
                if (0 <= indexOf) return this._array.splice(indexOf, 1), indexOf;
            }, 
            /**
   * Returns the first element.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @returns {*}
   */
            _proto.head = function head() {
                return this._array[0];
            }, 
            /**
   * Returns the last element.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @returns {*}
   */
            _proto.last = function last() {
                return this._array[this._array.length - 1];
            }, 
            /**
   * Remove the first element.
   * Returns the element removed or undefined if no element were removed.
   * @returns {*}
   */
            _proto.shift = function shift() {
                return this._array.shift();
            }, 
            /**
   * Remove the last element.
   * Returns the element removed or undefined if no element were removed.
   * @returns {*}
   */
            _proto.pop = function pop() {
                return this._array.pop();
            }, 
            /**
   * Returns true if the wrapped Array is well-sorted.
   *
   * You might want to call this function to know if a mutation you've done
   * yourself impacted the order of elements.
   * You can then call the forceSort function to sort the list manually.
   *
   * @example
   * ```js
   * const sortedList = new SortedList((a, b) => a.start - b.start);
   * const element1 = { start: 20 };
   * const element2 = { start: 10 };
   *
   * sortedList.add(element1, element2);
   * console.log(sortedList.unwrap()); // -> [{ start: 10 }, { start : 20 }]
   * console.log(sortedList.checkSort()); // -> true
   *
   * element2.start = 5; // Mutation impacting the order of elements
   * console.log(sortedList.unwrap()); // -> [{ start: 10 }, { start : 5 }]
   * console.log(sortedList.checkSort()); // -> false
   *
   * sortedList.forceSort();
   * console.log(sortedList.unwrap()); // -> [{ start: 5 }, { start : 10 }]
   * console.log(sortedList.checkSort()); // -> true
   * ```
   * @returns {Boolean}
   */
            _proto.checkSort = function checkSort() {
                for (var i = 0; i < this._array.length - 1; i++) if (0 < this._sortingFn(this._array[i], this._array[i + 1])) return !1;
                return !0;
            }, 
            /**
   * Force the array to be sorted.
   *
   * You might want to call this function when you're unsure that a mutation
   * you've done yourself impacted the order of the elements in the list.
   */
            _proto.forceSort = function forceSort() {
                this._array.sort(this._sortingFn);
            }, SortedList;
        }(), WeakMapMemory = 
        /* */
        function() {
            /**
   * @param {Function}
   */
            function WeakMapMemory(fn) {
                this._weakMap = new WeakMap(), this._fn = fn;
            }
            /**
   * @param {Object} obj
   * @returns {*}
   */            var _proto = WeakMapMemory.prototype;
            return _proto.get = function get(obj) {
                var fromMemory = this._weakMap.get(obj);
                if (void 0 !== fromMemory) return fromMemory;
                var newElement = this._fn(obj);
                return this._weakMap.set(obj, newElement), newElement;
            }, 
            /**
   * @param {Object} obj
   */
            _proto.destroy = function destroy(obj) {
                this._weakMap.delete(obj);
            }, WeakMapMemory;
        }(), concatAll = __webpack_require__(110);
        // CONCATENATED MODULE: ./src/core/source_buffers/garbage_collector.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Perform cleaning of the buffer according to the values set by the user
 * at each clock tick and each times the maxBufferBehind/maxBufferAhead values
 * change.
 *
 * @param {Object} opt
 * @returns {Observable}
 */
        function BufferGarbageCollector(_ref) {
            var queuedSourceBuffer = _ref.queuedSourceBuffer, clock$ = _ref.clock$, maxBufferBehind$ = _ref.maxBufferBehind$, maxBufferAhead$ = _ref.maxBufferAhead$;
            return Object(combineLatest.a)(clock$, maxBufferBehind$, maxBufferAhead$).pipe(Object(mergeMap.a)(function(_ref2) {
                var currentTime = _ref2[0], maxBufferBehind = _ref2[1], maxBufferAhead = _ref2[2];
                return clearBuffer(queuedSourceBuffer, currentTime, maxBufferBehind, maxBufferAhead);
            }));
        }
        /**
 * Remove buffer from the browser's memory based on the user's
 * maxBufferAhead / maxBufferBehind settings.
 *
 * Normally, the browser garbage-collect automatically old-added chunks of
 * buffer date when memory is scarce. However, you might want to control
 * the size of memory allocated. This function takes the current position
 * and a "depth" behind and ahead wanted for the buffer, in seconds.
 *
 * Anything older than the depth will be removed from the buffer.
 * @param {QueuedSourceBuffer} qSourceBuffer
 * @param {Number} position - The current position
 * @param {Number} maxBufferBehind
 * @param {Number} maxBufferAhead
 * @returns {Observable}
 */        function clearBuffer(qSourceBuffer, position, maxBufferBehind, maxBufferAhead) {
            if (!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead)) return empty.a;
            var cleanedupRanges = [], _getInnerAndOuterTime = Object(utils_ranges.b)(qSourceBuffer.getBuffered(), position), innerRange = _getInnerAndOuterTime.innerRange, outerRanges = _getInnerAndOuterTime.outerRanges;
            return function collectBufferBehind() {
                if (isFinite(maxBufferBehind)) {
                    // begin from the oldest
                    for (var i = 0; i < outerRanges.length; i++) {
                        var outerRange = outerRanges[i];
                        position - maxBufferBehind >= outerRange.end ? cleanedupRanges.push(outerRange) : position >= outerRange.end && position - maxBufferBehind > outerRange.start && position - maxBufferBehind < outerRange.end && cleanedupRanges.push({
                            start: outerRange.start,
                            end: position - maxBufferBehind
                        });
                    }
                    innerRange && position - maxBufferBehind > innerRange.start && cleanedupRanges.push({
                        start: innerRange.start,
                        end: position - maxBufferBehind
                    });
                }
            }(), function collectBufferAhead() {
                if (isFinite(maxBufferAhead)) {
                    // begin from the oldest
                    for (var i = 0; i < outerRanges.length; i++) {
                        var outerRange = outerRanges[i];
                        position + maxBufferAhead <= outerRange.start ? cleanedupRanges.push(outerRange) : position <= outerRange.start && position + maxBufferAhead < outerRange.end && position + maxBufferAhead > outerRange.start && cleanedupRanges.push({
                            start: position + maxBufferAhead,
                            end: outerRange.end
                        });
                    }
                    innerRange && position + maxBufferAhead < innerRange.end && cleanedupRanges.push({
                        start: position + maxBufferAhead,
                        end: innerRange.end
                    });
                }
            }(), Object(from.a)(cleanedupRanges.map(function(range) {
                return log.a.debug("GC: cleaning range from source buffer", range), qSourceBuffer.removeBuffer(range.start, range.end);
            })).pipe(Object(concatAll.a)(), Object(ignoreElements.a)());
        }
        // CONCATENATED MODULE: ./src/core/source_buffers/queued_source_buffer.ts
                function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function _createClass(Constructor, protoProps, staticProps) {
            return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
            Constructor;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        !function(SourceBufferAction) {
            SourceBufferAction[SourceBufferAction.Append = 0] = "Append", SourceBufferAction[SourceBufferAction.Remove = 1] = "Remove";
        }(SourceBufferAction || (SourceBufferAction = {}));
        /**
 * Wrap a SourceBuffer and append/remove segments in it in a queue.
 *
 * Wait for the previous buffer action to be finished (updateend event) to
 * perform the next in the queue.
 *
 * To work correctly, only a single QueuedSourceBuffer per SourceBuffer should
 * be created.
 *
 * @class QueuedSourceBuffer
 */
        var queued_source_buffer_QueuedSourceBuffer = 
        /* */
        function() {
            /**
   * @constructor
   * @param {SourceBuffer} sourceBuffer
   */
            function QueuedSourceBuffer(bufferType, codec, sourceBuffer) {
                this.bufferType = bufferType, this._sourceBuffer = sourceBuffer, this._queue = [], 
                this._currentOrder = null, this._lastInitSegment = null, this._currentCodec = codec, 
                this.__onError = this._onError.bind(this), this.__onUpdateEnd = this._onUpdateEnd.bind(this), 
                this._sourceBuffer.addEventListener("error", this.__onError), this._sourceBuffer.addEventListener("updateend", this.__onUpdateEnd);
            }
            /**
   * Public access to the SourceBuffer's current codec.
   * @returns {string}
   */            var _proto = QueuedSourceBuffer.prototype;
            /**
   * Append media segment to the attached SourceBuffer, in a FIFO queue.
   *
   * Depending on the type of data appended, this might need an associated
   * initialization segment.
   *
   * Such initialization segment will be pushed in the SourceBuffer if the
   * last segment pushed was associated to another initialization segment.
   * This detection is entirely reference-based so make sure that the same
   * initSegment argument given share the same reference.
   *
   * You can deactivate the usage of initialization segment by setting the
   * infos.initSegment argument to null.
   *
   * You can also only push an initialization segment by setting the
   * infos.segment argument to null.
   *
   * @param {string} codec
   * @param {Object} infos
   * @returns {Observable}
   */            return _proto.appendBuffer = function appendBuffer(infos) {
                return this._addToQueue({
                    type: SourceBufferAction.Append,
                    value: infos
                });
            }, 
            /**
   * Remove data from the attached SourceBuffer, in a FIFO queue.
   * @param {number} start - start position, in seconds
   * @param {number} end - end position, in seconds
   * @returns {Observable}
   */
            _proto.removeBuffer = function removeBuffer(start, end) {
                return this._addToQueue({
                    type: SourceBufferAction.Remove,
                    value: {
                        start: start,
                        end: end
                    }
                });
            }, 
            /**
   * Returns the currently buffered data, in a TimeRanges object.
   * @returns {TimeRanges}
   */
            _proto.getBuffered = function getBuffered() {
                return this._sourceBuffer.buffered;
            }, 
            /**
   * Dispose of the resources used by this QueuedSourceBuffer.
   *
   * /!\ You won't be able to use the QueuedSourceBuffer after calling this
   * function.
   * @private
   */
            _proto.dispose = function dispose() {
                for (this._sourceBuffer.removeEventListener("error", this.__onError), this._sourceBuffer.removeEventListener("updateend", this.__onUpdateEnd), 
                null != this._currentOrder && (this._currentOrder.subject.complete(), this._currentOrder = null); this._queue.length; ) {
                    var nextElement = this._queue.shift();
                    null != nextElement && nextElement.subject.complete();
                }
            }, 
            /**
   * Abort the linked SourceBuffer.
   *
   * /!\ You won't be able to use the QueuedSourceBuffer after calling this
   * function.
   * @private
   */
            _proto.abort = function abort() {
                this._sourceBuffer.abort();
            }, 
            /**
   * Callback used for the 'updateend' event, as a segment has been added/removed.
   * @private
   */
            _proto._onUpdateEnd = function _onUpdateEnd() {
                this._flush();
            }, 
            /**
   * Callback used for the 'error' event from the SourceBuffer.
   * @private
   * @param {Event} error
   */
            _proto._onError = function _onError(error) {
                // initialize init segment as a security
                (this._lastInitSegment = null) != this._currentOrder && this._currentOrder.subject.error(error);
            }, 
            /**
   * When the returned observable is subscribed:
   *   1. Add your order to the queue.
   *   2. Begin the queue if not pending.
   *
   * Cancel queued order on unsubscription.
   * @private
   * @param {Object} order
   * @returns {Observable}
   */
            _proto._addToQueue = function _addToQueue(order) {
                var _this = this;
                return Observable.a.create(function(obs) {
                    var queueItem, shouldRestartQueue = 0 === _this._queue.length && null == _this._currentOrder, subject = new Subject.a();
                    if (order.type === SourceBufferAction.Append) {
                        var _order$value = order.value, segment = _order$value.segment, initSegment = _order$value.initSegment, timestampOffset = _order$value.timestampOffset, codec = _order$value.codec;
                        if (null === initSegment && null === segment) return log.a.warn("QSB: no segment to append.", _this.bufferType), 
                        obs.next(null), void obs.complete();
                        queueItem = {
                            type: SourceBufferAction.Append,
                            value: {
                                initSegment: initSegment,
                                segment: segment,
                                timestampOffset: timestampOffset,
                                codec: codec
                            },
                            subject: subject
                        };
                    } else {
                        if (order.type !== SourceBufferAction.Remove) throw new Error("QSB: unrecognized order");
                        queueItem = {
                            type: SourceBufferAction.Remove,
                            value: order.value,
                            subject: subject
                        };
                    }
                    _this._queue.push(queueItem);
                    var subscription = subject.subscribe(obs);
                    return shouldRestartQueue && _this._flush(), function() {
                        subscription.unsubscribe();
                        var index = _this._queue.indexOf(queueItem);
                        0 <= index && _this._queue.splice(index, 1);
                    };
                });
            }, 
            /**
   * Perform next task if one.
   * @private
   */
            _proto._flush = function _flush() {
                if (!this._sourceBuffer.updating) {
                    if (null == this._currentOrder) {
                        if (0 === this._queue.length) return;
 // TODO TypeScrypt do not get the previous length check? Find solution /
                        // open issue
                                                var newQueueItem = this._queue.shift(), tasks = [];
                        newQueueItem.type === SourceBufferAction.Append ? (null !== newQueueItem.value.initSegment ? tasks.push({
                            type: SourceBufferAction.Append,
                            value: {
                                isInit: !0,
                                segment: newQueueItem.value.initSegment,
                                codec: newQueueItem.value.codec,
                                timestampOffset: newQueueItem.value.timestampOffset
                            }
                        }) : null === newQueueItem.value.segment && (newQueueItem.subject.next(), newQueueItem.subject.complete()), 
                        null !== newQueueItem.value.segment && tasks.push({
                            type: SourceBufferAction.Append,
                            value: {
                                segment: newQueueItem.value.segment,
                                isInit: !1,
                                codec: newQueueItem.value.codec,
                                timestampOffset: newQueueItem.value.timestampOffset
                            }
                        })) : tasks.push({
                            type: SourceBufferAction.Remove,
                            value: newQueueItem.value
                        }), this._currentOrder = {
                            tasks: tasks,
                            subject: newQueueItem.subject
                        };
                    }
                    var task = this._currentOrder.tasks.shift();
                    if (null == task) {
                        var subject = this._currentOrder.subject;
                        return this._currentOrder = null, subject.next(), subject.complete(), void (0 < this._queue.length && this._flush());
                    }
                    try {
                        switch (task.type) {
                          case SourceBufferAction.Append:
                            var _task$value = task.value, segment = _task$value.segment, isInit = _task$value.isInit, _task$value$timestamp = _task$value.timestampOffset, timestampOffset = void 0 === _task$value$timestamp ? 0 : _task$value$timestamp, codec = _task$value.codec;
                            if (isInit && this._lastInitSegment === segment) // nothing to do
                            return void this._flush();
                            if (this._currentCodec !== codec) log.a.debug("QSB: updating codec"), Object(compat.o)(this._sourceBuffer, codec) ? this._currentCodec = codec : log.a.warn("QSB: could not update codec", codec, this._currentCodec);
                            if (this._sourceBuffer.timestampOffset !== timestampOffset) {
                                var newTimestampOffset = timestampOffset || 0;
                                log.a.debug("QSB: updating timestampOffset", this.bufferType, this._sourceBuffer.timestampOffset, newTimestampOffset), 
                                this._sourceBuffer.timestampOffset = newTimestampOffset;
                            }
                            log.a.debug("QSB: pushing new data to source buffer", this.bufferType), isInit && (this._lastInitSegment = segment), 
                            this._sourceBuffer.appendBuffer(segment);
                            break;

                          case SourceBufferAction.Remove:
                            var _task$value2 = task.value, start = _task$value2.start, end = _task$value2.end;
                            log.a.debug("QSB: removing data from source buffer", this.bufferType, start, end), 
                            this._sourceBuffer.remove(start, end);
                        }
                    } catch (e) {
                        this._onError(e);
                    }
                }
            }, _createClass(QueuedSourceBuffer, [ {
                key: "codec",
                get: function get() {
                    return this._currentCodec;
                }
            } ]), QueuedSourceBuffer;
        }(), POSSIBLE_BUFFER_TYPES = [ "audio", "video", "text", "image" ];
        // CONCATENATED MODULE: ./src/core/source_buffers/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * Get all currently available buffer types.
 * /!\ This list can evolve at runtime depending on feature switching.
 * @returns {Array.<string>}
 */
        function getBufferTypes() {
            var bufferTypes = [ "audio", "video" ];
            return null == features.a.nativeTextTracksBuffer && null == features.a.htmlTextTracksBuffer || bufferTypes.push("text"), 
            null != features.a.imageBuffer && bufferTypes.push("image"), bufferTypes;
        }
        /**
 * Allows to easily create and dispose SourceBuffers.
 *
 * Only one source buffer per type is allowed at the same time:
 *
 *   - source buffers for native types (which depends on the native
 *     SourceBuffer implementation), are reused if one is re-created.
 *
 *   - source buffers for custom types are aborted each time a new one of the
 *     same type is created.
 *
 * The returned SourceBuffer is actually a QueuedSourceBuffer instance which
 * wrap a SourceBuffer implementation to queue all its actions.
 *
 * @class SourceBufferManager
 */        var source_buffers_SourceBufferManager = 
        /* */
        function() {
            /**
   * @param {HTMLMediaElement} mediaElement
   * @param {MediaSource} mediaSource
   * @constructor
   */
            function SourceBufferManager(mediaElement, mediaSource) {
                this._mediaElement = mediaElement, this._mediaSource = mediaSource, this._initializedSourceBuffers = {};
            }
            /**
   * Returns the created QueuedSourceBuffer for the given type.
   * Returns null if no QueuedSourceBuffer were created for the given type.
   *
   * @param {string} bufferType
   * @returns {QueuedSourceBuffer|null}
   */            
            /**
   * Returns true if the source buffer is "native" (has to be attached to the
   * mediaSource at the beginning of the stream.
   * @static
   * @param {string} bufferType
   * @returns {Boolean}
   */
            SourceBufferManager.isNative = function isNative(bufferType) {
                return shouldHaveNativeSourceBuffer(bufferType);
            };
            var _proto = SourceBufferManager.prototype;
            return _proto.get = function get(bufferType) {
                return this._initializedSourceBuffers[bufferType] || null;
            }, 
            /**
   * Creates a new QueuedSourceBuffer for the given buffer type.
   * Reuse an already created one if a QueuedSourceBuffer for the given type
   * already exists.
   * @param {string} bufferType
   * @param {string} codec
   * @param {Object|undefined} options
   * @returns {QueuedSourceBuffer}
   */
            _proto.createSourceBuffer = function createSourceBuffer(bufferType, codec, options) {
                void 0 === options && (options = {});
                var memorizedSourceBuffer = this._initializedSourceBuffers[bufferType];
                if (shouldHaveNativeSourceBuffer(bufferType)) {
                    if (memorizedSourceBuffer) return memorizedSourceBuffer.codec !== codec ? log.a.warn("SB: Reusing native SourceBuffer with codec", memorizedSourceBuffer.codec, "for codec", codec) : log.a.info("SB: Reusing native SourceBuffer with codec", codec), 
                    memorizedSourceBuffer;
                    log.a.info("SB: Adding native SourceBuffer with codec", codec);
                    var nativeSourceBuffer = createNativeQueuedSourceBuffer(bufferType, this._mediaSource, codec);
                    return this._initializedSourceBuffers[bufferType] = nativeSourceBuffer;
                }
                if (memorizedSourceBuffer) return log.a.info("SB: Reusing a previous custom SourceBuffer for the type", bufferType), 
                memorizedSourceBuffer;
                if ("text" === bufferType) {
                    var sourceBuffer;
                    if (log.a.info("SB: Creating a new text SourceBuffer with codec", codec), "html" === options.textTrackMode) {
                        if (null == features.a.htmlTextTracksBuffer) throw new Error("HTML Text track feature not activated");
                        sourceBuffer = new features.a.htmlTextTracksBuffer(this._mediaElement, options.textTrackElement);
                    } else {
                        if (null == features.a.nativeTextTracksBuffer) throw new Error("Native Text track feature not activated");
                        sourceBuffer = new features.a.nativeTextTracksBuffer(this._mediaElement, !!options.hideNativeSubtitle);
                    }
                    var queuedSourceBuffer = new queued_source_buffer_QueuedSourceBuffer("text", codec, sourceBuffer);
                    return this._initializedSourceBuffers.text = queuedSourceBuffer;
                }
                if ("image" !== bufferType) throw log.a.error("SB: Unknown buffer type:", bufferType), 
                new MediaError.a("BUFFER_TYPE_UNKNOWN", null, !0);
                if (null == features.a.imageBuffer) throw new Error("Image buffer feature not activated");
                log.a.info("SB: Creating a new image SourceBuffer with codec", codec);
                var _sourceBuffer = new features.a.imageBuffer(), _queuedSourceBuffer = new queued_source_buffer_QueuedSourceBuffer("image", codec, _sourceBuffer);
                return this._initializedSourceBuffers.image = _queuedSourceBuffer;
            }, 
            /**
   * Dispose of the active SourceBuffer for the given type.
   * @param {string} bufferType
   */
            _proto.disposeSourceBuffer = function disposeSourceBuffer(bufferType) {
                var memorizedSourceBuffer = this._initializedSourceBuffers[bufferType];
                if (null != memorizedSourceBuffer) {
                    if (log.a.info("SB: Aborting source buffer", bufferType), memorizedSourceBuffer.dispose(), 
                    !shouldHaveNativeSourceBuffer(bufferType) || "open" === this._mediaSource.readyState) try {
                        memorizedSourceBuffer.abort();
                    } catch (e) {
                        log.a.warn("SB: Failed to abort a " + bufferType + " SourceBuffer:", e);
                    }
                    delete this._initializedSourceBuffers[bufferType];
                } else log.a.warn("SB: Trying to dispose a SourceBuffer that does not exist");
            }, 
            /**
   * Dispose of all QueuedSourceBuffer created on this SourceBufferManager.
   */
            _proto.disposeAll = function disposeAll() {
                var _this = this;
                POSSIBLE_BUFFER_TYPES.forEach(function(bufferType) {
                    null != _this.get(bufferType) && _this.disposeSourceBuffer(bufferType);
                });
            }, SourceBufferManager;
        }();
        /**
 * Adds a SourceBuffer to the MediaSource.
 * @param {MediaSource} mediaSource
 * @param {string} codec
 * @returns {SourceBuffer}
 */        function createNativeQueuedSourceBuffer(bufferType, mediaSource, codec) {
            var sourceBuffer = mediaSource.addSourceBuffer(codec);
            return new queued_source_buffer_QueuedSourceBuffer(bufferType, codec, sourceBuffer);
        }
        /**
 * Returns true if the given buffeType is a native buffer, false otherwise.
 * "Native" source buffers are directly added to the MediaSource.
 * @param {string} bufferType
 * @returns {Boolean}
 */        function shouldHaveNativeSourceBuffer(bufferType) {
            return "audio" === bufferType || "video" === bufferType;
        }
        // CONCATENATED MODULE: ./src/core/buffer/active_period_emitter.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file helps to keep track of the currently active Periods.
 * That is, Periods for which at least a single Buffer is currently active.
 *
 * It also keep track of the currently active period:
 * The first chronological period for which all types of buffers are active.
 */
        /**
 * Emit the active Period each times it changes.
 *
 * The active Period is the first Period (in chronological order) which has
 * a PeriodBuffer for every defined BUFFER_TYPES.
 *
 * Emit null if no Period has PeriodBuffers for all types.
 *
 * @example
 * For 4 BUFFER_TYPES: "AUDIO", "VIDEO", "TEXT" and "IMAGE":
 * ```
 *                     +-------------+
 *         Period 1    | Period 2    | Period 3
 * AUDIO   |=========| | |===      | |
 * VIDEO               | |=====    | |
 * TEXT    |(NO TEXT)| | |(NO TEXT)| | |====    |
 * IMAGE   |=========| | |=        | |
 *                     +-------------+
 *
 * The active Period here is Period 2 as Period 1 has no video PeriodBuffer.
 *
 * If we are missing a or multiple PeriodBuffers in the first chronological
 * Period, like that is the case here, it generally means that we are
 * currently switching between Periods.
 *
 * For here we are surely switching from Period 1 to Period 2 beginning by the
 * video PeriodBuffer. As every PeriodBuffer is ready for Period 2, we can
 * already inform that it is the current Period.
 * ```
 *
 * @param {Array.<string>} bufferTypes - Every buffer types in the content.
 * @param {Observable} addPeriodBuffer$ - Emit PeriodBuffer informations when
 * one is added.
 * @param {Observable} removePeriodBuffer$ - Emit PeriodBuffer informations when
 * one is removed.
 * @returns {Observable}
 */        function ActivePeriodEmitter(bufferTypes, addPeriodBuffer$, removePeriodBuffer$) {
            var periodsList = new sorted_list_SortedList(function(a, b) {
                return a.period.start - b.period.start;
            }), onItemAdd$ = addPeriodBuffer$.pipe(Object(tap.a)(function(_ref) {
                var period = _ref.period, type = _ref.type, periodItem = periodsList.find(function(p) {
                    return p.period === period;
                });
                // add or update the periodItem
                                periodItem || (periodItem = {
                    period: period,
                    buffers: new Set()
                }, periodsList.add(periodItem)), periodItem.buffers.has(type) && log.a.warn("ActivePeriodEmitter: Buffer type " + type + " already added to the period"), 
                periodItem.buffers.add(type);
            })), onItemRemove$ = removePeriodBuffer$.pipe(Object(tap.a)(function(_ref2) {
                var period = _ref2.period, type = _ref2.type;
                if (periodsList && 0 !== periodsList.length()) {
                    var periodItem = periodsList.find(function(p) {
                        return p.period === period;
                    });
                    periodItem ? (periodItem.buffers.delete(type), periodItem.buffers.size || periodsList.removeElement(periodItem)) : log.a.error("ActivePeriodEmitter: cannot remove, unknown period.");
                } else log.a.error("ActivePeriodEmitter: cannot remove, no period is active.");
            }));
            return Object(merge.a)(onItemAdd$, onItemRemove$).pipe(Object(map.a)(function() {
                if (!periodsList.head()) return null;
                var periodItem = periodsList.find(function(p) {
                    return isBufferListFull(bufferTypes, p.buffers);
                });
                return null != periodItem ? periodItem.period : null;
            }), Object(distinctUntilChanged.a)());
        }
        /**
 * Returns true if the set of given buffer types is complete (has all possible
 * types).
 * @param {Array.<string>} bufferTypes - Every buffer types in the content.
 * @param {Set.<string>} bufferList
 * @returns {Boolean}
 */        function isBufferListFull(bufferTypes, bufferList) {
            return bufferList.size >= bufferTypes.length;
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/refCount.js
                var refCount = __webpack_require__(92), concatMap = __webpack_require__(148), buffer_events_generators = {
            activeBuffer: function activeBuffer(bufferType) {
                return {
                    type: "active-buffer",
                    value: {
                        bufferType: bufferType
                    }
                };
            },
            activePeriodChanged: function activePeriodChanged(period) {
                return {
                    type: "activePeriodChanged",
                    value: {
                        period: period
                    }
                };
            },
            adaptationChange: function adaptationChange(bufferType, adaptation, period) {
                return {
                    type: "adaptationChange",
                    value: {
                        type: bufferType,
                        adaptation: adaptation,
                        period: period
                    }
                };
            },
            addedSegment: function addedSegment(bufferType, segment, segmentData) {
                return {
                    type: "added-segment",
                    value: {
                        bufferType: bufferType,
                        segment: segment,
                        segmentData: segmentData
                    }
                };
            },
            bitrateEstimationChange: function bitrateEstimationChange(type, bitrate) {
                return {
                    type: "bitrateEstimationChange",
                    value: {
                        type: type,
                        bitrate: bitrate
                    }
                };
            },
            bufferComplete: function bufferComplete(bufferType) {
                return {
                    type: "complete-buffer",
                    value: {
                        type: bufferType
                    }
                };
            },
            discontinuityEncountered: function discontinuityEncountered(bufferType, nextTime) {
                return {
                    type: "discontinuity-encountered",
                    value: {
                        bufferType: bufferType,
                        nextTime: nextTime
                    }
                };
            },
            endOfStream: function endOfStream() {
                return {
                    type: "end-of-stream",
                    value: void 0
                };
            },
            fullBuffer: function fullBuffer(bufferType) {
                return {
                    type: "full-buffer",
                    value: {
                        bufferType: bufferType
                    }
                };
            },
            needsManifestRefresh: function needsManifestRefresh(bufferType) {
                return {
                    type: "needs-manifest-refresh",
                    value: {
                        bufferType: bufferType
                    }
                };
            },
            needsStreamReload: function needsStreamReload() {
                return {
                    type: "needs-stream-reload",
                    value: void 0
                };
            },
            periodBufferReady: function periodBufferReady(type, period, adaptation$) {
                return {
                    type: "periodBufferReady",
                    value: {
                        type: type,
                        period: period,
                        adaptation$: adaptation$
                    }
                };
            },
            periodBufferCleared: function periodBufferCleared(type, period) {
                return {
                    type: "periodBufferCleared",
                    value: {
                        type: type,
                        period: period
                    }
                };
            },
            representationChange: function representationChange(type, period, representation) {
                return {
                    type: "representationChange",
                    value: {
                        type: type,
                        period: period,
                        representation: representation
                    }
                };
            },
            resumeStream: function resumeStream() {
                return {
                    type: "resume-stream",
                    value: void 0
                };
            },
            warning: function warning(value) {
                return {
                    type: "warning",
                    value: value
                };
            }
        }, next_tick = __webpack_require__(56), next_tick_default = /* */ __webpack_require__.n(next_tick);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatMap.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeWhile.js
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function takeWhile(predicate) {
            return function(source) {
                return source.lift(new TakeWhileOperator(predicate));
            };
        }
        var TakeWhileOperator = /* */ function() {
            function TakeWhileOperator(predicate) {
                this.predicate = predicate;
            }
            return TakeWhileOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new takeWhile_TakeWhileSubscriber(subscriber, this.predicate));
            }, TakeWhileOperator;
        }(), takeWhile_TakeWhileSubscriber = /* */ function(_super) {
            function TakeWhileSubscriber(destination, predicate) {
                var _this = _super.call(this, destination) || this;
                return _this.predicate = predicate, _this.index = 0, _this;
            }
            return tslib_es6.a(TakeWhileSubscriber, _super), TakeWhileSubscriber.prototype._next = function(value) {
                var result, destination = this.destination;
                try {
                    result = this.predicate(value, this.index++);
                } catch (err) {
                    return void destination.error(err);
                }
                this.nextOrComplete(value, result);
            }, TakeWhileSubscriber.prototype.nextOrComplete = function(value, predicateResult) {
                var destination = this.destination;
                Boolean(predicateResult) ? destination.next(value) : destination.complete();
            }, TakeWhileSubscriber;
        }(Subscriber.a), simple_set = __webpack_require__(59), GC_GAP_CALM = config.a.BUFFER_GC_GAPS.CALM, GC_GAP_BEEFY = config.a.BUFFER_GC_GAPS.BEEFY;
        /**
 * Run the garbage collector.
 *
 * Try to clean up buffered ranges from a low gcGap at first.
 * If it does not succeed to clean up space, use a higher gcCap.
 *
 * @param {Observable} timings$
 * @param {Object} bufferingQueue
 * @returns {Observable}
 */
        function forceGarbageCollection(timings$, bufferingQueue) {
            // wait for next timing event
            return timings$.pipe(Object(take.a)(1), Object(mergeMap.a)(function(timing) {
                log.a.warn("Buffer: Running garbage collector");
                var buffered = bufferingQueue.getBuffered(), cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_CALM);
                // more aggressive GC if we could not find any range to clean
                return 0 === cleanedupRanges.length && (cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_BEEFY)), 
                log.a.debug("Buffer: GC cleaning", cleanedupRanges), Object(from.a)(cleanedupRanges.map(function(_ref) {
                    var start = _ref.start, end = _ref.end;
                    return bufferingQueue.removeBuffer(start, end);
                })).pipe(Object(concatAll.a)());
            }));
        }
        /**
 * Buffer garbage collector algorithm.
 *
 * Tries to free up some part of the ranges that are distant from the current
 * playing time.
 * See: https://w3c.github.io/media-source/#sourcebuffer-prepare-append
 *
 * @param {Number} currentTime
 * @param {TimeRanges} buffered - current buffered ranges
 * @param {Number} gcGap - delta gap from current timestamp from which we
 * should consider cleaning up.
 * @returns {Array.<Object>} - Ranges selected for clean up
 */        function selectGCedRanges(currentTime, buffered, gcGap) {
            // start by trying to remove all ranges that do not contain the
            // current time and respect the gcGap
            // respect the gcGap? FIXME?
            for (var _getInnerAndOuterTime = Object(utils_ranges.b)(buffered, currentTime), innerRange = _getInnerAndOuterTime.innerRange, outerRanges = _getInnerAndOuterTime.outerRanges, cleanedupRanges = [], i = 0; i < outerRanges.length; i++) {
                var outerRange = outerRanges[i];
                currentTime - gcGap < outerRange.end ? cleanedupRanges.push(outerRange) : currentTime + gcGap > outerRange.start && cleanedupRanges.push(outerRange);
            }
 // try to clean up some space in the current range
                        return innerRange && (log.a.debug("Buffer: GC removing part of inner range", cleanedupRanges), 
            currentTime - gcGap > innerRange.start && cleanedupRanges.push({
                start: innerRange.start,
                end: currentTime - gcGap
            }), currentTime + gcGap < innerRange.end && cleanedupRanges.push({
                start: currentTime + gcGap,
                end: innerRange.end
            })), cleanedupRanges;
        }
        // CONCATENATED MODULE: ./src/core/buffer/append_data.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Append buffer to the queuedSourceBuffer.
 * If it leads to a QuotaExceededError, try to run our custom range
 * _garbage collector_.
 *
 * @param {Observable} clock$
 * @param {Object} queuedSourceBuffer
 * @param {Object} dataInfos
 * @returns {Observable}
 */        function appendDataToSourceBufferWithRetries(clock$, queuedSourceBuffer, dataInfos) {
            var append$ = queuedSourceBuffer.appendBuffer(dataInfos);
            return append$.pipe(Object(catchError.a)(function(appendError) {
                if (!appendError || "QuotaExceededError" !== appendError.name) throw new MediaError.a("BUFFER_APPEND_ERROR", appendError, !0);
                return forceGarbageCollection(clock$, queuedSourceBuffer).pipe(Object(mergeMapTo.a)(append$), Object(catchError.a)(function(forcedGCError) {
                    // (weird Typing either due to TypeScript or RxJS bug)
                    throw new MediaError.a("BUFFER_FULL_ERROR", forcedGCError, !0);
                }));
            }));
        }
        // CONCATENATED MODULE: ./src/core/buffer/get_buffer_paddings.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var BUFFER_PADDING = config.a.BUFFER_PADDING;
        /**
 * Get safety paddings (low and high) for the size of buffer that won't
 * be flushed when switching representation for smooth transitions
 * and avoiding buffer underflows.
 *
 * @param {Object} adaptation
 * @returns {Object}
 */        function getBufferPaddings(adaptation) {
            switch (adaptation.type) {
              case "audio":
              case "video":
                return BUFFER_PADDING[adaptation.type];

              default:
                return BUFFER_PADDING.other;
            }
        }
        // CONCATENATED MODULE: ./src/core/buffer/get_segment_priority.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var SEGMENT_PRIORITIES_STEPS = config.a.SEGMENT_PRIORITIES_STEPS;
        /**
 * Calculate the priority number of the Segment, in function of the distance
 * with the current time.
 *
 * The lower is this number, the higher should be the priority of the request.
 *
 * @param {Object} segment
 * @param {Object} clockTick
 * @returns {number}
 */        function getSegmentPriority(segment, clockTick) {
            for (var currentTime = clockTick.currentTime + clockTick.wantedTimeOffset, distance = segment.time / segment.timescale - currentTime, priority = 0; priority < SEGMENT_PRIORITIES_STEPS.length; priority++) if (distance < SEGMENT_PRIORITIES_STEPS[priority]) return priority;
            return SEGMENT_PRIORITIES_STEPS.length;
        }
        // CONCATENATED MODULE: ./src/core/buffer/get_segments_needed.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns every segments currently wanted.
 * @param {Object} representation - The representation of the chosen
 * adaptation
 * @param {Object} range
 * @returns {Array.<Object>}
 */        function getSegmentsNeeded(representation, range) {
            var start = range.start, duration = range.end - start;
            // given the current timestamp and the previously calculated time gap and
            // wanted buffer size, we can retrieve the list of segments to inject in
            // our pipelines.
            return representation.index.getSegments(start, duration);
        }
        // CONCATENATED MODULE: ./src/core/buffer/get_wanted_range.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the range of segments needed for a particular point in time.
 *
 * @param {Object} hardLimits
 * @param {TimeRanges} buffered
 * @param {Object} timing
 * @param {number} bufferGoal
 * @param {Object} paddings
 * @returns {Object}
 */        function getWantedRange(hardLimits, buffered, timing, bufferGoal, paddings) {
            var currentTime = timing.currentTime + timing.wantedTimeOffset, limitEnd = null == timing.liveGap ? hardLimits.end : Math.min(hardLimits.end || Infinity, timing.currentTime + timing.liveGap), boundedLimits = {
                start: Math.max(hardLimits.start || 0, currentTime),
                end: limitEnd
            }, lowPadding = paddings.low, highPadding = paddings.high, bufferGap = Object(utils_ranges.c)(buffered, currentTime), timestampPadding = lowPadding < bufferGap && bufferGap < Infinity ? Math.min(bufferGap, highPadding) : 0;
            return {
                start: Math.min(Math.max(currentTime + timestampPadding, boundedLimits.start), boundedLimits.end || Infinity),
                end: Math.min(Math.max(currentTime + bufferGoal, boundedLimits.start), boundedLimits.end || Infinity)
            };
        }
        // CONCATENATED MODULE: ./src/core/buffer/segment_filter.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var BITRATE_REBUFFERING_RATIO = config.a.BITRATE_REBUFFERING_RATIO, MINIMUM_SEGMENT_SIZE = config.a.MINIMUM_SEGMENT_SIZE;
        /**
 * Returns true if the given Segment should be downloaded.
 * false otherwise.
 *
 * @param {Object} segment
 * @param {Object} content - The content the Segment depends on.
 * @param {Object} segmentBookkeeper
 * @param {Object} wantedRange
 * @param {Object} segmentIDsToIgnore
 * @returns {boolean}
 */        function segment_filter_shouldDownloadSegment(segment, content, segmentBookkeeper, wantedRange, segmentIDsToIgnore) {
            var period = content.period, adaptation = content.adaptation, representation = content.representation;
            if (segmentIDsToIgnore.test(segment.id)) return !1;
 // segment without time info are usually init segments or some
            // kind of metadata segment that we never filter out
                        if (segment.isInit || segment.time < 0) return !0;
            var time = segment.time, duration = segment.duration, timescale = segment.timescale;
            if (!duration) return !0;
            if (duration / timescale < MINIMUM_SEGMENT_SIZE) return !1;
            var currentSegment = segmentBookkeeper.hasPlayableSegment(wantedRange, {
                time: time,
                duration: duration,
                timescale: timescale
            });
            if (!currentSegment) return !0;
            if (currentSegment.infos.period.id !== period.id || currentSegment.infos.adaptation.id !== adaptation.id) return !0;
 // only re-load comparatively-poor bitrates for the same adaptation.
                        var bitrateCeil = currentSegment.infos.representation.bitrate * BITRATE_REBUFFERING_RATIO;
            return representation.bitrate > bitrateCeil;
        }
        // CONCATENATED MODULE: ./src/core/buffer/representation_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file allows to create RepresentationBuffers.
 *
 * A RepresentationBuffer downloads and push segment for a single
 * Representation (e.g. a single video stream of a given quality).
 * It chooses which segments should be downloaded according to the current
 * position and what is currently buffered.
 */
        /**
 * Build up buffer for a single Representation.
 *
 * Download and push segments linked to the given Representation according
 * to what is already in the SourceBuffer and where the playback currently is.
 *
 * Multiple RepresentationBuffer observables can be ran on the same
 * SourceBuffer.
 * This allows for example smooth transitions between multiple periods.
 *
 * @param {Object} opt
 * @returns {Observable}
 */        function RepresentationBuffer(_ref) {
            var clock$ = _ref.clock$, content = _ref.content, queuedSourceBuffer = _ref.queuedSourceBuffer, segmentBookkeeper = _ref.segmentBookkeeper, segmentFetcher = _ref.segmentFetcher, terminate$ = _ref.terminate$, wantedBufferAhead$ = _ref.wantedBufferAhead$, manifest = content.manifest, period = content.period, adaptation = content.adaptation, representation = content.representation, codec = representation.getMimeTypeString(), bufferType = adaptation.type, initSegment = representation.index.getInitSegment(), paddings = getBufferPaddings(adaptation), initSegmentObject = null == initSegment ? {
                segmentData: null,
                segmentInfos: null,
                segmentOffset: 0
            } : null, startQueue$ = new ReplaySubject.a(1), downloadQueue = [], finishedDownloadQueue$ = new Subject.a(), currentSegmentRequest = null, sourceBufferWaitingQueue = new simple_set.a(), status$ = Object(combineLatest.a)(clock$, wantedBufferAhead$, terminate$.pipe(Object(take.a)(1), Object(mapTo.a)(!0), Object(startWith.a)(!1)), finishedDownloadQueue$.pipe(Object(startWith.a)(void 0))).pipe(Object(map.a)(function getCurrentStatus(_ref2) {
                var timing = _ref2[0], bufferGoal = _ref2[1], terminate = _ref2[2], buffered = queuedSourceBuffer.getBuffered();
                segmentBookkeeper.synchronizeBuffered(buffered);
                // /!\ Side effect
                var neededRange = getWantedRange(period, buffered, timing, bufferGoal, paddings), discontinuity = timing.stalled && manifest.isLive ? representation.index.checkDiscontinuity(timing.currentTime) : -1, shouldRefreshManifest = representation.index.shouldRefresh(neededRange.start, neededRange.end), neededSegments = getSegmentsNeeded(representation, neededRange).filter(function(segment) {
                    return shouldDownloadSegment(segment, neededRange);
                }).map(function(segment) {
                    return {
                        priority: getSegmentPriority(segment, timing),
                        segment: segment
                    };
                });
                return null != initSegment && null == initSegmentObject && (neededSegments = [ {
                    segment: initSegment,
                    priority: getSegmentPriority(initSegment, timing)
                } ].concat(neededSegments)), {
                    discontinuity: discontinuity,
                    isFull: !neededSegments.length && null != period.end && neededRange.end >= period.end,
                    terminate: terminate,
                    neededSegments: neededSegments,
                    shouldRefreshManifest: shouldRefreshManifest
                };
            }), Object(mergeMap.a)(function handleStatus(status) {
                var neededSegments = status.neededSegments, mostNeededSegment = neededSegments[0];
                if (status.terminate) {
                    if (downloadQueue = [], null == currentSegmentRequest) // complete the downloading queue
                    return log.a.debug("Buffer: no request, terminate.", bufferType), startQueue$.complete(), 
                    Object(of.a)({
                        type: "terminated"
                    });
                    if (null == mostNeededSegment || currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) // complete the downloading queue
                    return log.a.debug("Buffer: cancel request and terminate.", bufferType), startQueue$.next(), 
                    // interrupt the current request
                    startQueue$.complete(), Object(of.a)({
                        type: "terminated"
                    });
                    if (currentSegmentRequest.priority !== mostNeededSegment.priority) {
                        var request$ = currentSegmentRequest.request$;
                        segmentFetcher.updatePriority(request$, mostNeededSegment.priority), currentSegmentRequest.priority = mostNeededSegment.priority;
                    }
                    return log.a.debug("Buffer: terminate after request.", bufferType), empty.a;
                }
                var neededActions = [];
                if (1 < status.discontinuity && neededActions.push(buffer_events_generators.discontinuityEncountered(bufferType, status.discontinuity + 1)), 
                status.shouldRefreshManifest && neededActions.push(buffer_events_generators.needsManifestRefresh(bufferType)), 
                null == mostNeededSegment) // (re-)start with an empty queue
                return currentSegmentRequest && log.a.debug("Buffer: interrupt segment request.", bufferType), 
                downloadQueue = [], startQueue$.next(), Object(concat.a)(of.a.apply(void 0, neededActions), status.isFull ? Object(of.a)(buffer_events_generators.fullBuffer(bufferType)) : empty.a);
                if (currentSegmentRequest) if (currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) log.a.debug("Buffer: restart download queue.", bufferType), 
                downloadQueue = neededSegments, startQueue$.next(); else if (currentSegmentRequest.priority !== mostNeededSegment.priority) {
                    log.a.debug("Buffer: update request priority.", bufferType);
                    var _request$ = currentSegmentRequest.request$;
                    segmentFetcher.updatePriority(_request$, mostNeededSegment.priority), currentSegmentRequest.priority = mostNeededSegment.priority;
                } else log.a.debug("Buffer: update downloading queue", bufferType), // Update the previous queue to be all needed segments but the first one,
                // for which a request is already pending
                downloadQueue = neededSegments.slice().splice(1, neededSegments.length); else log.a.debug("Buffer: start downloading queue.", bufferType), 
                downloadQueue = neededSegments, startQueue$.next();
                return Object(concat.a)(of.a.apply(void 0, neededActions), Object(of.a)(buffer_events_generators.activeBuffer(bufferType)));
            }), takeWhile(function(e) {
                return "terminated" !== e.type;
            })), bufferQueue$ = startQueue$.pipe(Object(switchMap.a)(function() {
                return downloadQueue.length ? loadSegmentsFromQueue() : empty.a;
            }), Object(mergeMap.a)(
            /**
   * Append the given segment to the SourceBuffer.
   * Emit the right event when it succeeds.
   * @param {Object} loadedSegment
   * @returns {Observable}
   */
            function appendSegment(loadedSegment) {
                return Object(defer.a)(function() {
                    var segment = loadedSegment.segment;
                    segment.isInit && (initSegmentObject = loadedSegment.value);
                    var _loadedSegment$value = loadedSegment.value, segmentInfos = _loadedSegment$value.segmentInfos, segmentData = _loadedSegment$value.segmentData, segmentOffset = _loadedSegment$value.segmentOffset;
                    if (null == segmentData) 
                    // no segmentData to add here (for example, a text init segment)
                    // just complete directly without appending anything
                    return empty.a;
                    var append$ = appendDataToSourceBufferWithRetries(clock$, queuedSourceBuffer, {
                        initSegment: initSegmentObject && initSegmentObject.segmentData,
                        segment: segment.isInit ? null : segmentData,
                        timestampOffset: segmentOffset,
                        codec: codec
                    });
                    return sourceBufferWaitingQueue.add(segment.id), append$.pipe(Object(mapTo.a)(buffer_events_generators.addedSegment(bufferType, segment, segmentData)), Object(tap.a)(function() {
                        if (!segment.isInit) {
                            var _ref3 = null != segmentInfos ? segmentInfos : segment, time = _ref3.time, duration = _ref3.duration, timescale = _ref3.timescale, start = time / timescale, end = duration && (time + duration) / timescale;
                            segmentBookkeeper.insert(period, adaptation, representation, segment, start, end);
                        }
                    }), finalize(function() {
                        sourceBufferWaitingQueue.remove(segment.id);
                    }));
                });
            }
            /**
   * Return true if the given segment should be downloaded. false otherwise.
   * @param {Object} segment
   * @param {Array.<Object>} neededRange
   * @returns {Boolean}
   */));
            // unwrap components of the content
                        return Object(merge.a)(status$, bufferQueue$).pipe(Object(share.a)());
            /**
   * Request every Segment in the ``downloadQueue`` on subscription.
   * Emit the data of a segment when a request succeeded.
   *
   * Important side-effects:
   *   - Mutates `currentSegmentRequest` when doing and finishing a request.
   *   - Will emit from finishedDownloadQueue$ Subject after it's done.
   * @returns {Observable}
   */            function loadSegmentsFromQueue() {
                var requestNextSegment$ = Object(defer.a)(function() {
                    var currentNeededSegment = downloadQueue.shift();
                    if (null == currentNeededSegment) return next_tick_default()(function() {
                        finishedDownloadQueue$.next();
                    }), empty.a;
                    var segment = currentNeededSegment.segment, priority = currentNeededSegment.priority, request$ = segmentFetcher.createRequest(object_assign_default()({
                        segment: segment
                    }, content), priority);
                    currentSegmentRequest = {
                        segment: segment,
                        priority: priority,
                        request$: request$
                    };
                    var response$ = request$.pipe(Object(mergeMap.a)(function(fetchedSegment) {
                        currentSegmentRequest = null;
                        var initInfos = initSegmentObject && initSegmentObject.segmentInfos || void 0;
                        return fetchedSegment.parse(initInfos);
                    }), Object(map.a)(function(args) {
                        return {
                            segment: segment,
                            value: args
                        };
                    }));
                    return Object(concat.a)(response$, requestNextSegment$);
                });
                return requestNextSegment$.pipe(finalize(function() {
                    currentSegmentRequest = null;
                }));
            }
            function shouldDownloadSegment(segment, neededRange) {
                return segment_filter_shouldDownloadSegment(segment, content, segmentBookkeeper, neededRange, sourceBufferWaitingQueue);
            }
        }
        // CONCATENATED MODULE: ./src/core/buffer/adaptation_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file allows to create AdaptationBuffers.
 *
 * An AdaptationBuffer downloads and push segment for a single Adaptation (e.g.
 * a single audio or text track).
 * It chooses which Representation to download mainly thanks to the
 * ABRManager, and orchestrates the various RepresentationBuffer, which will
 * download and push segments for a single Representation.
 */
        /**
 * Create new Buffer Observable linked to the given Adaptation.
 *
 * It will rely on the ABRManager to choose at any time the best Representation
 * for this Adaptation and then run the logic to download and push the
 * corresponding segments in the SourceBuffer.
 *
 * It will emit various events to report its status to the caller.
 *
 * @param {Observable} clock$ - Clock at which the Buffer will check for
 * segments download
 * @param {QueuedSourceBuffer} queuedSourceBuffer - QueuedSourceBuffer used
 * to push segments and know about the current real buffer's health.
 * @param {SegmentBookkeeper} segmentBookkeeper - Used to synchronize and
 * retrieve the Segments currently present in the QueuedSourceBuffer
 * @param {Function} segmentFetcher - Function used to download segments
 * @param {Observable} wantedBufferAhead$ - Emits the buffer goal
 * @param {Object} content - Content to download
 * @param {Object} abrManager
 * @returns {Observable}
 */        function AdaptationBuffer(clock$, queuedSourceBuffer, segmentBookkeeper, segmentFetcher, wantedBufferAhead$, content, abrManager, options) {
            var directManualBitrateSwitching = "direct" === options.manualBitrateSwitchingMode, manifest = content.manifest, period = content.period, adaptation = content.adaptation, currentRepresentation = null, abrClock$ = clock$.pipe(Object(map.a)(function(tick) {
                var downloadBitrate = currentRepresentation ? currentRepresentation.bitrate : void 0;
                return object_assign_default()({
                    downloadBitrate: downloadBitrate
                }, tick);
            })), abr$ = abrManager.get$(adaptation.type, abrClock$, adaptation.representations).pipe(// equivalent to a sane shareReplay:
            // https://github.com/ReactiveX/rxjs/issues/3336
            // XXX TODO Replace it when that issue is resolved
            Object(multicast.a)(function() {
                return new ReplaySubject.a(1);
            }), Object(refCount.a)()), killCurrentBuffer$ = new Subject.a(), terminateCurrentBuffer$ = new Subject.a(), bitrateEstimate$ = abr$.pipe(Object(filter.a)(function(_ref) {
                return null != _ref.bitrate;
            }), Object(distinctUntilChanged.a)(function(old, current) {
                return old.bitrate === current.bitrate;
            }), Object(map.a)(function(_ref2) {
                var bitrate = _ref2.bitrate;
                return log.a.debug("Buffer: new " + adaptation.type + " bitrate estimation", bitrate), 
                buffer_events_generators.bitrateEstimationChange(adaptation.type, bitrate);
            })), adaptationBuffer$ = abr$.pipe(Object(distinctUntilChanged.a)(function(a, b) {
                return a.manual === b.manual && a.representation.id === b.representation.id;
            }), Object(tap.a)(function(estimation) {
                estimation.urgent ? (log.a.info("Buffer: urgent Representation switch", adaptation.type), 
                killCurrentBuffer$.next()) : (log.a.info("Buffer: slow Representation switch", adaptation.type), 
                terminateCurrentBuffer$.next());
            }), Object(concatMap.a)(function(estimate, i) {
                var representation = estimate.representation;
                // Manual switch needs an immediate feedback.
                // To do that properly, we need to reload the stream
                if (currentRepresentation = representation, directManualBitrateSwitching && estimate.manual && 0 !== i) return Object(of.a)(buffer_events_generators.needsStreamReload());
                var representationChange$ = Object(of.a)(buffer_events_generators.representationChange(adaptation.type, period, representation)), representationBuffer$ = createRepresentationBuffer(representation).pipe(Object(takeUntil.a)(killCurrentBuffer$));
                return Object(concat.a)(representationChange$, representationBuffer$);
            }));
            return Object(merge.a)(adaptationBuffer$, bitrateEstimate$);
            /**
   * Create and returns a new RepresentationBuffer Observable, linked to the
   * given Representation.
   * @param {Representation} representation
   * @returns {Observable}
   */            function createRepresentationBuffer(representation) {
                return Object(defer.a)(function() {
                    return log.a.info("Buffer: changing representation", adaptation.type, representation), 
                    RepresentationBuffer({
                        clock$: clock$,
                        content: {
                            representation: representation,
                            adaptation: adaptation,
                            period: period,
                            manifest: manifest
                        },
                        queuedSourceBuffer: queuedSourceBuffer,
                        segmentBookkeeper: segmentBookkeeper,
                        segmentFetcher: segmentFetcher,
                        terminate$: terminateCurrentBuffer$,
                        wantedBufferAhead$: wantedBufferAhead$
                    }).pipe(Object(catchError.a)(function(error) {
                        // TODO only for smooth/to Delete? Do it in the stream?
                        // for live adaptations, handle 412 errors as precondition-
                        // failed errors, ie: we are requesting for segments before they
                        // exist
                        // (In case of smooth streaming, 412 errors are requests that are
                        // performed to early).
                        if (!manifest.isLive || error.type !== constants.b.NETWORK_ERROR || !error.isHttpError(412)) throw error;
                        return manifest.updateLiveGap(1), // go back 1s for now
                        log.a.warn("Buffer: precondition failed", manifest.presentationLiveGap), Object(timer.a)(2e3).pipe(Object(mergeMap.a)(function() {
                            return createRepresentationBuffer(representation);
                        }));
                    }));
                });
            }
        }
 // Re-export RepresentationBuffer events used by the AdaptationBufferManager
        // CONCATENATED MODULE: ./src/core/buffer/are_buffers_complete.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns an Observable which emits ``true`` when all PeriodBuffers given are
 * _complete_.
 * Returns false otherwise.
 *
 * A PeriodBuffer for a given type is considered _complete_ when both of these
 * conditions are true:
 *   - it is the last PeriodBuffer in the content for the given type
 *   - it has finished downloading segments (it is _full_)
 *
 * Simply put a _complete_ PeriodBuffer for a given type means that every
 * segments needed for this Buffer have been downloaded.
 *
 * When the Observable returned here emits, every Buffer are finished.
 * @param {...Observable} buffers
 * @returns {Observable}
 */        function areBuffersComplete() {
            for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) buffers[_key] = arguments[_key];
            /**
   * Array of Observables linked to the Array of Buffers which emit:
   *   - true when the corresponding buffer is considered _complete_.
   *   - false when the corresponding buffer is considered _active_.
   * @type {Array.<Observable>}
   */            var isCompleteArray = buffers.map(function(buffer) {
                return buffer.pipe(Object(filter.a)(function(evt) {
                    return "complete-buffer" === evt.type || "active-buffer" === evt.type;
                }), Object(map.a)(function(evt) {
                    return "complete-buffer" === evt.type;
                }), Object(startWith.a)(!1), Object(distinctUntilChanged.a)());
            });
            return combineLatest.a.apply(void 0, isCompleteArray).pipe(Object(map.a)(function(areComplete) {
                return areComplete.every(function(isComplete) {
                    return isComplete;
                });
            }), Object(distinctUntilChanged.a)());
        }
        // CONCATENATED MODULE: ./src/core/buffer/create_fake_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create empty AdaptationBuffer Observable, linked to a Period.
 *
 * This observable will never download any segment and just emit a "full"
 * event when reaching the end.
 *
 * @param {Observable} bufferClock$
 * @param {Observable} wantedBufferAhead$
 * @param {string} bufferType
 * @param {Object} content
 * @returns {Observable}
 */        function createFakeAdaptationBuffer(bufferClock$, wantedBufferAhead$, bufferType, content) {
            var period = content.period;
            return Object(combineLatest.a)(bufferClock$, wantedBufferAhead$).pipe(Object(filter.a)(function(_ref) {
                var clockTick = _ref[0], wantedBufferAhead = _ref[1];
                return null != period.end && clockTick.currentTime + wantedBufferAhead >= period.end;
            }), Object(map.a)(function() {
                return log.a.debug("Buffer: full FakeBuffer", bufferType), {
                    type: "full-buffer",
                    value: {
                        bufferType: bufferType
                    }
                };
            }));
        }
        // CONCATENATED MODULE: ./src/core/buffer/get_adaptation_switch_strategy.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var ADAPTATION_SWITCH_BUFFER_PADDINGS = config.a.ADAPTATION_SWITCH_BUFFER_PADDINGS;
        /**
 * Find out what to do when switching adaptation, based on the current
 * situation.
 * @param {TimeRanges} buffered
 * @param {Object} period
 * @param {string} bufferType
 * @param {Object} clockTick
 * @returns {Object}
 */        function getAdaptationSwitchStrategy(buffered, period, bufferType, clockTick) {
            if (!buffered.length) return {
                type: "continue",
                value: void 0
            };
            var bufferedRanges = Object(utils_ranges.a)(buffered), start = period.start, end = period.end || Infinity;
            if (!Object(utils_ranges.j)(bufferedRanges, [ {
                start: start,
                end: end
            } ]).length) return {
                type: "continue",
                value: void 0
            };
            var currentTime = clockTick.currentTime;
            if ("video" === bufferType && 1 < clockTick.readyState && Object(utils_ranges.i)({
                start: start,
                end: end
            }, currentTime)) return {
                type: "reload-stream",
                value: void 0
            };
            var paddingBefore = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].before || 0, paddingAfter = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].after || 0;
            return !paddingAfter && !paddingBefore || end <= currentTime - paddingBefore || currentTime + paddingAfter <= start ? {
                type: "clean-buffer",
                value: [ {
                    start: start,
                    end: end
                } ]
            } : currentTime - paddingBefore <= start ? {
                type: "clean-buffer",
                value: [ {
                    start: currentTime + paddingAfter,
                    end: end
                } ]
            } : end <= currentTime + paddingAfter ? {
                type: "clean-buffer",
                value: [ {
                    start: start,
                    end: currentTime - paddingBefore
                } ]
            } : {
                type: "clean-buffer",
                value: [ {
                    start: start,
                    end: currentTime - paddingBefore
                }, {
                    start: currentTime + paddingAfter,
                    end: end
                } ]
            };
        }
        // CONCATENATED MODULE: ./src/utils/takeFirstSet.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the first argument given different from undefined or null.
 * @param {...*} args
 * @returns {*}
 */        function takeFirstSet() {
            for (var i = 0, len = arguments.length; i < len; ) {
                if (null != (i < 0 || arguments.length <= i ? void 0 : arguments[i])) return i < 0 || arguments.length <= i ? void 0 : arguments[i];
                i++;
            }
        }
        // CONCATENATED MODULE: ./src/core/buffer/segment_bookkeeper.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT = config.a.MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT, MAX_BUFFERED_DISTANCE = config.a.MAX_BUFFERED_DISTANCE, segment_bookkeeper_MINIMUM_SEGMENT_SIZE = config.a.MINIMUM_SEGMENT_SIZE, segment_bookkeeper_SegmentBookkeeper = 
        /* */
        function() {
            function SegmentBookkeeper() {
                /**
     * The inventory keep track of all the segments which should be currently
     * in the browser's memory.
     * This array contains objects, each being related to a single downloaded
     * segment which is at least partially added in a source buffer.
     * @type {Array.<Object>}
     */
                this.inventory = [];
            }
            /**
   * Infer each segment's bufferedStart and bufferedEnd from the TimeRanges
   * given (coming from the source buffer).
   * @param {TimeRanges}
   *
   * TODO implement management of segments whose end is not known
   */            var _proto = SegmentBookkeeper.prototype;
            return _proto.synchronizeBuffered = function synchronizeBuffered(buffered) {
                for (var inventory = this.inventory, ranges = Object(utils_ranges.a)(buffered), inventoryIndex = 0, thisSegment = inventory[0], rangesLength = ranges.length, i = 0; i < rangesLength; i++) {
                    if (null == thisSegment) 
                    // If thisSegment is not set, it means that we arrived at the end of
                    // our inventory.
                    // This TimeRange do not link to any segment and neither will any
                    // subsequent one.
                    // (It may be linked to another adaptation, for example)
                    return;
                    var _ranges$i = ranges[i], rangeStart = _ranges$i.start, rangeEnd = _ranges$i.end;
 // if current TimeRange is too small to contain a segment, go to next one
                                        if (!(rangeEnd - rangeStart < segment_bookkeeper_MINIMUM_SEGMENT_SIZE)) {
                        // Find the first segment either within this TimeRange or past it:
                        // skip until first segment with at least MINIMUM_SEGMENT_SIZE past the
                        // start of that range.
                        for (
                        /**
       * Inventory index of the last segment not contained in the current range.
       * Will be used to know how many segments have been garbage collected.
       * @type {Number}
       */
                        var indexBefore = inventoryIndex; thisSegment && // TODO better way to indicate to typescript that all is well here
                        takeFirstSet(thisSegment.bufferedEnd, thisSegment.end) - rangeStart < segment_bookkeeper_MINIMUM_SEGMENT_SIZE; ) thisSegment = inventory[++inventoryIndex];
                        /**
       * Contains the end of the last garbage-collected segment before
       * thisSegment.
       * Might be useful to infer later the bufferedStart of thisSegment.
       *
       * -1 if no segment have been garbage-collected before thisSegment.
       * @type {Number}
       */                        var lastDeletedSegmentEnd = -1, numberOfSegmentToDelete = inventoryIndex - indexBefore;
 // remove garbage-collected segments
                        // (not in that TimeRange nor in the previous one)
                                                if (0 < numberOfSegmentToDelete) {
                            // last garbage-collected segment
                            var lastDeletedSegment = inventory[indexBefore + numberOfSegmentToDelete - 1];
 // TODO better way to indicate to typescript that all is well here
                                                        lastDeletedSegmentEnd = takeFirstSet(lastDeletedSegment.bufferedEnd, lastDeletedSegment.end), 
                            // mutate inventory
                            inventory.splice(indexBefore, numberOfSegmentToDelete), inventoryIndex = indexBefore;
                        }
 // if no segment is left for that range (or any other one), quit
                                                if (null == thisSegment) return;
 // Infer the bufferedStart for this segment, and the bufferedStart and
                        // bufferedEnd for the following segments included in that range.
                        //
                        // If the current segment is actually completely outside that range (it
                        // is contained in one of the next one), skip that part.
                                                if (rangeEnd - // TODO better way to indicate to typescript that all is well here
                        takeFirstSet(thisSegment.bufferedStart, thisSegment.start) >= segment_bookkeeper_MINIMUM_SEGMENT_SIZE) // Make contiguous until first segment outside that range
                        // (i.e until the start of the next segment can not constitute a segment
                        // in that range == less than MINIMUM_SEGMENT_SIZE into that range)
                        for (
                        // set the bufferedStart of the first segment in that range
                        null != thisSegment.bufferedStart && thisSegment.bufferedStart < rangeStart ? 
                        // the segment appears to have been partially garbage collected:
                        // Update bufferedStart
                        thisSegment.bufferedStart = rangeStart : null == thisSegment.bufferedStart && (-1 !== lastDeletedSegmentEnd && rangeStart < lastDeletedSegmentEnd && thisSegment.start - lastDeletedSegmentEnd <= MAX_BUFFERED_DISTANCE ? thisSegment.bufferedStart = lastDeletedSegmentEnd : thisSegment.start - rangeStart <= MAX_BUFFERED_DISTANCE ? thisSegment.bufferedStart = rangeStart : thisSegment.bufferedStart = thisSegment.start), 
                        thisSegment = inventory[++inventoryIndex]; thisSegment && rangeEnd - // TODO better way to indicate to typescript that all is well here
                        takeFirstSet(thisSegment.bufferedStart, thisSegment.start) >= segment_bookkeeper_MINIMUM_SEGMENT_SIZE; ) {
                            var prevSegment = inventory[inventoryIndex - 1];
 // those segments are contiguous, we have no way to infer their real
                            // end
                                                        null == prevSegment.bufferedEnd && (prevSegment.bufferedEnd = prevSegment.end), 
                            thisSegment.bufferedStart = prevSegment.bufferedEnd, thisSegment = inventory[++inventoryIndex];
                        }
 // update the bufferedEnd of the last segment in that range
                                                var lastSegmentInRange = inventory[inventoryIndex - 1];
                        lastSegmentInRange && (null != lastSegmentInRange.bufferedEnd && lastSegmentInRange.bufferedEnd > rangeEnd ? 
                        // the segment appears to have been partially garbage collected:
                        // Update bufferedEnd
                        lastSegmentInRange.bufferedEnd = rangeEnd : null == lastSegmentInRange.bufferedEnd && (lastSegmentInRange.bufferedEnd = rangeEnd - lastSegmentInRange.end <= MAX_BUFFERED_DISTANCE ? rangeEnd : lastSegmentInRange.end));
                    }
                }
 // if we still have segments left, they are not affiliated to any range.
                // They might have been garbage collected, delete them from here.
                                thisSegment && inventory.splice(inventoryIndex, inventory.length - inventoryIndex);
            }, 
            /**
   * Add a new segment in the inventory.
   *
   * Note: As new segments can "replace" partially or completely old ones, we
   * have to perform a complex logic and might update previously added segments.
   *
   * @param {Object} period
   * @param {Object} adaptation
   * @param {Object} representation
   * @param {Object} segment
   * @param {Number} start - start time of the segment, in seconds
   * @param {Number|undefined} end - end time of the segment, in seconds. Can
   * be undefined in some rare cases
   */
            _proto.insert = function insert(period, adaptation, representation, segment, start, end) {
                // TODO (*very* low-priority) manage segments whose end is unknown (rare but
                // could eventually happen).
                // This should be properly managed in this method, but it is not in some
                // other methods of this class, so I decided to not one of those to the
                // inventory by security
                if (null != end) {
                    // begin by the end as in most use cases this will be faster
                    for (var inventory = this.inventory, newSegment = {
                        start: start,
                        end: end,
                        bufferedStart: void 0,
                        bufferedEnd: void 0,
                        infos: {
                            segment: segment,
                            period: period,
                            adaptation: adaptation,
                            representation: representation
                        }
                    }, i = inventory.length - 1 // infer start and end from the segment data
                    // /!\ Can be a little different than their real start/end time in the
                    // sourcebuffer.
                    // const start = segment.time / segment.timescale;
                    // const end = (segment.time + segment.duration) / segment.timescale;
                    ; 0 <= i; i--) {
                        var segmentI = inventory[i];
                        if (segmentI.start <= start) return segmentI.end <= start ? 
                        // our segment is after, push it after this one
                        //
                        // Case 1:
                        //   segmentI     : |------|
                        //   newSegment   :        |------|
                        //
                        // Case 2:
                        //   segmentI     : |------|
                        //   newSegment   :          |------|
                        void this.inventory.splice(i + 1, 0, newSegment) : 
                        // /!\ also goes here if end is undefined
                        segmentI.start >= start ? 
                        // In those cases, replace
                        // Case 1:
                        //  segmentI     : |-------|
                        //  newSegment   : |-------|
                        //
                        // Case 2:
                        //  segmentI     : |-------|
                        //  newSegment   : |----------|
                        //
                        // Case 3:
                        //  segmentI     : |-------|
                        //  newSegment   : |???*
                        //
                        // Case 4:
                        //  segmentI     : |???*
                        //  newSegment   : |------|
                        //
                        // Case 5:
                        //  segmentI     : |???*
                        //  newSegment   : |???*
                        //
                        // *|??? - unknown end
                        void this.inventory.splice(i, 1, newSegment) : (
                        // our segment has a "complex" relation with this one,
                        // update the old one end and add this one after it.
                        //
                        // Case 1:
                        //  segmentI     : |-------|
                        //  newSegment   :    |------|
                        //
                        // Case 2:
                        //  segmentI     : |-------|
                        //  newSegment   :    |----|
                        //
                        // Case 3:
                        //  segmentI     : |-------|
                        //  newSegment   :    |???*
                        //
                        // Case 4:
                        //  segmentI     : |???*
                        //  newSegment   :    |----|
                        //
                        // Case 5:
                        //  segmentI     : |???*
                        //  newSegment   :    |???*
                        //
                        // *|??? - unknown end
                        // (if segment's end is not known yet, it could perfectly
                        // end before the one we're adding now)
                        null != segmentI.end && (segmentI.end = start), void this.inventory.splice(i + 1, 0, newSegment));
                    }
 // if we got here, we are the first segment
                    // check bounds of the previous first segment
                                        var firstSegment = this.inventory[0];
                    firstSegment ? null != end ? firstSegment.start >= end ? 
                    // our segment is before, put it before
                    // Case 1:
                    //  firstSegment :      |----|
                    //  newSegment   : |----|
                    //
                    // Case 2:
                    //  firstSegment :        |----|
                    //  newSegment   : |----|
                    //
                    // Case 3:
                    //  firstSegment :        |???*
                    //  newSegment   : |----|
                    //
                    // Case 4:
                    //  firstSegment :      |???*
                    //  newSegment   : |----|
                    //
                    // *|??? - unknown end
                    this.inventory.splice(0, 0, newSegment) : firstSegment.end <= end ? 
                    // Our segment is bigger, replace the first
                    // Case 1:
                    //  firstSegment :   |---|
                    //  newSegment   : |-------|
                    //
                    // Case 2:
                    //  firstSegment :   |-----|
                    //  newSegment   : |-------|
                    this.inventory.splice(0, 1, newSegment) : (
                    // our segment has a "complex" relation with the first one,
                    // update the old one start and add this one before it.
                    // Case 1:
                    //  firstSegment :    |------|
                    //  newSegment   : |------|
                    //
                    // Case 2:
                    // firstSegment :   |???*
                    // newSegment   : |-----|
                    //
                    // *|??? - unknown end
                    firstSegment.start = end, this.inventory.splice(0, 0, newSegment)) : firstSegment.start === start ? 
                    // same beginning, unknown end, just replace
                    // Case 1:
                    //  firstSegment : |-------|
                    //  newSegment   : |???*
                    //
                    // Case 2:
                    //  firstSegment : |???*
                    //  newSegment   : |???*
                    //
                    // *|??? - unknown end
                    this.inventory.splice(0, 1, newSegment) : 
                    // our segment begins before this one, push at the beginning
                    // Case 1:
                    // firstSegment :   |-------|
                    // newSegment   : |???*
                    //
                    // Case 2:
                    // firstSegment :   |???*
                    // newSegment   : |???*
                    //
                    // *|??? - unknown end
                    this.inventory.splice(0, 0, newSegment) : 
                    // we do not have any segment yet
                    this.inventory.push(newSegment);
                } else // This leads to excessive re-downloads of segment without an ending time.
                log.a.warn("SB: ending time of the segment not defined");
            }, 
            /**
   * Returns segment infos for a segment corresponding to the given time,
   * duration and timescale.
   *
   * Returns null if either:
   *   - no segment can be linked exactly to the given time/duration
   *   - a segment is linked to this information, but is currently considered
   *     "incomplete" to be playable, in the sourceBuffer. We check if all
   *     needed data for playback (from wanted range) is loaded.
   *
   * The main purpose of this method is to know if the segment asked should be
   * downloaded (or re-downloaded).
   *
   * /!\ Make sure that this class is synchronized with the sourceBuffer
   * (see addBufferedInfos method of the same class) before calling this method,
   * as it depends on it to categorize "incomplete" from "complete" segments.
   *
   * @param {Object} wantedRange
   * @param {Object} segmentInfos
   * @returns {Object|null}
   */
            _proto.hasPlayableSegment = function hasPlayableSegment(wantedRange, segmentInfos) {
                for (var time = segmentInfos.time, duration = segmentInfos.duration, timescale = segmentInfos.timescale, inventory = this.inventory, i = inventory.length - 1; 0 <= i; i--) {
                    var currentSegmentI = inventory[i], prevSegmentI = inventory[i - 1], nextSegmentI = inventory[i + 1], segment = currentSegmentI.infos.segment, _time = time, _duration = duration;
                    if (segment.timescale !== timescale && (
                    // Note: we could get rounding errors here
                    _time = time * segment.timescale / timescale, _duration = duration * segment.timescale / timescale), 
                    segment.time === _time && segment.duration === _duration && hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI) && hasWantedRange(wantedRange, currentSegmentI, prevSegmentI, nextSegmentI)) return currentSegmentI;
                }
                return null;
 // -- Helpers
                /**
     * Check if segment can be evaluated.
     * @param {Object} currentSegmentI
     * @param {Object} prevSegmentI
     * @param {Object} nextSegmentI
     * @returns {Boolean}
     */                function hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI) {
                    return !(prevSegmentI && null == prevSegmentI.bufferedEnd || null == currentSegmentI.bufferedStart) && !(nextSegmentI && null == nextSegmentI.bufferedStart || null == currentSegmentI.bufferedEnd);
                }
                /**
     * Returns true if the segment given can be played for the wanted range.
     * @param {Object} _wantedRange
     * @param {Object} currentSegmentI
     * @param {Object} prevSegmentI
     * @param {Object} nextSegmentI
     * @returns {Boolean}
     */                function hasWantedRange(_wantedRange, currentSegmentI, prevSegmentI, nextSegmentI) {
                    if (!prevSegmentI || null == prevSegmentI.bufferedEnd || null == currentSegmentI.bufferedStart || prevSegmentI.bufferedEnd < currentSegmentI.bufferedStart) {
                        if (null == currentSegmentI.bufferedStart) return !1;
                        var timeDiff = currentSegmentI.bufferedStart - currentSegmentI.start;
                        if (_wantedRange.start > currentSegmentI.start) {
                            if (0 < currentSegmentI.bufferedStart - _wantedRange.start && MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT < timeDiff) return log.a.debug("SB: The wanted segment has been garbage collected", currentSegmentI), 
                            !1;
                        } else if (MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT < timeDiff) return log.a.debug("SB: The wanted segment has been garbage collected", currentSegmentI), 
                        !1;
                    }
                    if (null === currentSegmentI.end) return !1;
                    if (!nextSegmentI || null == nextSegmentI.bufferedStart || null == currentSegmentI.bufferedEnd || nextSegmentI.bufferedStart > currentSegmentI.bufferedEnd) {
                        if (null == currentSegmentI.bufferedEnd) return !1;
                        var _timeDiff = currentSegmentI.end - currentSegmentI.bufferedEnd;
                        if (_wantedRange.end < currentSegmentI.end) {
                            if (0 < _wantedRange.end - currentSegmentI.bufferedEnd && MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT < _timeDiff) return log.a.debug("SB: The wanted segment has been garbage collected", currentSegmentI), 
                            !1;
                        } else if (MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT < _timeDiff) return log.a.debug("SB: The wanted segment has been garbage collected", currentSegmentI), 
                        !1;
                    }
                    return !0;
                }
            }, 
            /**
   * Empty the current inventory
   */
            _proto.reset = function reset() {
                this.inventory = [];
            }, SegmentBookkeeper;
        }(), MAXIMUM_MAX_BUFFER_AHEAD = config.a.MAXIMUM_MAX_BUFFER_AHEAD, MAXIMUM_MAX_BUFFER_BEHIND = config.a.MAXIMUM_MAX_BUFFER_BEHIND, DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR = config.a.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR, DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE = config.a.DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE;
        /**
 * Keep track of every segment downloaded and currently in the browser's memory.
 *
 * The main point of this class is to know which CDN segments are already
 * pushed to the SourceBuffer, at which bitrate, and which have been
 * garbage-collected since by the browser (and thus should be re-downloaded).
 * @class SegmentBookkeeper
 */        
        /**
 * @param {string} bufferType
 * @param {number|undefined} retry
 * @param {number|undefined} offlineRetry
 * @returns {Object} - Options to give to the Pipeline
 */
        function getPipelineOptions(bufferType, retry, offlineRetry) {
            return {
                cache: Object(array_includes.a)([ "audio", "video" ], bufferType) ? new initialization_segment_cache() : void 0,
                maxRetry: "image" === bufferType ? 0 : null != retry ? retry : DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR,
                maxRetryOffline: null != offlineRetry ? offlineRetry : DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE
            };
        }
        /**
 * Get mimetype string of the first representation declared in the given
 * adaptation.
 * @param {Adaptation} adaptation
 * @returns {string}
 */        function getFirstDeclaredMimeType(adaptation) {
            var representations = adaptation.representations;
            return representations[0] && representations[0].getMimeTypeString() || "";
        }
        // CONCATENATED MODULE: ./src/core/buffer/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        var core_buffer = 
        /**
 * Create and manage the various Buffer Observables needed for the content to
 * stream:
 *
 *   - Create or dispose SourceBuffers depending on the chosen adaptations.
 *
 *   - Concatenate Buffers for adaptation from separate Periods at the right
 *     time, to allow smooth transitions between periods.
 *
 *   - Emit events as Period or Adaptations change or as new Period are
 *     prepared.
 *
 * Here multiple buffers can be created at the same time to allow smooth
 * transitions between periods.
 * To do this, we dynamically create or destroy buffers as they are needed.
 * @param {Object} content
 * @param {Observable} clock$ - Emit position informations
 * @param {Object} abrManager - Emit bitrate estimation and best Representation
 * to play.
 * @param {Object} sourceBufferManager - Will be used to lazily create
 * SourceBuffer instances associated with the current content.
 * @param {Object} segmentPipelinesManager - Download segments
 * @param {Object} options
 * @returns {Observable}
 *
 * TODO Special case for image Buffer, where we want data for EVERY active
 * periods.
 */
        function PeriodBufferManager(content, clock$, abrManager, sourceBufferManager, segmentPipelinesManager, options) {
            var manifest = content.manifest, initialPeriod = content.initialPeriod, wantedBufferAhead$ = options.wantedBufferAhead$, maxBufferAhead$ = options.maxBufferAhead$, maxBufferBehind$ = options.maxBufferBehind$, garbageCollectors = new WeakMapMemory(function(qSourceBuffer) {
                var bufferType = qSourceBuffer.bufferType, defaultMaxBehind = null != MAXIMUM_MAX_BUFFER_BEHIND[bufferType] ? MAXIMUM_MAX_BUFFER_BEHIND[bufferType] : Infinity, defaultMaxAhead = null != MAXIMUM_MAX_BUFFER_AHEAD[bufferType] ? MAXIMUM_MAX_BUFFER_AHEAD[bufferType] : Infinity;
                return BufferGarbageCollector({
                    queuedSourceBuffer: qSourceBuffer,
                    clock$: clock$.pipe(Object(map.a)(function(tick) {
                        return tick.currentTime;
                    })),
                    maxBufferBehind$: maxBufferBehind$.pipe(Object(map.a)(function(val) {
                        return Math.min(val, defaultMaxBehind);
                    })),
                    maxBufferAhead$: maxBufferAhead$.pipe(Object(map.a)(function(val) {
                        return Math.min(val, defaultMaxAhead);
                    }))
                });
            }), segmentBookkeepers = new WeakMapMemory(function() {
                return new segment_bookkeeper_SegmentBookkeeper();
            }), addPeriodBuffer$ = new Subject.a(), removePeriodBuffer$ = new Subject.a(), bufferTypes = getBufferTypes(), buffersArray = bufferTypes.map(function(bufferType) {
                return manageEveryBuffers(bufferType, initialPeriod).pipe(Object(tap.a)(function(evt) {
                    "periodBufferReady" === evt.type ? addPeriodBuffer$.next(evt.value) : "periodBufferCleared" === evt.type && removePeriodBuffer$.next(evt.value);
                }), Object(share.a)());
            }), activePeriodChanged$ = ActivePeriodEmitter(bufferTypes, addPeriodBuffer$, removePeriodBuffer$).pipe(Object(filter.a)(function(period) {
                return !!period;
            }), Object(map.a)(function(period) {
                return log.a.info("Buffer: New active period", period), buffer_events_generators.activePeriodChanged(period);
            })), streamHasEnded$ = areBuffersComplete.apply(void 0, buffersArray).pipe(Object(map.a)(function(areComplete) {
                return areComplete ? buffer_events_generators.endOfStream() : buffer_events_generators.resumeStream();
            }));
            return merge.a.apply(void 0, [ activePeriodChanged$ ].concat(buffersArray, [ streamHasEnded$ ]));
            /**
   * Manage creation and removal of Buffers for every Periods.
   *
   * Works by creating consecutive buffers through the
   * manageConsecutivePeriodBuffers function, and restarting it when the clock
   * goes out of the bounds of these buffers.
   * @param {string} bufferType - e.g. "audio" or "video"
   * @param {Period} basePeriod - Initial Period downloaded.
   * @returns {Observable}
   */            function manageEveryBuffers(bufferType, basePeriod) {
                // Each Period currently considered, chronologically
                var periodList = new sorted_list_SortedList(function(a, b) {
                    return a.start - b.start;
                });
                /**
     * Returns true if the given time is either:
     *   - less than the start of the chronologically first Period
     *   - more than the end of the chronologically last Period
     * @param {number} time
     * @returns {boolean}
     */                function isOutOfPeriodList(time) {
                    var head = periodList.head(), last = periodList.last();
                    return null == head || null == last || head.start > time || (last.end || Infinity) < time;
                }
 // Destroy the current set of consecutive buffers.
                // Used when the clocks goes out of the bounds of those, e.g. when the user
                // seeks.
                // We can then re-create consecutive buffers, from the new point in time.
                                var destroyCurrentBuffers = new Subject.a(), outOfManifest$ = clock$.pipe(Object(mergeMap.a)(function(_ref) {
                    var currentTime = _ref.currentTime, position = _ref.wantedTimeOffset + currentTime;
                    if (position < manifest.getMinimumPosition()) {
                        var warning = new MediaError.a("MEDIA_TIME_BEFORE_MANIFEST", null, !1);
                        return Object(of.a)(buffer_events_generators.warning(warning));
                    }
                    if (position > manifest.getMaximumPosition()) {
                        var _warning = new MediaError.a("MEDIA_TIME_AFTER_MANIFEST", null, !1);
                        return Object(of.a)(buffer_events_generators.warning(_warning));
                    }
                    return empty.a;
                })), restartBuffers$ = clock$.pipe(Object(filter.a)(function(_ref2) {
                    var currentTime = _ref2.currentTime, wantedTimeOffset = _ref2.wantedTimeOffset;
                    return !!manifest.getPeriodForTime(wantedTimeOffset + currentTime) && isOutOfPeriodList(wantedTimeOffset + currentTime);
                }), Object(take.a)(1), Object(tap.a)(function(_ref3) {
                    var currentTime = _ref3.currentTime, wantedTimeOffset = _ref3.wantedTimeOffset;
                    log.a.info("Buffer: Current position out of the bounds of the active periods,re-creating buffers.", bufferType, currentTime + wantedTimeOffset), 
                    destroyCurrentBuffers.next();
                }), Object(mergeMap.a)(function(_ref4) {
                    var currentTime = _ref4.currentTime, wantedTimeOffset = _ref4.wantedTimeOffset, newInitialPeriod = manifest.getPeriodForTime(currentTime + wantedTimeOffset);
                    if (null == newInitialPeriod) throw new MediaError.a("MEDIA_TIME_NOT_FOUND", null, !0);
                    // Note: For this to work, manageEveryBuffers should always emit the
                    // "periodBufferReady" event for the new InitialPeriod synchronously
                    return manageEveryBuffers(bufferType, newInitialPeriod);
                })), currentBuffers$ = manageConsecutivePeriodBuffers(bufferType, basePeriod, destroyCurrentBuffers).pipe(Object(tap.a)(function(message) {
                    "periodBufferReady" === message.type ? periodList.add(message.value.period) : "periodBufferCleared" === message.type && periodList.removeElement(message.value.period);
                }), Object(share.a)());
 // trigger warnings when the wanted time is before or after the manifest's
                // segments
                                return Object(merge.a)(currentBuffers$, restartBuffers$, outOfManifest$);
            }
            /**
   * Manage creation and removal of Buffers for consecutive Periods.
   *
   * This function is called recursively for each successive Periods as needed.
   *
   * This function does not guarantee creation/destruction of the right Buffers
   * when the user seeks or rewind in the content.
   * It only manages regular playback, another layer should be used to manage
   * those cases.
   *
   * You can know about buffers creation and destruction respectively through
   * the "periodBufferReady" and "periodBufferCleared" events.
   *
   * The "periodBufferReady" related to the given period should be sent synchronously
   * on subscription.
   * Further "periodBufferReady" for further Periods should be sent each time the
   * Buffer for the previous Buffer is full.
   *
   * Buffers for each Period are cleared ("periodBufferCleared" event) either:
   *   - when it has finished to play (currentTime is after it)
   *   - when one of the older Buffers becomes active again, in which case the
   *     Buffers coming after will be cleared from the newest to the oldest.
   *   - when the destroy$ observable emits, in which case every created Buffer
   *     here will be cleared from the newest to the oldest.
   *
   * TODO The code here can surely be greatly simplified.
   * @param {string} bufferType - e.g. "audio" or "video"
   * @param {Period} basePeriod - Initial Period downloaded.
   * @param {Observable} destroy$ - Emit when/if all created Buffer from this
   * point should be destroyed.
   * @returns {Observable}
   */            function manageConsecutivePeriodBuffers(bufferType, basePeriod, destroy$) {
                log.a.info("Buffer: Creating new Buffer for", bufferType, basePeriod);
                // Emits the chosen adaptation for the current type.
                var adaptation$ = new ReplaySubject.a(1), createNextPeriodBuffer$ = new Subject.a(), destroyNextBuffers$ = new Subject.a(), endOfCurrentBuffer$ = clock$.pipe(Object(filter.a)(function(_ref5) {
                    var currentTime = _ref5.currentTime, wantedTimeOffset = _ref5.wantedTimeOffset;
                    return !!basePeriod.end && currentTime + wantedTimeOffset >= basePeriod.end;
                })), nextPeriodBuffer$ = createNextPeriodBuffer$.pipe(exhaustMap(function(nextPeriod) {
                    return manageConsecutivePeriodBuffers(bufferType, nextPeriod, destroyNextBuffers$);
                })), destroyAll$ = destroy$.pipe(Object(take.a)(1), Object(tap.a)(function() {
                    // first complete createNextBuffer$ to allow completion of the
                    // nextPeriodBuffer$ observable once every further Buffers have been
                    // cleared.
                    createNextPeriodBuffer$.complete(), // emit destruction signal to the next Buffer first
                    destroyNextBuffers$.next(), destroyNextBuffers$.complete();
                }), Object(share.a)()), killCurrentBuffer$ = Object(merge.a)(endOfCurrentBuffer$, destroyAll$), periodBuffer$ = createPeriodBuffer(bufferType, basePeriod, adaptation$).pipe(Object(mergeMap.a)(function(evt) {
                    var type = evt.type;
                    if ("full-buffer" === type) {
                        var nextPeriod = manifest.getPeriodAfter(basePeriod);
                        if (null == nextPeriod) return Object(of.a)(buffer_events_generators.bufferComplete(bufferType));
                        // current buffer is full, create the next one if not
                        createNextPeriodBuffer$.next(nextPeriod);
                    } else "active-buffer" === type && 
                    // current buffer is active, destroy next buffer if created
                    destroyNextBuffers$.next();
                    return Object(of.a)(evt);
                }), Object(share.a)()), currentBuffer$ = Object(concat.a)(Object(of.a)(buffer_events_generators.periodBufferReady(bufferType, basePeriod, adaptation$)), periodBuffer$.pipe(Object(takeUntil.a)(killCurrentBuffer$)), Object(of.a)(buffer_events_generators.periodBufferCleared(bufferType, basePeriod)).pipe(Object(tap.a)(function() {
                    log.a.info("Buffer: Destroying buffer for", bufferType, basePeriod);
                })));
 // Emits the Period of the next Period Buffer when it can be created.
                                return Object(merge.a)(currentBuffer$, nextPeriodBuffer$, destroyAll$.pipe(Object(ignoreElements.a)()));
            }
            /**
   * Create single PeriodBuffer Observable:
   *   - Lazily create (or reuse) a SourceBuffer for the given type.
   *   - Create a Buffer linked to an Adaptation each time it changes, to
   *     download and append the corresponding Segments in the SourceBuffer.
   *   - Announce when the Buffer is full or is awaiting new Segments through
   *     events
   *
   * /!\ This Observable has multiple side-effects (creation of SourceBuffers,
   * downloading and appending of Segments etc.) on subscription.
   *
   * @param {string} bufferType
   * @param {Period} period - The period concerned
   * @param {Observable} adaptation$ - Emit the chosen adaptation.
   * Emit null to deactivate a type of adaptation
   * @returns {Observable}
   */            function createPeriodBuffer(bufferType, period, adaptation$) {
                return adaptation$.pipe(Object(switchMap.a)(function(adaptation) {
                    if (null == adaptation) {
                        log.a.info("Buffer: Set no " + bufferType + " Adaptation", period);
                        var cleanBuffer$, previousQSourceBuffer = sourceBufferManager.get(bufferType);
                        return cleanBuffer$ = null != previousQSourceBuffer ? (log.a.info("Buffer: Clearing previous " + bufferType + " SourceBuffer"), 
                        previousQSourceBuffer.removeBuffer(period.start, period.end || Infinity)) : Object(of.a)(null), 
                        Object(concat.a)(cleanBuffer$.pipe(Object(mapTo.a)(buffer_events_generators.adaptationChange(bufferType, null, period))), createFakeAdaptationBuffer(clock$, wantedBufferAhead$, bufferType, {
                            manifest: manifest,
                            period: period
                        }));
                    }
                    log.a.info("Buffer: Updating " + bufferType + " adaptation", adaptation, period);
                    var newBuffer$ = clock$.pipe(Object(take.a)(1), Object(mergeMap.a)(function(tick) {
                        var qSourceBuffer = createOrReuseQueuedSourceBuffer(bufferType, adaptation), strategy = getAdaptationSwitchStrategy(qSourceBuffer.getBuffered(), period, bufferType, tick);
                        if ("reload-stream" === strategy.type) return Object(of.a)(buffer_events_generators.needsStreamReload());
                        var cleanBuffer$ = "clean-buffer" === strategy.type ? concat.a.apply(void 0, strategy.value.map(function(_ref6) {
                            var start = _ref6.start, end = _ref6.end;
                            return qSourceBuffer.removeBuffer(start, end);
                        })).pipe(Object(ignoreElements.a)()) : empty.a, bufferGarbageCollector$ = garbageCollectors.get(qSourceBuffer), adaptationBuffer$ = createAdaptationBuffer(bufferType, period, adaptation, qSourceBuffer);
                        return Object(concat.a)(cleanBuffer$, Object(merge.a)(adaptationBuffer$, bufferGarbageCollector$));
                    }));
                    return Object(concat.a)(Object(of.a)(buffer_events_generators.adaptationChange(bufferType, adaptation, period)), newBuffer$);
                }));
            }
            /**
   * @param {string} bufferType
   * @param {Object} adaptation
   * @returns {Object}
   */            function createOrReuseQueuedSourceBuffer(bufferType, adaptation) {
                var currentQSourceBuffer = sourceBufferManager.get(bufferType);
                if (null != currentQSourceBuffer) return log.a.info("Buffer: Reusing a previous SourceBuffer for the type", bufferType), 
                currentQSourceBuffer;
                var codec = getFirstDeclaredMimeType(adaptation), sbOptions = "text" === bufferType ? options.textTrackOptions : void 0;
                return sourceBufferManager.createSourceBuffer(bufferType, codec, sbOptions);
            }
            /**
   * @param {string} bufferType
   * @param {Object} period
   * @param {Object} adaptation
   * @param {Object} qSourceBuffer
   * @returns {Observable}
   */            function createAdaptationBuffer(bufferType, period, adaptation, qSourceBuffer) {
                var segmentBookkeeper = segmentBookkeepers.get(qSourceBuffer), pipelineOptions = getPipelineOptions(bufferType, options.segmentRetry, options.offlineRetry), pipeline = segmentPipelinesManager.createPipeline(bufferType, pipelineOptions);
                return AdaptationBuffer(clock$, qSourceBuffer, segmentBookkeeper, pipeline, wantedBufferAhead$, {
                    manifest: manifest,
                    period: period,
                    adaptation: adaptation
                }, abrManager, options).pipe(Object(catchError.a)(function(error) {
                    // non native buffer should not impact the stability of the
                    // player. ie: if a text buffer sends an error, we want to
                    // continue streaming without any subtitles
                    if (!source_buffers_SourceBufferManager.isNative(bufferType)) return log.a.error("Buffer: Custom " + bufferType + " buffer crashed. Aborting it.", error), 
                    sourceBufferManager.disposeSourceBuffer(bufferType), Object(concat.a)(Object(of.a)(buffer_events_generators.warning(error)), createFakeAdaptationBuffer(clock$, wantedBufferAhead$, bufferType, {
                        manifest: manifest,
                        period: period
                    }));
                    throw log.a.error("Buffer: Native " + bufferType + " buffer crashed. Stopping playback.", error), 
                    error;
                }));
            }
        };
        // CONCATENATED MODULE: ./src/core/stream/create_buffer_clock.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create clock Observable for the Buffer.
 * @param {Object} manifest
 * @param {Observable} streamClock$
 * @param {Observable} initialSeek$
 * @param {Number} startTime
 * @returns {Observable}
 */        function createBufferClock(manifest, streamClock$, initialSeek$, speed$, startTime) {
            /**
   * wantedTimeOffset is an offset to add to the timing's current time to have
   * the "real" wanted position.
   * For now, this is seen when the media element has not yet seeked to its
   * initial position, the currentTime will most probably be 0 where the
   * effective starting position will be _startTime_.
   * Thus we initially set a wantedTimeOffset equal to startTime.
   * @type {Number}
   */
            var wantedTimeOffset = startTime, updateTimeOffset$ = initialSeek$.pipe(Object(take.a)(1), Object(tap.a)(function() {
                wantedTimeOffset = 0;
            }), // (initial seek performed)
            Object(ignoreElements.a)()), clock$ = Object(combineLatest.a)(streamClock$, speed$).pipe(Object(map.a)(function(_ref) {
                var tick = _ref[0], speed = _ref[1];
                return object_assign_default()({
                    isLive: manifest.isLive,
                    liveGap: manifest.isLive ? manifest.getMaximumPosition() - tick.currentTime : Infinity,
                    wantedTimeOffset: wantedTimeOffset,
                    speed: speed
                }, tick);
            }));
            return Object(merge.a)(clock$, updateTimeOffset$);
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArray.js
                var isArray = __webpack_require__(47), fromArray = __webpack_require__(26);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromArray.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/race.js
        /** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function race() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            if (1 === observables.length) {
                if (!Object(isArray.a)(observables[0])) return observables[0];
                observables = observables[0];
            }
            return Object(fromArray.a)(observables, void 0).lift(new RaceOperator());
        }
        var RaceOperator = /* */ function() {
            function RaceOperator() {}
            return RaceOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new race_RaceSubscriber(subscriber));
            }, RaceOperator;
        }(), race_RaceSubscriber = /* */ function(_super) {
            function RaceSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.hasFirst = !1, _this.observables = [], _this.subscriptions = [], _this;
            }
            return tslib_es6.a(RaceSubscriber, _super), RaceSubscriber.prototype._next = function(observable) {
                this.observables.push(observable);
            }, RaceSubscriber.prototype._complete = function() {
                var observables = this.observables, len = observables.length;
                if (0 === len) this.destination.complete(); else {
                    for (var i = 0; i < len && !this.hasFirst; i++) {
                        var observable = observables[i], subscription = Object(subscribeToResult.a)(this, observable, observable, i);
                        this.subscriptions && this.subscriptions.push(subscription), this.add(subscription);
                    }
                    this.observables = null;
                }
            }, RaceSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                if (!this.hasFirst) {
                    this.hasFirst = !0;
                    for (var i = 0; i < this.subscriptions.length; i++) if (i !== outerIndex) {
                        var subscription = this.subscriptions[i];
                        subscription.unsubscribe(), this.remove(subscription);
                    }
                    this.subscriptions = null;
                }
                this.destination.next(innerValue);
            }, RaceSubscriber;
        }(OuterSubscriber.a), ArgumentOutOfRangeError = __webpack_require__(79);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeLast.js
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
        function takeLast(count) {
            return function takeLastOperatorFunction(source) {
                return 0 === count ? Object(empty.b)() : source.lift(new takeLast_TakeLastOperator(count));
            };
        }
        var takeLast_TakeLastOperator = /* */ function() {
            function TakeLastOperator(total) {
                if (this.total = total, this.total < 0) throw new ArgumentOutOfRangeError.a();
            }
            return TakeLastOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new takeLast_TakeLastSubscriber(subscriber, this.total));
            }, TakeLastOperator;
        }(), takeLast_TakeLastSubscriber = /* */ function(_super) {
            function TakeLastSubscriber(destination, total) {
                var _this = _super.call(this, destination) || this;
                return _this.total = total, _this.ring = new Array(), _this.count = 0, _this;
            }
            return tslib_es6.a(TakeLastSubscriber, _super), TakeLastSubscriber.prototype._next = function(value) {
                var ring = this.ring, total = this.total, count = this.count++;
                ring.length < total ? ring.push(value) : ring[count % total] = value;
            }, TakeLastSubscriber.prototype._complete = function() {
                var destination = this.destination, count = this.count;
                if (0 < count) for (var total = this.count >= this.total ? this.total : this.count, ring = this.ring, i = 0; i < total; i++) {
                    var idx = count++ % total;
                    destination.next(ring[idx]);
                }
                destination.complete();
            }, TakeLastSubscriber;
        }(Subscriber.a);
        //# sourceMappingURL=takeLast.js.map
        // CONCATENATED MODULE: ./src/core/stream/end_of_stream.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get "updating" SourceBuffers from a SourceBufferList.
 * @param {SourceBufferList} sourceBuffers
 * @returns {Array.<SourceBuffer>}
 */
        function getUpdatingSourceBuffers(sourceBuffers) {
            for (var updatingSourceBuffers = [], i = 0; i < sourceBuffers.length; i++) {
                var SourceBuffer = sourceBuffers[i];
                SourceBuffer.updating && updatingSourceBuffers.push(SourceBuffer);
            }
            return updatingSourceBuffers;
        }
        /**
 * Trigger the `endOfStream` method of a MediaSource.
 *
 * If the MediaSource is ended/closed, do not call this method.
 * If SourceBuffers are updating, wait for them to be updated before closing
 * it.
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */        function triggerEndOfStream(mediaSource) {
            return Object(defer.a)(function() {
                if (log.a.debug("Stream: Trying to call endOfStream"), "open" !== mediaSource.readyState) return log.a.debug("Stream: MediaSource not open, cancel endOfStream"), 
                Object(of.a)(null);
                var sourceBuffers = mediaSource.sourceBuffers, updatingSourceBuffers = getUpdatingSourceBuffers(sourceBuffers);
                if (!updatingSourceBuffers.length) return log.a.info("Stream: Triggering end of stream"), 
                mediaSource.endOfStream(), Object(of.a)(null);
                log.a.debug("Stream: Waiting SourceBuffers to be updated before calling endOfStream.");
                var updatedSourceBuffers$ = updatingSourceBuffers.map(function(sourceBuffer) {
                    return Object(events.p)(sourceBuffer).pipe(Object(take.a)(1));
                });
                return race(merge.a.apply(void 0, updatedSourceBuffers$).pipe(takeLast(1)), Object(events.k)(sourceBuffers).pipe(Object(take.a)(1))).pipe(Object(mergeMap.a)(function() {
                    return triggerEndOfStream(mediaSource);
                }));
            });
        }
        /**
 * Trigger the `endOfStream` method of a MediaSource each times it opens.
 * @see triggerEndOfStream
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */        function maintainEndOfStream(mediaSource) {
            return Object(events.n)(mediaSource).pipe(Object(startWith.a)(null), Object(switchMap.a)(function() {
                return triggerEndOfStream(mediaSource);
            }));
        }
        // EXTERNAL MODULE: ./src/core/stream/initial_seek_and_play.ts
                var initial_seek_and_play = __webpack_require__(91), speed_manager = __webpack_require__(104), stalling_manager = __webpack_require__(95);
        // EXTERNAL MODULE: ./src/core/stream/speed_manager.ts + 1 modules
                // CONCATENATED MODULE: ./src/core/stream/stream_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns a function allowing to load or reload the content in arguments into
 * a single or multiple MediaSources.
 * @param {Object} loadStreamArguments
 * @returns {Observable}
 */
        function StreamLoader(_ref) {
            var mediaElement = _ref.mediaElement, manifest = _ref.manifest, clock$ = _ref.clock$, speed$ = _ref.speed$, bufferOptions = _ref.bufferOptions, abrManager = _ref.abrManager, segmentPipelinesManager = _ref.segmentPipelinesManager;
            /**
   * Load the content on the given MediaSource.
   * @param {MediaSource} mediaSource
   * @param {number} initialTime
   * @param {boolean} autoPlay
   */            return function loadStreamOnMediaSource(mediaSource, initialTime, autoPlay) {
                setDurationToMediaSource(mediaSource, manifest.getDuration());
                var initialPeriod = manifest.getPeriodForTime(initialTime);
                if (null == initialPeriod) throw new MediaError.a("MEDIA_STARTING_TIME_NOT_FOUND", null, !0);
 // Creates SourceBufferManager allowing to create and keep track of a single
                // SourceBuffer per type.
                                var sourceBufferManager = new source_buffers_SourceBufferManager(mediaElement, mediaSource);
 // Initialize all native source buffers from the first period at the same
                // time.
                // We cannot lazily create native sourcebuffers since the spec does not
                // allow adding them during playback.
                //
                // From https://w3c.github.io/media-source/#methods
                //    For example, a user agent may throw a QuotaExceededError
                //    exception if the media element has reached the HAVE_METADATA
                //    readyState. This can occur if the user agent's media engine
                //    does not support adding more tracks during playback.
                                createNativeSourceBuffersForPeriod(sourceBufferManager, initialPeriod);
                var _seekAndLoadOnMediaEv = Object(initial_seek_and_play.a)(mediaElement, initialTime, autoPlay), seek$ = _seekAndLoadOnMediaEv.seek$, load$ = _seekAndLoadOnMediaEv.load$, bufferClock$ = createBufferClock(manifest, clock$, seek$, speed$, initialTime), cancelEndOfStream$ = new Subject.a(), buffers$ = core_buffer({
                    manifest: manifest,
                    initialPeriod: initialPeriod
                }, bufferClock$, abrManager, sourceBufferManager, segmentPipelinesManager, bufferOptions).pipe(Object(mergeMap.a)(function(evt) {
                    switch (evt.type) {
                      case "end-of-stream":
                        return log.a.debug("Stream: end-of-stream order received."), maintainEndOfStream(mediaSource).pipe(Object(ignoreElements.a)(), Object(takeUntil.a)(cancelEndOfStream$));

                      case "resume-stream":
                        return log.a.debug("Stream: resume-stream order received."), cancelEndOfStream$.next(null), 
                        empty.a;

                      case "discontinuity-encountered":
                        return source_buffers_SourceBufferManager.isNative(evt.value.bufferType) && (log.a.warn("Stream: Explicit discontinuity seek", evt.value.nextTime), 
                        mediaElement.currentTime = evt.value.nextTime), empty.a;

                      default:
                        return Object(of.a)(evt);
                    }
                })), speedManager$ = Object(speed_manager.a)(mediaElement, speed$, clock$, {
                    pauseWhenStalled: !0
                }).pipe(Object(map.a)(events_generators.a.speedChanged)), stallingManager$ = Object(stalling_manager.a)(mediaElement, clock$).pipe(Object(map.a)(events_generators.a.stalled)), loadedEvent$ = load$.pipe(Object(mergeMap.a)(function(evt) {
                    if ("autoplay-blocked" !== evt) return log.a.debug("Stream: Stream is loaded."), 
                    Object(of.a)(events_generators.a.loaded());
                    var error = new MediaError.a("MEDIA_ERR_BLOCKED_AUTOPLAY", null, !1);
                    return Object(of.a)(events_generators.a.warning(error), events_generators.a.loaded());
                }));
                return Object(merge.a)(loadedEvent$, buffers$, speedManager$, stallingManager$).pipe(finalize(function() {
                    // clean-up every created SourceBuffers
                    sourceBufferManager.disposeAll();
                }));
            };
            /**
   * Create all native SourceBuffers needed for a given Period.
   *
   * Native Buffers have the particulary to need to be created at the beginning of
   * the content.
   * Custom source buffers (entirely managed in JS) can generally be created and
   * disposed at will during the lifecycle of the content.
   * @param {SourceBufferManager} sourceBufferManager
   * @param {Period} period
   */            function createNativeSourceBuffersForPeriod(sourceBufferManager, period) {
                Object.keys(period.adaptations).forEach(function(bufferType) {
                    if (source_buffers_SourceBufferManager.isNative(bufferType)) {
                        var adaptations = period.adaptations[bufferType] || [], representations = adaptations ? adaptations[0].representations : [];
                        if (representations.length) {
                            var codec = representations[0].getMimeTypeString();
                            sourceBufferManager.createSourceBuffer(bufferType, codec);
                        }
                    }
                });
            }
        }
        // CONCATENATED MODULE: ./src/core/stream/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns pipeline options based on the global config and the user config.
 * @param {Object} networkConfig
 * @returns {Object}
 */        function getManifestPipelineOptions(networkConfig) {
            return {
                maxRetry: null != networkConfig.manifestRetry ? networkConfig.manifestRetry : config.a.DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
                maxRetryOffline: null != networkConfig.offlineRetry ? networkConfig.offlineRetry : config.a.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR
            };
        }
        /**
 * Central part of the player. Play a given stream described by the given
 * manifest with given options.
 *
 * On subscription:
 *  - Creates the MediaSource and attached sourceBuffers instances.
 *  - download the content's manifest
 *  - Perform EME management if needed
 *  - get Buffers for each active adaptations.
 *  - give choice of the adaptation to the caller (e.g. to choose a language)
 *  - returns Observable emitting notifications about the stream lifecycle.
 * @param {Object} args
 * @returns {Observable}
 */        function Stream(_ref) {
            var adaptiveOptions = _ref.adaptiveOptions, autoPlay = _ref.autoPlay, bufferOptions = _ref.bufferOptions, clock$ = _ref.clock$, keySystems = _ref.keySystems, mediaElement = _ref.mediaElement, networkConfig = _ref.networkConfig, speed$ = _ref.speed$, startAt = _ref.startAt, textTrackOptions = _ref.textTrackOptions, transport = _ref.transport, url = _ref.url, warning$ = new Subject.a(), fetchManifest = throttle(createManifestPipeline(transport, getManifestPipelineOptions(networkConfig), warning$)), network$ = new Subject.a(), requestsInfos$ = new Subject.a(), segmentPipelinesManager = new segment_SegmentPipelinesManager(transport.pipelines, requestsInfos$, network$, warning$), abrManager = new abr_ABRManager(requestsInfos$, network$, adaptiveOptions), emeManager$ = Object(create_eme_manager.a)(mediaElement, keySystems), mediaErrorManager$ = Object(media_error_manager.a)(mediaElement), updatedManifest$ = new ReplaySubject.a(1), stream$ = Object(combineLatest.a)(openMediaSource(mediaElement), fetchManifest(url)).pipe(Object(mergeMap.a)(function(_ref2) {
                var mediaSource = _ref2[0], _ref2$ = _ref2[1], manifest = _ref2$.manifest, sendingTime = _ref2$.sendingTime;
                /**
     * @returns {Observable}
     */                function refreshManifest() {
                    var refreshURL = manifest.getUrl();
                    return refreshURL ? fetchManifest(refreshURL).pipe(Object(map.a)(function(_ref3) {
                        var newManifest = _ref3.manifest, newSendingTime = _ref3.sendingTime;
                        return manifest.update(newManifest), events_generators.a.manifestUpdate(manifest, newSendingTime);
                    }), Object(tap.a)(function(evt) {
                        return updatedManifest$.next(evt.value);
                    }), Object(share.a)()) : (log.a.warn("Stream: Cannot refresh the manifest: no url"), 
                    empty.a);
                }
                var loadStream = StreamLoader({
                    mediaElement: mediaElement,
                    manifest: manifest,
                    clock$: clock$,
                    speed$: speed$,
                    abrManager: abrManager,
                    segmentPipelinesManager: segmentPipelinesManager,
                    bufferOptions: object_assign_default()({
                        textTrackOptions: textTrackOptions,
                        offlineRetry: networkConfig.offlineRetry,
                        segmentRetry: networkConfig.segmentRetry
                    }, bufferOptions)
                });
                log.a.debug("Stream: Calculating initial time");
                var initialTime = getInitialTime(manifest, startAt);
                log.a.debug("Stream: Initial time calculated:", initialTime);
                var reloadStreamSubject$ = new Subject.a(), onStreamLoaderEvent = streamLoaderEventProcessor(reloadStreamSubject$, refreshManifest), reloadStream$ = reloadStreamSubject$.pipe(Object(switchMap.a)(function() {
                    var currentPosition = mediaElement.currentTime, isPaused = mediaElement.paused;
                    return openMediaSource(mediaElement).pipe(Object(mergeMap.a)(function(newMS) {
                        return loadStream(newMS, currentPosition, !isPaused);
                    }), Object(mergeMap.a)(onStreamLoaderEvent), Object(startWith.a)(events_generators.a.reloadingStream()));
                })), initialLoad$ = Object(concat.a)(Object(of.a)(events_generators.a.manifestReady(abrManager, manifest)), loadStream(mediaSource, initialTime, autoPlay).pipe(Object(takeUntil.a)(reloadStreamSubject$), Object(mergeMap.a)(onStreamLoaderEvent))), manifestUpdateTimeout$ = updatedManifest$.pipe(Object(startWith.a)({
                    manifest: manifest,
                    sendingTime: sendingTime
                }), Object(switchMap.a)(function(_ref4) {
                    var newManifest = _ref4.manifest, newSendingTime = _ref4.sendingTime;
                    if (newManifest.lifetime) {
                        var timeSinceRequest = null == newSendingTime ? 0 : performance.now() - newSendingTime, updateTimeout = 1e3 * newManifest.lifetime - timeSinceRequest;
                        return Object(timer.a)(updateTimeout);
                    }
                    return empty.a;
                }));
                return Object(merge.a)(initialLoad$, reloadStream$, manifestUpdateTimeout$.pipe(Object(mergeMap.a)(refreshManifest)));
            }));
            // Subject through which warnings will be sent
                        return Object(merge.a)(stream$, mediaErrorManager$, emeManager$, warning$.pipe(Object(map.a)(events_generators.a.warning)));
        }
        /**
 * Generate function reacting to StreamLoader events.
 * @param {Subject} reloadStreamSubject$
 * @param {Function} refreshManifest
 * @returns {Function}
 */        function streamLoaderEventProcessor(reloadStreamSubject$, refreshManifest) {
            /**
   * React to StreamLoader events.
   * @param {Object} evt
   * @returns {Observable}
   */
            return function onStreamLoaderEvent(evt) {
                switch (evt.type) {
                  case "needs-stream-reload":
                    reloadStreamSubject$.next();
                    break;

                  case "needs-manifest-refresh":
                    return refreshManifest();
                }
                return Object(of.a)(evt);
            };
        }
        // CONCATENATED MODULE: ./src/core/api/clock.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file defines a global clock for the RxPlayer.
 *
 * Each clock tick also pass informations about the current state of the
 * media element to sub-parts of the player.
 */        function isMediaInfoState(state) {
            return "init" === state || "canplay" === state || "play" === state || "progress" === state || "seeking" === state || "seeked" === state || "loadedmetadata" === state || "ratechange" === state || "timeupdate" === state;
        }
        var SAMPLING_INTERVAL_MEDIASOURCE = config.a.SAMPLING_INTERVAL_MEDIASOURCE, SAMPLING_INTERVAL_NO_MEDIASOURCE = config.a.SAMPLING_INTERVAL_NO_MEDIASOURCE, RESUME_GAP_AFTER_SEEKING = config.a.RESUME_GAP_AFTER_SEEKING, RESUME_GAP_AFTER_NOT_ENOUGH_DATA = config.a.RESUME_GAP_AFTER_NOT_ENOUGH_DATA, RESUME_GAP_AFTER_BUFFERING = config.a.RESUME_GAP_AFTER_BUFFERING, STALL_GAP = config.a.STALL_GAP, SCANNED_MEDIA_ELEMENTS_EVENTS = [ "canplay", "play", "progress", "seeking", "seeked", "loadedmetadata", "ratechange" ];
        /**
 * HTMLMediaElement Events for which timings are calculated and emitted.
 * @type {Array.<string>}
 */        
        /**
 * Returns the amount of time in seconds the buffer should have ahead of the
 * current position before resuming playback. Based on the infos of the stall.
 * Waiting time differs between a "seeking" stall and a buffering stall.
 * @param {Object|null} stalled
 * @returns {Number}
 */
        function getResumeGap(stalled) {
            if (!stalled) return 0;
            switch (stalled.reason) {
              case "seeking":
                return RESUME_GAP_AFTER_SEEKING;

              case "not-ready":
                return RESUME_GAP_AFTER_NOT_ENOUGH_DATA;

              default:
                return RESUME_GAP_AFTER_BUFFERING;
            }
        }
        /**
 * @param {Object} currentRange
 * @param {Number} duration
 * @returns {Boolean}
 */        function hasLoadedUntilTheEnd(currentRange, duration) {
            return null != currentRange && duration - currentRange.end <= STALL_GAP;
        }
        /**
 * Generate a basic timings object from the media element and the eventName
 * which triggered the request.
 * @param {HTMLMediaElement} mediaElement
 * @param {string} currentState
 * @returns {Object}
 */        function getMediaInfos(mediaElement, currentState) {
            var buffered = mediaElement.buffered, currentTime = mediaElement.currentTime, duration = mediaElement.duration, ended = mediaElement.ended, paused = mediaElement.paused, playbackRate = mediaElement.playbackRate, readyState = mediaElement.readyState, seeking = mediaElement.seeking;
            return {
                bufferGap: Object(utils_ranges.c)(buffered, currentTime),
                buffered: buffered,
                currentRange: Object(utils_ranges.f)(buffered, currentTime),
                currentTime: currentTime,
                duration: duration,
                ended: ended,
                paused: paused,
                playbackRate: playbackRate,
                readyState: readyState,
                seeking: seeking,
                state: currentState
            };
        }
        /**
 * Infer stalled status of the media based on:
 *   - the return of the function getMediaInfos
 *   - the previous timings object.
 *
 * @param {Object} prevTimings - Previous timings object. See function to know
 * the different properties needed.
 * @param {Object} currentTimings - Current timings object. This does not need
 * to have every single infos, see function to know which properties are needed.
 * @param {Boolean} withMediaSource - False if the directfile API is used.
 * @returns {Object|null}
 */        function getStalledStatus(prevTimings, currentTimings, withMediaSource) {
            var shouldStall, shouldUnstall, currentState = currentTimings.state, currentTime = currentTimings.currentTime, bufferGap = currentTimings.bufferGap, currentRange = currentTimings.currentRange, duration = currentTimings.duration, paused = currentTimings.paused, readyState = currentTimings.readyState, ended = currentTimings.ended, prevStalled = prevTimings.stalled, prevState = prevTimings.state, prevTime = prevTimings.currentTime, fullyLoaded = hasLoadedUntilTheEnd(currentRange, duration), canStall = 1 <= readyState && "loadedmetadata" !== currentState && !prevStalled && !(fullyLoaded || ended);
            return withMediaSource ? canStall && (bufferGap <= STALL_GAP || Infinity === bufferGap || 1 === readyState) ? shouldStall = !0 : prevStalled && 1 < readyState && bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled) || fullyLoaded || ended) && (shouldUnstall = !0) : canStall && (!paused && "timeupdate" === currentState && "timeupdate" === prevState && currentTime === prevTime || "seeking" === currentState && Infinity === bufferGap) ? shouldStall = !0 : prevStalled && ("seeking" !== currentState && currentTime !== prevTime || "canplay" === currentState || bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled) || fullyLoaded || ended)) && (shouldUnstall = !0), 
            shouldStall ? {
                reason: "seeking" === currentState || currentTimings.seeking ? "seeking" : 1 === readyState ? "not-ready" : "buffering",
                timestamp: performance.now()
            } : shouldUnstall ? null : prevStalled;
        }
        /**
 * Timings observable.
 *
 * This streams samples snapshots of player's current state:
 *   * time position
 *   * playback rate
 *   * current buffered range
 *   * gap with current buffered range ending
 *   * media duration
 *
 * In addition to sampling, this stream also reacts to "seeking" and "play"
 * events.
 *
 * Observable is shared for performance reason: reduces the number of event
 * listeners and intervals/timeouts but also limit access to the media element
 * properties and gap calculations.
 *
 * The sampling is manual instead of based on "timeupdate" to reduce the
 * number of events.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} options
 * @returns {Observable}
 */        
        /* harmony default export */ var api_clock = function createClock(mediaElement, _ref) {
            var withMediaSource = _ref.withMediaSource;
            return Observable.a.create(function(obs) {
                var lastTimings = object_assign_default()(getMediaInfos(mediaElement, "init"), {
                    stalled: null
                });
                /**
     * Emit timings sample.
     * Meant to be used as a callback on various async events.
     * @param {Event} [evt] - The Event which triggered the callback, if one.
     */                function emitSample(evt) {
                    var state = evt && isMediaInfoState(evt.type) ? evt.type : "timeupdate", mediaTimings = getMediaInfos(mediaElement, state), stalledState = getStalledStatus(lastTimings, mediaTimings, withMediaSource);
                    // /!\ Mutate mediaTimings
                    lastTimings = object_assign_default()(mediaTimings, {
                        stalled: stalledState
                    }), log.a.debug("API: new clock tick", lastTimings), obs.next(lastTimings);
                }
                var intervalID = setInterval(emitSample, withMediaSource ? SAMPLING_INTERVAL_MEDIASOURCE : SAMPLING_INTERVAL_NO_MEDIASOURCE);
                return SCANNED_MEDIA_ELEMENTS_EVENTS.forEach(function(eventName) {
                    return mediaElement.addEventListener(eventName, emitSample);
                }), obs.next(lastTimings), function() {
                    clearInterval(intervalID), SCANNED_MEDIA_ELEMENTS_EVENTS.forEach(function(eventName) {
                        return mediaElement.removeEventListener(eventName, emitSample);
                    });
                };
            }).pipe(Object(multicast.a)(function() {
                return new ReplaySubject.a(1);
            }), // Always emit the last
            Object(refCount.a)());
        }, PLAYER_STATES_STOPPED = "STOPPED", PLAYER_STATES_LOADED = "LOADED", PLAYER_STATES_LOADING = "LOADING", PLAYER_STATES_PLAYING = "PLAYING", PLAYER_STATES_PAUSED = "PAUSED", PLAYER_STATES_ENDED = "ENDED", PLAYER_STATES_BUFFERING = "BUFFERING", PLAYER_STATES_SEEKING = "SEEKING", PLAYER_STATES_RELOADING = "RELOADING";
        // CONCATENATED MODULE: ./src/core/api/constants.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file declares constants useful for every API files.
 */
        /**
 * Player state dictionnary
 * @type {Object}
 */        
        // CONCATENATED MODULE: ./src/core/api/from_wallclock_time.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {number} timeInMs
 * @param {Object} manifest
 * @returns {number}
 */
        function fromWallClockTime(timeInMs, manifest) {
            return normalizeWallClockTime(timeInMs, manifest) / 1e3 - (manifest.availabilityStartTime || 0);
        }
        /**
 * @param {number|date}
 * @param {Object} manifest
 * @retunrs {number}
 */        function normalizeWallClockTime(_time, manifest) {
            if (!manifest.isLive) return +_time;
            var spd = manifest.suggestedPresentationDelay || 0, plg = manifest.presentationLiveGap || 0, tsbd = manifest.timeShiftBufferDepth || 0, timeInMs = "number" == typeof _time ? _time : +_time, now = Date.now(), max = now - 1e3 * (plg + spd), min = now - 1e3 * tsbd;
            return Math.max(Math.min(timeInMs, max), min);
        }
        // CONCATENATED MODULE: ./src/core/api/get_player_state.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var FORCED_ENDED_THRESHOLD = config.a.FORCED_ENDED_THRESHOLD;
        /**
 * Get state string for a loaded content.
 * @param {HTMLMediaElement} mediaElement
 * @param {boolean} isPlaying - false when the player is paused. true otherwise.
 * @param {Object} stalledStatus - Current stalled state:
 *   - null when not stalled
 *   - an object with a description of the situation if stalled.
 * @returns {string}
 */        function getLoadedContentState(mediaElement, isPlaying, stalledStatus) {
            if (mediaElement.ended) return PLAYER_STATES_ENDED;
            if (stalledStatus) {
                // On some old browsers (e.g. Chrome 54), the browser does not
                // emit an 'ended' event in some conditions. Detect if we
                // reached the end by comparing the current position and the
                // duration instead.
                var gapBetweenDurationAndCurrentTime = Math.abs(mediaElement.duration - mediaElement.currentTime);
                return null != FORCED_ENDED_THRESHOLD && gapBetweenDurationAndCurrentTime < FORCED_ENDED_THRESHOLD ? PLAYER_STATES_ENDED : "seeking" === stalledStatus.reason ? PLAYER_STATES_SEEKING : PLAYER_STATES_BUFFERING;
            }
            return isPlaying ? PLAYER_STATES_PLAYING : PLAYER_STATES_PAUSED;
        }
        // CONCATENATED MODULE: ./src/core/api/option_parsers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file exports various helpers to parse options given to various APIs,
 * throw if something is wrong, and return a normalized option object.
 */        var DEFAULT_AUTO_PLAY = config.a.DEFAULT_AUTO_PLAY, DEFAULT_INITIAL_BITRATES = config.a.DEFAULT_INITIAL_BITRATES, DEFAULT_LIMIT_VIDEO_WIDTH = config.a.DEFAULT_LIMIT_VIDEO_WIDTH, DEFAULT_MANUAL_BITRATE_SWITCHING_MODE = config.a.DEFAULT_MANUAL_BITRATE_SWITCHING_MODE, DEFAULT_MAX_BITRATES = config.a.DEFAULT_MAX_BITRATES, DEFAULT_MAX_BUFFER_AHEAD = config.a.DEFAULT_MAX_BUFFER_AHEAD, DEFAULT_MAX_BUFFER_BEHIND = config.a.DEFAULT_MAX_BUFFER_BEHIND, DEFAULT_SHOW_NATIVE_SUBTITLE = config.a.DEFAULT_SHOW_NATIVE_SUBTITLE, DEFAULT_TEXT_TRACK_MODE = config.a.DEFAULT_TEXT_TRACK_MODE, DEFAULT_THROTTLE_WHEN_HIDDEN = config.a.DEFAULT_THROTTLE_WHEN_HIDDEN, DEFAULT_WANTED_BUFFER_AHEAD = config.a.DEFAULT_WANTED_BUFFER_AHEAD;
        /**
 * Parse options given to the API constructor and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 * @param {Object|undefined} options
 * @returns {Object}
 */        function parseConstructorOptions(options) {
            var maxBufferAhead, maxBufferBehind, wantedBufferAhead, limitVideoWidth, throttleWhenHidden, videoElement, initialVideoBitrate, initialAudioBitrate, maxAudioBitrate, maxVideoBitrate, stopAtEnd;
            if (null == options.maxBufferAhead) maxBufferAhead = DEFAULT_MAX_BUFFER_AHEAD; else if (maxBufferAhead = Number(options.maxBufferAhead), 
            isNaN(maxBufferAhead)) throw new Error("Invalid maxBufferAhead parameter. Should be a number.");
            if (null == options.maxBufferBehind) maxBufferBehind = DEFAULT_MAX_BUFFER_BEHIND; else if (maxBufferBehind = Number(options.maxBufferBehind), 
            isNaN(maxBufferBehind)) throw new Error("Invalid maxBufferBehind parameter. Should be a number.");
            if (null == options.wantedBufferAhead) wantedBufferAhead = DEFAULT_WANTED_BUFFER_AHEAD; else if (wantedBufferAhead = Number(options.wantedBufferAhead), 
            isNaN(wantedBufferAhead)) 
            /* tslint:disable:max-line-length */
            throw new Error("Invalid wantedBufferAhead parameter. Should be a number.");
            /* tslint:enable:max-line-length */            if (limitVideoWidth = null == options.limitVideoWidth ? DEFAULT_LIMIT_VIDEO_WIDTH : !!options.limitVideoWidth, 
            throttleWhenHidden = null == options.throttleWhenHidden ? DEFAULT_THROTTLE_WHEN_HIDDEN : !!options.throttleWhenHidden, 
            null == options.videoElement) videoElement = document.createElement("video"); else {
                if (!(options.videoElement instanceof HTMLMediaElement)) 
                /* tslint:disable:max-line-length */
                throw new Error("Invalid videoElement parameter. Should be a HTMLMediaElement.");
                /* tslint:enable:max-line-length */                videoElement = options.videoElement;
            }
            if (null == options.initialVideoBitrate) initialVideoBitrate = DEFAULT_INITIAL_BITRATES.video; else if (initialVideoBitrate = Number(options.initialVideoBitrate), 
            isNaN(initialVideoBitrate)) 
            /* tslint:disable:max-line-length */
            throw new Error("Invalid initialVideoBitrate parameter. Should be a number.");
            /* tslint:enable:max-line-length */            if (null == options.initialAudioBitrate) initialAudioBitrate = DEFAULT_INITIAL_BITRATES.audio; else if (initialAudioBitrate = Number(options.initialAudioBitrate), 
            isNaN(initialAudioBitrate)) 
            /* tslint:disable:max-line-length */
            throw new Error("Invalid initialAudioBitrate parameter. Should be a number.");
            /* tslint:enable:max-line-length */            if (null == options.maxVideoBitrate) maxVideoBitrate = DEFAULT_MAX_BITRATES.video; else if (maxVideoBitrate = Number(options.maxVideoBitrate), 
            isNaN(maxVideoBitrate)) throw new Error("Invalid maxVideoBitrate parameter. Should be a number.");
            if (null == options.maxAudioBitrate) maxAudioBitrate = DEFAULT_MAX_BITRATES.audio; else if (maxAudioBitrate = Number(options.maxAudioBitrate), 
            isNaN(maxAudioBitrate)) throw new Error("Invalid maxAudioBitrate parameter. Should be a number.");
            if (null == options.stopAtEnd) stopAtEnd = !0; else {
                if ("boolean" != typeof options.stopAtEnd) throw new Error("Invalid stopAtEnd parameter. Should be a boolean.");
                stopAtEnd = options.stopAtEnd;
            }
            return {
                maxBufferAhead: maxBufferAhead,
                maxBufferBehind: maxBufferBehind,
                limitVideoWidth: limitVideoWidth,
                videoElement: videoElement,
                wantedBufferAhead: wantedBufferAhead,
                throttleWhenHidden: throttleWhenHidden,
                initialAudioBitrate: initialAudioBitrate,
                initialVideoBitrate: initialVideoBitrate,
                maxAudioBitrate: maxAudioBitrate,
                maxVideoBitrate: maxVideoBitrate,
                stopAtEnd: stopAtEnd
            };
        }
        /**
 * Parse options given to loadVideo and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 *
 * Throws if any mandatory option is not set.
 * @param {Object|undefined} options
 * @param {Object} ctx - The player context, needed for some default values.
 * @returns {Object}
 */        function parseLoadVideoOptions(options) {
            var url, transport, keySystems, supplementaryTextTracks, supplementaryImageTracks, textTrackMode, textTrackElement, startAt;
            if (!options || null == options.url) throw new Error("No url set on loadVideo");
            if (url = String(options.url), null == options.transport) throw new Error("No transport set on loadVideo");
            transport = String(options.transport);
            var autoPlay = null == options.autoPlay ? DEFAULT_AUTO_PLAY : !!options.autoPlay;
            if (null == options.keySystems) keySystems = []; else {
                var _iterator = keySystems = Array.isArray(options.keySystems) ? options.keySystems : [ options.keySystems ], _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var keySystem = _ref;
                    if ("string" != typeof keySystem.type || "function" != typeof keySystem.getLicense) throw new Error("Invalid key system given: Missing type string or getLicense callback");
                }
            }
            var transportOptions = options.transportOptions || {};
            if (null == options.supplementaryTextTracks) supplementaryTextTracks = []; else {
                var _iterator2 = supplementaryTextTracks = Array.isArray(options.supplementaryTextTracks) ? options.supplementaryTextTracks : [ options.supplementaryTextTracks ], _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var supplementaryTextTrack = _ref2;
                    if ("boolean" != typeof supplementaryTextTrack.closedCaption && (supplementaryTextTrack.closedCaption = !!supplementaryTextTrack.closedCaption), 
                    "string" != typeof supplementaryTextTrack.language || "string" != typeof supplementaryTextTrack.mimeType || "string" != typeof supplementaryTextTrack.url) 
                    /* tslint:disable:max-line-length */
                    throw new Error("Invalid supplementary text track given. Missing either language, mimetype or url");
                    /* tslint:enable:max-line-length */                }
            }
            if (null == options.supplementaryImageTracks) supplementaryImageTracks = []; else {
                var _iterator3 = supplementaryImageTracks = Array.isArray(options.supplementaryImageTracks) ? options.supplementaryImageTracks : [ options.supplementaryImageTracks ], _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var supplementaryImageTrack = _ref3;
                    if ("string" != typeof supplementaryImageTrack.mimeType || "string" != typeof supplementaryImageTrack.url) 
                    /* tslint:disable:max-line-length */
                    throw new Error("Invalid supplementary image track given. Missing either mimetype or url");
                    /* tslint:enable:max-line-length */                }
            }
            if (null == options.textTrackMode) textTrackMode = DEFAULT_TEXT_TRACK_MODE; else {
                if ("native" !== options.textTrackMode && "html" !== options.textTrackMode) throw new Error("Invalid textTrackMode.");
                textTrackMode = options.textTrackMode;
            }
            var defaultAudioTrack = Object(utils_languages.b)(options.defaultAudioTrack), defaultTextTrack = Object(utils_languages.c)(options.defaultTextTrack), hideNativeSubtitle = null == options.hidenativeSubtitle ? !DEFAULT_SHOW_NATIVE_SUBTITLE : !!options.hideNativeSubtitle, manualBitrateSwitchingMode = null == options.manualBitrateSwitchingMode ? !DEFAULT_MANUAL_BITRATE_SWITCHING_MODE : options.manualBitrateSwitchingMode;
            if ("html" === textTrackMode) {
                // TODO Better way to express that in TypeScript?
                if (null == options.textTrackElement) 
                /* tslint:disable:max-line-length */
                throw new Error('You have to provide a textTrackElement in "html" textTrackMode.');
                /* tslint:enable:max-line-length */                if (!(options.textTrackElement instanceof HTMLElement)) throw new Error("textTrackElement should be an HTMLElement.");
                textTrackElement = options.textTrackElement;
            } else null != options.textTrackElement && 
            /* tslint:disable:max-line-length */
            log.a.warn('API: You have set a textTrackElement without being in an "html" textTrackMode. It will be ignored.');
            if (null != options.startAt) 
            // TODO Better way to express that in TypeScript?
            if (options.startAt.wallClockTime instanceof Date) {
                var wallClockTime = options.startAt.wallClockTime.getTime() / 1e3;
                startAt = object_assign_default()({}, options.startAt, {
                    wallClockTime: wallClockTime
                });
            } else startAt = options.startAt;
            // TODO without cast
            /* tslint:disable no-object-literal-type-assertion */
            return {
                autoPlay: autoPlay,
                defaultAudioTrack: defaultAudioTrack,
                defaultTextTrack: defaultTextTrack,
                hideNativeSubtitle: hideNativeSubtitle,
                keySystems: keySystems,
                manualBitrateSwitchingMode: manualBitrateSwitchingMode,
                networkConfig: null == options.networkConfig ? {} : {
                    manifestRetry: options.networkConfig.manifestRetry,
                    offlineRetry: options.networkConfig.offlineRetry,
                    segmentRetry: options.networkConfig.segmentRetry
                },
                startAt: startAt,
                supplementaryImageTracks: supplementaryImageTracks,
                supplementaryTextTracks: supplementaryTextTracks,
                textTrackElement: textTrackElement,
                textTrackMode: textTrackMode,
                transport: transport,
                transportOptions: transportOptions,
                url: url
            };
            /* tslint:enable no-object-literal-type-assertion */        }
        // CONCATENATED MODULE: ./src/core/api/track_manager.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file is used to abstract the notion of text and audio tracks switching
 * for an easier API management.
 */
        /**
 * Manage audio and text tracks for all active periods.
 * Chose the audio and text tracks for each period and record this choice.
 * @class TrackManager
 */        var track_manager_TrackManager = 
        /* */
        function() {
            /**
   * @param {Object} defaults
   */
            function TrackManager(defaults) {
                void 0 === defaults && (defaults = {});
                var _defaults = defaults, preferredAudioTracks = _defaults.preferredAudioTracks, preferredTextTracks = _defaults.preferredTextTracks;
                this._periods = new sorted_list_SortedList(function(a, b) {
                    return a.period.start - b.period.start;
                }), this._audioChoiceMemory = new WeakMap(), this._textChoiceMemory = new WeakMap(), 
                this._videoChoiceMemory = new WeakMap(), this._preferredAudioTracks = preferredAudioTracks || [], 
                this._preferredTextTracks = preferredTextTracks || [];
            }
            /**
   * Add Subject to choose Adaptation for new "audio" or "text" Period.
   * @param {string} bufferType
   * @param {Period} period
   * @param {Subject} adaptations
   */            var _proto = TrackManager.prototype;
            return _proto.addPeriod = function addPeriod(bufferType, period, adaptation$) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null != periodItem) {
                    if (null != periodItem[bufferType]) return void log.a.warn("TrackManager: " + bufferType + " already added for period", period);
                    periodItem[bufferType] = {
                        adaptations: period.adaptations[bufferType] || [],
                        adaptation$: adaptation$
                    };
                } else {
                    var _this$_periods$add;
                    this._periods.add(((_this$_periods$add = {
                        period: period
                    })[bufferType] = {
                        adaptations: period.adaptations[bufferType] || [],
                        adaptation$: adaptation$
                    }, _this$_periods$add));
                }
            }, 
            /**
   * Remove Subject to choose an "audio" or "text" Adaptation for a Period.
   * @param {string} bufferType
   * @param {Period} period
   */
            _proto.removePeriod = function removePeriod(bufferType, period) {
                var periodIndex = findPeriodIndex(this._periods, period);
                if (null != periodIndex) {
                    var periodItem = this._periods.get(periodIndex);
                    null != periodItem[bufferType] ? (delete periodItem[bufferType], null == periodItem.audio && null == periodItem.text && this._periods.removeElement(periodItem)) : log.a.warn("TrackManager: " + bufferType + " already removed for period", period);
                } else log.a.warn("TrackManager: " + bufferType + " not found for period", period);
            }, _proto.resetPeriods = function resetPeriods() {
                for (;0 < this._periods.length(); ) this._periods.pop();
            }, 
            /**
   * Update the choice of all added Periods based on:
   *   1. What was the last chosen adaptation
   *   2. If not found, the preferences
   */
            _proto.update = function update() {
                this._updateAudioTrackChoices(), this._updateTextTrackChoices(), this._updateVideoTrackChoices();
            }, 
            /**
   * Emit initial audio Adaptation through the given Subject based on:
   *   - the preferred audio tracks
   *   - the last choice for this period, if one
   * @param {Period} period
   *
   * @throws Error - Throws if the period given has not been added
   */
            _proto.setInitialAudioTrack = function setInitialAudioTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (!audioInfos || !periodItem) throw new Error("TrackManager: Given Period not found.");
                var preferredAudioTracks = this._preferredAudioTracks, audioAdaptations = period.adaptations.audio || [], chosenAudioAdaptation = this._audioChoiceMemory.get(period);
                if (void 0 !== chosenAudioAdaptation && Object(array_includes.a)(audioAdaptations, chosenAudioAdaptation)) audioInfos.adaptation$.next(chosenAudioAdaptation); else {
                    var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks);
                    this._audioChoiceMemory.set(period, optimalAdaptation), audioInfos.adaptation$.next(optimalAdaptation);
                }
            }, 
            /**
   * Emit initial text Adaptation through the given Subject based on:
   *   - the preferred text tracks
   *   - the last choice for this period, if one
   * @param {Period} period
   *
   * @throws Error - Throws if the period given has not been added
   */
            _proto.setInitialTextTrack = function setInitialTextTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (!textInfos || !periodItem) throw new Error("TrackManager: Given Period not found.");
                var preferredTextTracks = this._preferredTextTracks, textAdaptations = period.adaptations.text || [], chosenTextAdaptation = this._textChoiceMemory.get(period);
                if (void 0 !== chosenTextAdaptation && Object(array_includes.a)(textAdaptations, chosenTextAdaptation)) textInfos.adaptation$.next(chosenTextAdaptation); else {
                    var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks);
                    this._textChoiceMemory.set(period, optimalAdaptation), textInfos.adaptation$.next(optimalAdaptation);
                }
            }, 
            /**
   * Emit initial video Adaptation through the given Subject based on:
   *   - the preferred video tracks
   *   - the last choice for this period, if one
   * @param {Period} period
   *
   * @throws Error - Throws if the period given has not been added
   */
            _proto.setInitialVideoTrack = function setInitialVideoTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), videoInfos = periodItem && periodItem.video;
                if (!videoInfos || !periodItem) throw new Error("TrackManager: Given Period not found.");
                var videoAdaptations = period.adaptations.video || [], chosenVideoAdaptation = this._videoChoiceMemory.get(period);
                if (void 0 !== chosenVideoAdaptation && Object(array_includes.a)(videoAdaptations, chosenVideoAdaptation)) videoInfos.adaptation$.next(chosenVideoAdaptation); else {
                    var optimalAdaptation = videoAdaptations[0];
                    this._videoChoiceMemory.set(period, optimalAdaptation), videoInfos.adaptation$.next(optimalAdaptation);
                }
            }, 
            /**
   * Set audio track based on the ID of its adaptation for a given added Period.
   *
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   *
   * @throws Error - Throws if the period given has not been added
   * @throws Error - Throws if the given id is not found in any audio adaptation
   * of the given Period.
   */
            _proto.setAudioTrackByID = function setAudioTrackByID(period, wantedId) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (!audioInfos) throw new Error("TrackManager: Given Period not found.");
                var wantedAdaptation = find_default()(audioInfos.adaptations, function(_ref) {
                    return _ref.id === wantedId;
                });
                if (void 0 === wantedAdaptation) throw new Error("Audio Track not found.");
                this._audioChoiceMemory.get(period) !== wantedAdaptation && (this._audioChoiceMemory.set(period, wantedAdaptation), 
                audioInfos.adaptation$.next(wantedAdaptation));
            }, 
            /**
   * Set text track based on the ID of its adaptation for a given added Period.
   *
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   *
   * @throws Error - Throws if the period given has not been added
   * @throws Error - Throws if the given id is not found in any text adaptation
   * of the given Period.
   */
            _proto.setTextTrackByID = function setTextTrackByID(period, wantedId) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (!textInfos) throw new Error("TrackManager: Given Period not found.");
                var wantedAdaptation = find_default()(textInfos.adaptations, function(_ref2) {
                    return _ref2.id === wantedId;
                });
                if (void 0 === wantedAdaptation) throw new Error("Text Track not found.");
                this._textChoiceMemory.get(period) !== wantedAdaptation && (this._textChoiceMemory.set(period, wantedAdaptation), 
                textInfos.adaptation$.next(wantedAdaptation));
            }, 
            /**
   * Set video track based on the ID of its adaptation for a given added Period.
   *
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   *
   * @throws Error - Throws if the period given has not been added
   * @throws Error - Throws if the given id is not found in any video adaptation
   * of the given Period.
   */
            _proto.setVideoTrackByID = function setVideoTrackByID(period, wantedId) {
                var periodItem = getPeriodItem(this._periods, period), videoInfos = periodItem && periodItem.video;
                if (!videoInfos) throw new Error("LanguageManager: Given Period not found.");
                var wantedAdaptation = find_default()(videoInfos.adaptations, function(_ref3) {
                    return _ref3.id === wantedId;
                });
                if (void 0 === wantedAdaptation) throw new Error("Video Track not found.");
                this._videoChoiceMemory.get(period) !== wantedAdaptation && (this._videoChoiceMemory.set(period, wantedAdaptation), 
                videoInfos.adaptation$.next(wantedAdaptation));
            }, 
            /**
   * Disable the given audio track for a given Period.
   *
   * @param {Period} period - The concerned Period.
   *
   * @throws Error - Throws if the period given has not been added
   */
            _proto.disableAudioTrack = function disableAudioTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (!audioInfos) throw new Error("TrackManager: Given Period not found.");
                null !== this._audioChoiceMemory.get(period) && (this._audioChoiceMemory.set(period, null), 
                audioInfos.adaptation$.next(null));
            }, 
            /**
   * Disable the current text track for a given period.
   *
   * @param {Period} period - The concerned Period.
   *
   * @throws Error - Throws if the period given has not been added
   */
            _proto.disableTextTrack = function disableTextTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (!textInfos) throw new Error("TrackManager: Given Period not found.");
                null !== this._textChoiceMemory.get(period) && (this._textChoiceMemory.set(period, null), 
                textInfos.adaptation$.next(null));
            }, 
            /**
   * Returns an object describing the chosen audio track for the given audio
   * Period.
   *
   * Returns null is the the current audio track is disabled or not
   * set yet.
   *
   * @param {Period} period
   * @returns {Object|null}
   */
            _proto.getChosenAudioTrack = function getChosenAudioTrack(period) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null == (periodItem && periodItem.audio)) return null;
                var chosenAudioAdaptation = this._audioChoiceMemory.get(period);
                return chosenAudioAdaptation ? {
                    language: chosenAudioAdaptation.language || "",
                    normalized: chosenAudioAdaptation.normalizedLanguage || "",
                    audioDescription: !!chosenAudioAdaptation.isAudioDescription,
                    id: chosenAudioAdaptation.id
                } : null;
            }, 
            /**
   * Returns an object describing the chosen text track for the given text
   * Period.
   *
   * Returns null is the the current text track is disabled or not
   * set yet.
   *
   * @param {Period} period
   * @returns {Object|null}
   */
            _proto.getChosenTextTrack = function getChosenTextTrack(period) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null == (periodItem && periodItem.text)) return null;
                var chosenTextAdaptation = this._textChoiceMemory.get(period);
                return chosenTextAdaptation ? {
                    language: chosenTextAdaptation.language || "",
                    normalized: chosenTextAdaptation.normalizedLanguage || "",
                    closedCaption: !!chosenTextAdaptation.isClosedCaption,
                    id: chosenTextAdaptation.id
                } : null;
            }, 
            /**
   * Returns an object describing the chosen video track for the given video
   * Period.
   *
   * Returns null is the the current video track is disabled or not
   * set yet.
   *
   * @param {Period} period
   * @returns {Object|null}
   */
            _proto.getChosenVideoTrack = function getChosenVideoTrack(period) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null == (periodItem && periodItem.video)) return null;
                var chosenVideoAdaptation = this._videoChoiceMemory.get(period);
                return chosenVideoAdaptation ? {
                    id: chosenVideoAdaptation.id,
                    representations: chosenVideoAdaptation.representations.map(parseVideoRepresentation)
                } : null;
            }, 
            /**
   * Returns all available audio tracks for a given Period, as an array of
   * objects.
   *
   * @returns {Array.<Object>}
   */
            _proto.getAvailableAudioTracks = function getAvailableAudioTracks(period) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (null == audioInfos) return [];
                var chosenAudioAdaptation = this._audioChoiceMemory.get(period), currentId = chosenAudioAdaptation && chosenAudioAdaptation.id;
                return audioInfos.adaptations.map(function(adaptation) {
                    return {
                        language: adaptation.language || "",
                        normalized: adaptation.normalizedLanguage || "",
                        audioDescription: !!adaptation.isAudioDescription,
                        id: adaptation.id,
                        active: null != currentId && currentId === adaptation.id
                    };
                });
            }, 
            /**
   * Returns all available text tracks for a given Period, as an array of
   * objects.
   *
   * @param {Period} period
   * @returns {Array.<Object>}
   */
            _proto.getAvailableTextTracks = function getAvailableTextTracks(period) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (null == textInfos) return [];
                var chosenTextAdaptation = this._textChoiceMemory.get(period), currentId = chosenTextAdaptation && chosenTextAdaptation.id;
                return textInfos.adaptations.map(function(adaptation) {
                    return {
                        language: adaptation.language || "",
                        normalized: adaptation.normalizedLanguage || "",
                        closedCaption: !!adaptation.isClosedCaption,
                        id: adaptation.id,
                        active: null != currentId && currentId === adaptation.id
                    };
                });
            }, 
            /**
   * Returns all available video tracks for a given Period, as an array of
   * objects.
   *
   * @returns {Array.<Object>}
   */
            _proto.getAvailableVideoTracks = function getAvailableVideoTracks(period) {
                var periodItem = getPeriodItem(this._periods, period), videoInfos = periodItem && periodItem.video;
                if (null == videoInfos) return [];
                var chosenVideoAdaptation = this._videoChoiceMemory.get(period), currentId = chosenVideoAdaptation && chosenVideoAdaptation.id;
                return videoInfos.adaptations.map(function(adaptation) {
                    return {
                        id: adaptation.id,
                        active: null != currentId && currentId === adaptation.id,
                        representations: adaptation.representations.map(parseVideoRepresentation)
                    };
                });
            }, _proto._updateAudioTrackChoices = function _updateAudioTrackChoices() {
                var _this = this, preferredAudioTracks = this._preferredAudioTracks;
                !function recursiveUpdateAudioTrack(index) {
                    if (!(index >= _this._periods.length())) {
                        var periodItem = _this._periods.get(index);
                        if (null != periodItem.audio) {
                            var period = periodItem.period, audioItem = periodItem.audio, audioAdaptations = period.adaptations.audio || [], chosenAudioAdaptation = _this._audioChoiceMemory.get(period);
                            if (null === chosenAudioAdaptation || void 0 !== chosenAudioAdaptation && Object(array_includes.a)(audioAdaptations, chosenAudioAdaptation)) 
                            // Already best audio for this Buffer, check next one
                            recursiveUpdateAudioTrack(index + 1); else {
                                var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks);
                                _this._audioChoiceMemory.set(period, optimalAdaptation), audioItem.adaptation$.next(optimalAdaptation), 
                                // previous "next" call could have changed everything, start over
                                recursiveUpdateAudioTrack(0);
                            }
                        } else 
                        // No audio Buffer for this period, check next one
                        recursiveUpdateAudioTrack(index + 1);
                    }
                }(0);
            }, _proto._updateTextTrackChoices = function _updateTextTrackChoices() {
                var _this2 = this, preferredTextTracks = this._preferredTextTracks;
                !function recursiveUpdateTextTrack(index) {
                    if (!(index >= _this2._periods.length())) {
                        var periodItem = _this2._periods.get(index);
                        if (null != periodItem.text) {
                            var period = periodItem.period, textItem = periodItem.text, textAdaptations = period.adaptations.text || [], chosenTextAdaptation = _this2._textChoiceMemory.get(period);
                            if (null === chosenTextAdaptation || void 0 !== chosenTextAdaptation && Object(array_includes.a)(textAdaptations, chosenTextAdaptation)) 
                            // Already best text for this Buffer, check next one
                            recursiveUpdateTextTrack(index + 1); else {
                                var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks);
                                _this2._textChoiceMemory.set(period, optimalAdaptation), textItem.adaptation$.next(optimalAdaptation), 
                                // previous "next" call could have changed everything, start over
                                recursiveUpdateTextTrack(0);
                            }
                        } else 
                        // No text Buffer for this period, check next one
                        recursiveUpdateTextTrack(index + 1);
                    }
                }(0);
            }, _proto._updateVideoTrackChoices = function _updateVideoTrackChoices() {
                var _this3 = this;
                !function recursiveUpdateVideoTrack(index) {
                    if (!(index >= _this3._periods.length())) {
                        var periodItem = _this3._periods.get(index);
                        if (null != periodItem.video) {
                            var period = periodItem.period, videoItem = periodItem.video, videoAdaptations = period.adaptations.video || [], chosenVideoAdaptation = _this3._videoChoiceMemory.get(period);
                            if (null === chosenVideoAdaptation || void 0 !== chosenVideoAdaptation && Object(array_includes.a)(videoAdaptations, chosenVideoAdaptation)) 
                            // Already best video for this Buffer, check next one
                            recursiveUpdateVideoTrack(index + 1); else {
                                var optimalAdaptation = videoAdaptations[0];
                                _this3._videoChoiceMemory.set(period, optimalAdaptation), videoItem.adaptation$.next(optimalAdaptation), 
                                // previous "next" call could have changed everything, start over
                                recursiveUpdateVideoTrack(0);
                            }
                        } else 
                        // No video Buffer for this period, check next one
                        recursiveUpdateVideoTrack(index + 1);
                    }
                }(0);
            }, TrackManager;
        }();
 // /**
        //  * Returns true if the given audio adaptation is an optimal choice for a period
        //  * given:
        //  *
        //  *   - the list of audio adaptations in the period
        //  *
        //  *   - an array of preferred audio configurations sorted from the most preferred
        //  *     to the least preferred.
        //  *
        //  * @param {Adaptation|null} adaptation
        //  * @param {Array.<Adaptation>} audioAdaptations
        //  * @param {Array.<Object>} preferredAudioTracks
        //  * @returns {Boolean}
        //  */
        // function isAudioAdaptationOptimal(
        //   adaptation : Adaptation|null,
        //   audioAdaptations : Adaptation[],
        //   preferredAudioTracks : IAudioTrackPreference[]
        // ) : boolean {
        //   if (!audioAdaptations.length) {
        //     return adaptation === null;
        //   }
        //   for (let i = 0; i < preferredAudioTracks.length; i++) {
        //     const preferredAudioTrack = preferredAudioTracks[i];
        //     if (preferredAudioTrack === null) {
        //       return adaptation === null;
        //     }
        //     const foundAdaptation = arrayFind(audioAdaptations, (audioAdaptation) =>
        //       audioAdaptation.normalizedLanguage === preferredAudioTrack.normalized &&
        //       !!audioAdaptation.isAudioDescription === preferredAudioTrack.audioDescription
        //     );
        //     if (foundAdaptation !== undefined) {
        //       if (adaptation === null) {
        //         return false;
        //       }
        //       return (
        //         (foundAdaptation.normalizedLanguage || "") ===
        //         (adaptation.normalizedLanguage || "")
        //       ) && !!foundAdaptation.isAudioDescription === !!adaptation.isAudioDescription;
        //     }
        //   }
        //   return true; // no optimal adaptation, just return true
        // }
        /**
 * Find an optimal audio adaptation given their list and the array of preferred
 * audio tracks sorted from the most preferred to the least preferred.
 *
 * null if the most optimal audio adaptation is no audio adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @returns {Adaptation|null}
 */        function findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks) {
            if (!audioAdaptations.length) return null;
            for (var _loop = function _loop(i) {
                var preferredAudioTrack = preferredAudioTracks[i];
                if (null === preferredAudioTrack) return {
                    v: null
                };
                var foundAdaptation = find_default()(audioAdaptations, function(audioAdaptation) {
                    return (audioAdaptation.normalizedLanguage || "") === preferredAudioTrack.normalized && !!audioAdaptation.isAudioDescription === preferredAudioTrack.audioDescription;
                });
                return void 0 !== foundAdaptation ? {
                    v: foundAdaptation
                } : void 0;
            }, i = 0; i < preferredAudioTracks.length; i++) {
                var _ret = _loop(i);
                if ("object" == typeof _ret) return _ret.v;
            }
 // no optimal adaptation, just return the first one
                        return audioAdaptations[0];
        }
 // /**
        //  * Returns true if the given text adaptation is an optimal choice for a period
        //  * given:
        //  *
        //  *   - the list of text adaptations in the period
        //  *
        //  *   - an array of preferred text configurations sorted from the most preferred
        //  *     to the least preferred.
        //  *
        //  * @param {Adaptation|null} adaptation
        //  * @param {Array.<Adaptation>} audioAdaptations
        //  * @param {Array.<Object>} preferredAudioTracks
        //  * @returns {Boolean}
        //  */
        // function isTextAdaptationOptimal(
        //   adaptation : Adaptation|null,
        //   textAdaptations : Adaptation[],
        //   preferredTextTracks : ITextTrackPreference[]
        // ) : boolean {
        //   if (!textAdaptations.length) {
        //     return adaptation === null;
        //   }
        //   for (let i = 0; i < preferredTextTracks.length; i++) {
        //     const preferredTextTrack = preferredTextTracks[i];
        //     if (preferredTextTrack === null) {
        //       return adaptation === null;
        //     }
        //     const foundAdaptation = arrayFind(textAdaptations, (textAdaptation) =>
        //       (textAdaptation.normalizedLanguage || "") === preferredTextTrack.normalized &&
        //       !!textAdaptation.isClosedCaption === preferredTextTrack.closedCaption
        //     );
        //     if (foundAdaptation !== undefined) {
        //       if (adaptation === null) {
        //         return false;
        //       }
        //       return (
        //         (foundAdaptation.normalizedLanguage || "") ===
        //         (adaptation.normalizedLanguage || "")
        //       ) && !!foundAdaptation.isClosedCaption === !!adaptation.isClosedCaption;
        //     }
        //   }
        //   return adaptation === null;
        // }
        /**
 * Find an optimal text adaptation given their list and the array of preferred
 * text tracks sorted from the most preferred to the least preferred.
 *
 * null if the most optimal text adaptation is no text adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @returns {Adaptation|null}
 */        function findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks) {
            if (!textAdaptations.length) return null;
            for (var _loop2 = function _loop2(i) {
                var preferredTextTrack = preferredTextTracks[i];
                if (null === preferredTextTrack) return {
                    v: null
                };
                var foundAdaptation = find_default()(textAdaptations, function(textAdaptation) {
                    return (textAdaptation.normalizedLanguage || "") === preferredTextTrack.normalized && !!textAdaptation.isClosedCaption === preferredTextTrack.closedCaption;
                });
                return void 0 !== foundAdaptation ? {
                    v: foundAdaptation
                } : void 0;
            }, i = 0; i < preferredTextTracks.length; i++) {
                var _ret2 = _loop2(i);
                if ("object" == typeof _ret2) return _ret2.v;
            }
 // no optimal adaptation
                        return null;
        }
        function findPeriodIndex(periods, period) {
            for (var i = 0; i < periods.length(); i++) {
                if (periods.get(i).period.id === period.id) return i;
            }
        }
        function getPeriodItem(periods, period) {
            for (var i = 0; i < periods.length(); i++) {
                var periodI = periods.get(i);
                if (periodI.period.id === period.id) return periodI;
            }
        }
        /**
 * Parse video Representation into a ITMVideoRepresentation.
 * @param {Object} representation
 * @returns {Object}
 */        function parseVideoRepresentation(_ref4) {
            return {
                id: _ref4.id,
                bitrate: _ref4.bitrate,
                frameRate: _ref4.frameRate,
                width: _ref4.width,
                height: _ref4.height,
                codec: _ref4.codec
            };
        }
        // CONCATENATED MODULE: ./src/core/api/index.ts
                function api_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function api_createClass(Constructor, protoProps, staticProps) {
            return protoProps && api_defineProperties(Constructor.prototype, protoProps), staticProps && api_defineProperties(Constructor, staticProps), 
            Constructor;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file and directory defines the public API for the RxPlayer.
 *
 * It also starts the different sub-parts of the player on various API calls.
 */        var DEFAULT_UNMUTED_VOLUME = config.a.DEFAULT_UNMUTED_VOLUME, api_Player = 
        /* */
        function(_EventEmitter) {
            /**
   * @constructor
   * @param {Object} options
   */
            function Player(options) {
                var _this;
                void 0 === options && (options = {}), _this = _EventEmitter.call(this) || this;
                var _parseConstructorOpti = parseConstructorOptions(options), initialAudioBitrate = _parseConstructorOpti.initialAudioBitrate, initialVideoBitrate = _parseConstructorOpti.initialVideoBitrate, limitVideoWidth = _parseConstructorOpti.limitVideoWidth, maxAudioBitrate = _parseConstructorOpti.maxAudioBitrate, maxBufferAhead = _parseConstructorOpti.maxBufferAhead, maxBufferBehind = _parseConstructorOpti.maxBufferBehind, maxVideoBitrate = _parseConstructorOpti.maxVideoBitrate, throttleWhenHidden = _parseConstructorOpti.throttleWhenHidden, videoElement = _parseConstructorOpti.videoElement, wantedBufferAhead = _parseConstructorOpti.wantedBufferAhead, stopAtEnd = _parseConstructorOpti.stopAtEnd;
 // Workaround to support Firefox autoplay on FF 42.
                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1194624
                                return videoElement.preload = "auto", _this.version = 
                /*PLAYER_VERSION*/
                "3.9.2", _this.log = log.a, _this.state = "STOPPED", _this.videoElement = videoElement, 
                _this._priv_destroy$ = new Subject.a(), 
                /** @deprecated */
                Object(events.d)(videoElement).pipe(Object(takeUntil.a)(_this._priv_destroy$))
                /* tslint:disable deprecation */ .subscribe(function() {
                    return _this.trigger("fullscreenChange", _this.isFullscreen());
                }), 
                /* tslint:enable deprecation */
                /** @deprecated */
                Object(events.o)(videoElement.textTracks).pipe(Object(takeUntil.a)(_this._priv_destroy$), Object(map.a)(function(evt) {
                    for (var target = evt.target, arr = [], i = 0; i < target.length; i++) {
                        var textTrack = target[i];
                        arr.push(textTrack);
                    }
                    return arr;
                }), // We can have two consecutive textTrackChanges with the exact same
                // payload when we perform multiple texttrack operations before the event
                // loop is freed.
                // In that case we only want to fire one time the observable.
                Object(distinctUntilChanged.a)(function(textTracksA, textTracksB) {
                    if (textTracksA.length !== textTracksB.length) return !1;
                    for (var i = 0; i < textTracksA.length; i++) if (textTracksA[i] !== textTracksB[i]) return !1;
                    return !0;
                })).subscribe(function(x) {
                    return _this._priv_onNativeTextTracksNext(x);
                }), _this._priv_playing$ = new ReplaySubject.a(1), _this._priv_speed$ = new BehaviorSubject_BehaviorSubject(videoElement.playbackRate), 
                _this._priv_stopCurrentContent$ = new Subject.a(), _this._priv_streamLock$ = new BehaviorSubject_BehaviorSubject(!1), 
                _this._priv_bufferOptions = {
                    wantedBufferAhead$: new BehaviorSubject_BehaviorSubject(wantedBufferAhead),
                    maxBufferAhead$: new BehaviorSubject_BehaviorSubject(maxBufferAhead),
                    maxBufferBehind$: new BehaviorSubject_BehaviorSubject(maxBufferBehind)
                }, _this._priv_bitrateInfos = {
                    lastBitrates: {
                        audio: initialAudioBitrate,
                        video: initialVideoBitrate
                    },
                    initialMaxAutoBitrates: {
                        audio: maxAudioBitrate,
                        video: maxVideoBitrate
                    },
                    manualBitrates: {
                        audio: -1,
                        video: -1
                    }
                }, _this._priv_throttleWhenHidden = throttleWhenHidden, _this._priv_limitVideoWidth = limitVideoWidth, 
                _this._priv_mutedMemory = DEFAULT_UNMUTED_VOLUME, _this._priv_trackManager = null, 
                _this._priv_abrManager = null, _this._priv_currentError = null, _this._priv_contentInfos = null, 
                _this._priv_contentEventsMemory = {
                    period: null,
                    videoTrack: null,
                    audioTrack: null,
                    textTrack: null,
                    videoBitrate: null,
                    audioBitrate: null,
                    bitrateEstimation: void 0
                }, _this._priv_stopAtEnd = stopAtEnd, _this._priv_setPlayerState(PLAYER_STATES_STOPPED), 
                _this;
            }
            /**
   * All possible Error types emitted by the RxPlayer.
   * @type {Object}
   */            _inheritsLoose(Player, _EventEmitter);
            var _proto = Player.prototype;
            /**
   * Stop the playback for the current content.
   */            return _proto.stop = function stop() {
                this.state !== PLAYER_STATES_STOPPED && (this._priv_stopCurrentContent$.next(), 
                this._priv_cleanUpCurrentContentState(), this._priv_setPlayerState(PLAYER_STATES_STOPPED));
            }, 
            /**
   * Free the resources used by the player.
   * /!\ The player cannot be "used" anymore after this method has been called.
   */
            _proto.dispose = function dispose() {
                // free resources linked to the loaded content
                this.stop(), this.videoElement && 
                // free resources used for EME management
                Object(eme.disposeEME)(this.videoElement), // free Observables linked to the Player instance
                this._priv_destroy$.next(), this._priv_destroy$.complete(), // Complete all subjects
                this._priv_stopCurrentContent$.complete(), this._priv_playing$.complete(), this._priv_speed$.complete(), 
                this._priv_streamLock$.complete(), this._priv_bufferOptions.wantedBufferAhead$.complete(), 
                this._priv_bufferOptions.maxBufferAhead$.complete(), this._priv_bufferOptions.maxBufferBehind$.complete(), 
                // un-attach video element
                this.videoElement = null;
            }, 
            /**
   * Load a new video.
   * @param {Object} opts
   * @returns {Observable}
   * @throws Error - throws if no url is given.
   * @throws Error - throws if no transport is given and no default transport
   * has been set.
   * @throws Error - throws if the asked transport does not exist
   */
            _proto.loadVideo = function loadVideo(opts) {
                var _this2 = this, options = parseLoadVideoOptions(opts);
                log.a.info("API: Calling loadvideo", options);
                var autoPlay = options.autoPlay, defaultAudioTrack = options.defaultAudioTrack, defaultTextTrack = options.defaultTextTrack, keySystems = options.keySystems, manualBitrateSwitchingMode = options.manualBitrateSwitchingMode, networkConfig = options.networkConfig, startAt = options.startAt, supplementaryImageTracks = options.supplementaryImageTracks, supplementaryTextTracks = options.supplementaryTextTracks, transport = options.transport, transportOptions = options.transportOptions, url = options.url;
 // Perform multiple checks on the given options
                                if (!this.videoElement) throw new Error("the attached video element is disposed");
 // now that every check has passed, stop previous content
                                this.stop();
                var isDirectFile = "directfile" === transport;
                this._priv_currentError = null, this._priv_contentInfos = {
                    url: url,
                    isDirectFile: isDirectFile,
                    thumbnails: null,
                    manifest: null,
                    currentPeriod: null,
                    activeAdaptations: null,
                    activeRepresentations: null,
                    initialAudioTrack: defaultAudioTrack,
                    initialTextTrack: defaultTextTrack
                }, // inilialize to false
                this._priv_playing$.next(!1);
                // get every properties used from context for clarity
                var stream, videoElement = this.videoElement, clock$ = api_clock(videoElement, {
                    withMediaSource: !isDirectFile
                }), closeStream$ = Object(merge.a)(this._priv_stopCurrentContent$, this._priv_stopAtEnd ? Object(events.c)(videoElement) : empty.a).pipe(Object(take.a)(1));
 // Global clock used for the whole application.
                                if (isDirectFile) {
                    if (null == features.a.directfile) throw new Error("DirectFile feature not activated in your build.");
                    stream = features.a.directfile({
                        autoPlay: autoPlay,
                        clock$: clock$,
                        keySystems: keySystems,
                        mediaElement: videoElement,
                        speed$: this._priv_speed$,
                        startAt: startAt,
                        url: url
                    }).pipe(Object(takeUntil.a)(closeStream$)).pipe(publish());
                } // Emit an object when the player stalls and null when it unstall
                 else {
                    var transportFn = features.a.transports[transport];
                    if (!transportFn) throw new Error('transport "' + transport + '" not supported');
                    var pipelines = transportFn(transportOptions), representationFilter = transportOptions.representationFilter, adaptiveOptions = {
                        initialBitrates: this._priv_bitrateInfos.lastBitrates,
                        manualBitrates: this._priv_bitrateInfos.manualBitrates,
                        maxAutoBitrates: this._priv_bitrateInfos.initialMaxAutoBitrates,
                        throttle: this._priv_throttleWhenHidden ? {
                            video: Object(events.a)().pipe(Object(map.a)(function(isBg) {
                                return isBg ? 0 : Infinity;
                            }), Object(takeUntil.a)(this._priv_stopCurrentContent$))
                        } : {},
                        limitWidth: this._priv_limitVideoWidth ? {
                            video: Object(events.q)(videoElement).pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$))
                        } : {}
                    }, textTrackOptions = "native" === options.textTrackMode ? {
                        textTrackMode: "native",
                        hideNativeSubtitle: options.hideNativeSubtitle
                    } : {
                        textTrackMode: "html",
                        textTrackElement: options.textTrackElement
                    };
                    // Stream Observable, through which the content will be launched.
                    stream = Stream({
                        adaptiveOptions: adaptiveOptions,
                        autoPlay: autoPlay,
                        bufferOptions: object_assign_default()({
                            manualBitrateSwitchingMode: manualBitrateSwitchingMode
                        }, this._priv_bufferOptions),
                        clock$: clock$,
                        keySystems: keySystems,
                        mediaElement: videoElement,
                        networkConfig: networkConfig,
                        speed$: this._priv_speed$,
                        startAt: startAt,
                        textTrackOptions: textTrackOptions,
                        transport: {
                            pipelines: pipelines,
                            options: {
                                representationFilter: representationFilter,
                                supplementaryImageTracks: supplementaryImageTracks,
                                supplementaryTextTracks: supplementaryTextTracks
                            }
                        },
                        url: url
                    }).pipe(Object(takeUntil.a)(closeStream$)).pipe(publish());
                }
                var streamDisposable, stalled$ = stream.pipe(Object(filter.a)(function(evt) {
                    return "stalled" === evt.type;
                }), Object(map.a)(function(x) {
                    return x.value;
                })), loaded$ = stream.pipe(Object(filter.a)(function(evt) {
                    return "loaded" === evt.type;
                }), Object(share.a)()), reloading$ = stream.pipe(Object(filter.a)(function(evt) {
                    return "reloading-stream" === evt.type;
                }), Object(share.a)()), endedEvent$ = Object(events.c)(videoElement), seekingEvent$ = Object(events.m)(videoElement), loadedStateUpdates$ = Object(combineLatest.a)(this._priv_playing$, stalled$.pipe(Object(startWith.a)(null)), endedEvent$.pipe(Object(startWith.a)(null)), seekingEvent$.pipe(Object(startWith.a)(null))).pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$), Object(map.a)(function(_ref) {
                    var isPlaying = _ref[0], stalledStatus = _ref[1];
                    return getLoadedContentState(videoElement, isPlaying, stalledStatus);
                })), playerState$ = Object(concat.a)(Object(of.a)(PLAYER_STATES_LOADING), // Begin with LOADING
                // LOADED as soon as the first "loaded" event is sent from the Stream
                loaded$.pipe(Object(take.a)(1), Object(mapTo.a)(PLAYER_STATES_LOADED)), Object(merge.a)(loadedStateUpdates$.pipe(// From the first reload onward, we enter another dynamic (below)
                Object(takeUntil.a)(reloading$), skipWhile(function(state) {
                    return state === PLAYER_STATES_PAUSED;
                })), // when reloading
                reloading$.pipe(Object(switchMapTo.a)(loaded$.pipe(Object(take.a)(1), // wait for the next loaded Stream event
                Object(mergeMapTo.a)(loadedStateUpdates$), // to update the state as usual
                Object(startWith.a)(PLAYER_STATES_RELOADING)))))).pipe(Object(distinctUntilChanged.a)());
 // Emit when the Stream is considered "loaded".
                                this._priv_stopCurrentContent$.pipe(Object(take.a)(1)).subscribe(function() {
                    streamDisposable && streamDisposable.unsubscribe();
                }), Object(events.j)(videoElement).pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function(e) {
                    return _this2._priv_onPlayPauseNext("play" === e.type);
                }, noop.a), clock$.pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function(x) {
                    return _this2._priv_triggerTimeChange(x);
                }, noop.a), playerState$.pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function(x) {
                    return _this2._priv_setPlayerState(x);
                }, noop.a), stream.subscribe(function(x) {
                    return _this2._priv_onStreamNext(x);
                }, function(err) {
                    return _this2._priv_onStreamError(err);
                }, function() {
                    return _this2._priv_onStreamComplete();
                }), // connect the stream when the lock is inactive
                this._priv_streamLock$.pipe(Object(filter.a)(function(isLocked) {
                    return !isLocked;
                }), Object(take.a)(1), Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function() {
                    streamDisposable = stream.connect();
                });
            }, 
            /**
   * Returns fatal error if one for the current content.
   * null otherwise.
   * @returns {Object|null}
   */
            _proto.getError = function getError() {
                return this._priv_currentError;
            }, 
            /**
   * Returns manifest/playlist object.
   * null if the player is STOPPED.
   * @returns {Manifest|null}
   */
            _proto.getManifest = function getManifest() {
                return this._priv_contentInfos && this._priv_contentInfos.manifest;
            }, 
            /**
   * Returns adaptations (tracks) for every currently playing type
   * (audio/video/text...).
   * @returns {Object|null}
   */
            _proto.getCurrentAdaptations = function getCurrentAdaptations() {
                if (!this._priv_contentInfos) return null;
                var _this$_priv_contentIn = this._priv_contentInfos, currentPeriod = _this$_priv_contentIn.currentPeriod, activeAdaptations = _this$_priv_contentIn.activeAdaptations;
                return currentPeriod && activeAdaptations && activeAdaptations.get(currentPeriod) || null;
            }, 
            /**
   * Returns representations (qualities) for every currently playing type
   * (audio/video/text...).
   * @returns {Object|null}
   */
            _proto.getCurrentRepresentations = function getCurrentRepresentations() {
                if (!this._priv_contentInfos) return null;
                var _this$_priv_contentIn2 = this._priv_contentInfos, currentPeriod = _this$_priv_contentIn2.currentPeriod, activeRepresentations = _this$_priv_contentIn2.activeRepresentations;
                return currentPeriod && activeRepresentations && activeRepresentations.get(currentPeriod) || null;
            }, 
            /**
   * Returns the media DOM element used by the player.
   * You should not its HTML5 API directly and use the player's method instead,
   * to ensure a well-behaved player.
   * @returns {HTMLMediaElement|null}
   */
            _proto.getVideoElement = function getVideoElement() {
                return this.videoElement;
            }, 
            /**
   * If one returns the first native text-track element attached to the media element.
   * @deprecated
   * @returns {TextTrack}
   */
            _proto.getNativeTextTrack = function getNativeTextTrack() {
                if (Object(warnOnce.a)("getNativeTextTrack is deprecated. Please open an issue if you used this API."), 
                !this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return 0 < videoElement.textTracks.length ? videoElement.textTracks[0] : null;
            }, 
            /**
   * Returns the player's current state.
   * @returns {string}
   */
            _proto.getPlayerState = function getPlayerState() {
                return this.state;
            }, 
            /**
   * Returns true if both:
   *   - a content is loaded
   *   - the content loaded is a live content
   * @returns {Boolean}
   */
            _proto.isLive = function isLive() {
                if (!this._priv_contentInfos) return !1;
                var _this$_priv_contentIn3 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn3.isDirectFile, manifest = _this$_priv_contentIn3.manifest;
                return !(isDirectFile || !manifest) && manifest.isLive;
            }, 
            /**
   * Returns the url of the content's manifest
   * @returns {string|undefined}
   */
            _proto.getUrl = function getUrl() {
                if (this._priv_contentInfos) {
                    var _this$_priv_contentIn4 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn4.isDirectFile, manifest = _this$_priv_contentIn4.manifest, url = _this$_priv_contentIn4.url;
                    return isDirectFile ? url : manifest ? manifest.getUrl() : void 0;
                }
            }, 
            /**
   * Returns the video duration, in seconds.
   * NaN if no video is playing.
   * @returns {Number}
   */
            _proto.getVideoDuration = function getVideoDuration() {
                if (!this.videoElement) throw new Error("Disposed player");
                return this.videoElement.duration;
            }, 
            /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the current time
   * @returns {Number}
   */
            _proto.getVideoBufferGap = function getVideoBufferGap() {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return Object(utils_ranges.c)(videoElement.buffered, videoElement.currentTime);
            }, 
            /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */
            _proto.getVideoLoadedTime = function getVideoLoadedTime() {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return Object(utils_ranges.g)(videoElement.buffered, videoElement.currentTime);
            }, 
            /**
   * Returns in seconds the difference between:
   *   - the current time.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */
            _proto.getVideoPlayedTime = function getVideoPlayedTime() {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return Object(utils_ranges.e)(videoElement.buffered, videoElement.currentTime);
            }, 
            /**
   * Get the current position, in s, in wall-clock time.
   * That is:
   *   - for live content, get a timestamp, in s, of the current played content.
   *   - for static content, returns the position from beginning in s.
   *
   * If you do not know if you want to use this method or getPosition:
   *   - If what you want is to display the current time to the user, use this
   *     one.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use getPosition.
   *
   * @returns {Number}
   */
            _proto.getWallClockTime = function getWallClockTime() {
                if (!this.videoElement) throw new Error("Disposed player");
                if (!this._priv_contentInfos) return this.videoElement.currentTime;
                var _this$_priv_contentIn5 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn5.isDirectFile, manifest = _this$_priv_contentIn5.manifest;
                if (isDirectFile) return this.videoElement.currentTime;
                if (manifest) {
                    var currentTime = this.videoElement.currentTime;
                    return this.isLive() ? currentTime + (manifest.availabilityStartTime || 0) : currentTime;
                }
                return 0;
            }, 
            /**
   * Get the current position, in seconds, of the video element.
   *
   * If you do not know if you want to use this method or getWallClockTime:
   *   - If what you want is to display the current time to the user, use
   *     getWallClockTime.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use this one.
   *
   * @returns {Number}
   */
            _proto.getPosition = function getPosition() {
                if (!this.videoElement) throw new Error("Disposed player");
                return this.videoElement.currentTime;
            }, 
            /**
   * Returns the current speed at which the video plays.
   * @returns {Number}
   */
            _proto.getPlaybackRate = function getPlaybackRate() {
                return this._priv_speed$.getValue();
            }, 
            /**
   * Update the playback rate of the video.
   * @param {Number} rate
   */
            _proto.setPlaybackRate = function setPlaybackRate(rate) {
                this._priv_speed$.next(rate);
            }, 
            /**
   * Returns all available bitrates for the current video Adaptation.
   * @returns {Array.<Number>}
   */
            _proto.getAvailableVideoBitrates = function getAvailableVideoBitrates() {
                if (!this._priv_contentInfos) return [];
                var _this$_priv_contentIn6 = this._priv_contentInfos, currentPeriod = _this$_priv_contentIn6.currentPeriod, activeAdaptations = _this$_priv_contentIn6.activeAdaptations;
                if (!currentPeriod || !activeAdaptations) return [];
                var adaptations = activeAdaptations.get(currentPeriod), videoAdaptation = adaptations && adaptations.video;
                return videoAdaptation ? videoAdaptation.representations.map(function(_ref2) {
                    return _ref2.bitrate;
                }) : [];
            }, 
            /**
   * Returns all available bitrates for the current audio Adaptation.
   * @returns {Array.<Number>}
   */
            _proto.getAvailableAudioBitrates = function getAvailableAudioBitrates() {
                if (!this._priv_contentInfos) return [];
                var _this$_priv_contentIn7 = this._priv_contentInfos, currentPeriod = _this$_priv_contentIn7.currentPeriod, activeAdaptations = _this$_priv_contentIn7.activeAdaptations;
                if (!currentPeriod || !activeAdaptations) return [];
                var adaptations = activeAdaptations.get(currentPeriod), audioAdaptation = adaptations && adaptations.audio;
                return audioAdaptation ? audioAdaptation.representations.map(function(_ref3) {
                    return _ref3.bitrate;
                }) : [];
            }, 
            /**
   * Returns the manual audio bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */
            _proto.getManualAudioBitrate = function getManualAudioBitrate() {
                return this._priv_bitrateInfos.manualBitrates.audio;
            }, 
            /**
   * Returns the manual video bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */
            _proto.getManualVideoBitrate = function getManualVideoBitrate() {
                return this._priv_bitrateInfos.manualBitrates.video;
            }, 
            /**
   * Returns currently considered bitrate for video segments.
   * @returns {Number|undefined}
   */
            _proto.getVideoBitrate = function getVideoBitrate() {
                var representations = this.getCurrentRepresentations();
                if (representations && representations.video) return representations.video.bitrate;
            }, 
            /**
   * Returns currently considered bitrate for audio segments.
   * @returns {Number|undefined}
   */
            _proto.getAudioBitrate = function getAudioBitrate() {
                var representations = this.getCurrentRepresentations();
                if (representations && representations.audio) return representations.audio.bitrate;
            }, 
            /**
   * Returns max wanted video bitrate currently set.
   * @returns {Number}
   */
            _proto.getMaxVideoBitrate = function getMaxVideoBitrate() {
                return this._priv_abrManager ? this._priv_abrManager.getMaxAutoBitrate("video") : this._priv_bitrateInfos.initialMaxAutoBitrates.video;
            }, 
            /**
   * Returns max wanted audio bitrate currently set.
   * @returns {Number}
   */
            _proto.getMaxAudioBitrate = function getMaxAudioBitrate() {
                return this._priv_abrManager ? this._priv_abrManager.getMaxAutoBitrate("audio") : this._priv_bitrateInfos.initialMaxAutoBitrates.audio;
            }, 
            /**
   * Play/Resume the current video.
   */
            _proto.play = function play() {
                if (!this.videoElement) throw new Error("Disposed player");
                /* tslint:disable no-floating-promises */                this.videoElement.play();
            }, 
            /**
   * Pause the current video.
   */
            _proto.pause = function pause() {
                if (!this.videoElement) throw new Error("Disposed player");
                this.videoElement.pause();
            }, 
            /**
   * Seek to a given absolute position.
   * @param {Number|Object} time
   * @returns {Number} - The time the player has seek to
   */
            _proto.seekTo = function seekTo(time) {
                if (!this.videoElement) throw new Error("Disposed player");
                if (!this._priv_contentInfos) throw new Error("player: no content loaded");
                var positionWanted, _this$_priv_contentIn8 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn8.isDirectFile, manifest = _this$_priv_contentIn8.manifest;
                if (!isDirectFile && !manifest) throw new Error("player: the content did not load yet");
                var typeOf = typeof time;
                if ("number" === typeOf) positionWanted = time; else if ("object" === typeOf) {
                    var currentTs = this.videoElement.currentTime;
                    if (null != time.relative) positionWanted = currentTs + time.relative; else if (null != time.position) positionWanted = time.position; else {
                        if (null == time.wallClockTime) throw new Error('invalid time object. You must set one of the following properties: "relative", "position" or "wallClockTime"');
                        positionWanted = isDirectFile ? time.wallClockTime : fromWallClockTime(1e3 * time.wallClockTime, manifest);
                    }
                }
                if (void 0 === positionWanted) throw new Error("invalid time given");
                return this.videoElement.currentTime = positionWanted;
            }, 
            /**
   * Returns true if the media element is full screen.
   * @deprecated
   * @returns {Boolean}
   */
            _proto.isFullscreen = function isFullscreen() {
                return Object(warnOnce.a)("isFullscreen is deprecated. Fullscreen management should now be managed by the application"), 
                Object(fullscreen.b)();
            }, 
            /**
   * Set/exit fullScreen.
   * @deprecated
   * @param {Boolean} [goFull=true] - if false, exit full screen.
   */
            _proto.setFullscreen = function setFullscreen(goFull) {
                if (void 0 === goFull && (goFull = !0), Object(warnOnce.a)("setFullscreen is deprecated. Fullscreen management should now be managed by the application"), 
                !this.videoElement) throw new Error("Disposed player");
                goFull ? Object(fullscreen.c)(this.videoElement) : Object(fullscreen.a)();
            }, 
            /**
   * Exit from full screen mode.
   * @deprecated
   */
            _proto.exitFullscreen = function exitFullscreen() {
                Object(warnOnce.a)("exitFullscreen is deprecated. Fullscreen management should now be managed by the application"), 
                Object(fullscreen.a)();
            }, 
            /**
   * Returns the current player's audio volume on the media element.
   * From 0 (no audio) to 1 (maximum volume).
   * @returns {Number}
   */
            _proto.getVolume = function getVolume() {
                if (!this.videoElement) throw new Error("Disposed player");
                return this.videoElement.volume;
            }, 
            /**
   * Set the player's audio volume. From 0 (no volume) to 1 (maximum volume).
   * @param {Number} volume
   */
            _proto.setVolume = function setVolume(volume) {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                volume !== videoElement.volume && (videoElement.volume = volume, this.trigger("volumeChange", volume));
            }, 
            /**
   * Returns true if the volume is set to 0. false otherwise.
   * @returns {Boolean}
   */
            _proto.isMute = function isMute() {
                return !this.getVolume();
            }, 
            /**
   * Set the volume to 0 and save current one for when unmuted.
   */
            _proto.mute = function mute() {
                this._priv_mutedMemory = this.getVolume(), this.setVolume(0);
            }, 
            /**
   * Set the volume back to when it was when mute was last called.
   * If the volume was set to 0, set a default volume instead (see config).
   */
            _proto.unMute = function unMute() {
                0 === this.getVolume() && this.setVolume(this._priv_mutedMemory || DEFAULT_UNMUTED_VOLUME);
            }, 
            /**
   * Force the video bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */
            _proto.setVideoBitrate = function setVideoBitrate(btr) {
                this._priv_bitrateInfos.manualBitrates.video = btr, this._priv_abrManager && this._priv_abrManager.setManualBitrate("video", btr);
            }, 
            /**
   * Force the audio bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */
            _proto.setAudioBitrate = function setAudioBitrate(btr) {
                this._priv_bitrateInfos.manualBitrates.audio = btr, this._priv_abrManager && this._priv_abrManager.setManualBitrate("audio", btr);
            }, 
            /**
   * Update the maximum video bitrate the user can switch to.
   * @param {Number} btr
   */
            _proto.setMaxVideoBitrate = function setMaxVideoBitrate(btr) {
                // set it for the next content loaded
                this._priv_bitrateInfos.initialMaxAutoBitrates.video = btr, // set it for the current if one is loaded
                this._priv_abrManager && this._priv_abrManager.setMaxAutoBitrate("video", btr);
            }, 
            /**
   * Update the maximum video bitrate the user can switch to.
   * @param {Number} btr
   */
            _proto.setMaxAudioBitrate = function setMaxAudioBitrate(btr) {
                // set it for the next content loaded
                this._priv_bitrateInfos.initialMaxAutoBitrates.audio = btr, // set it for the current if one is loaded
                this._priv_abrManager && this._priv_abrManager.setMaxAutoBitrate("audio", btr);
            }, 
            /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */
            _proto.setMaxBufferBehind = function setMaxBufferBehind(depthInSeconds) {
                this._priv_bufferOptions.maxBufferBehind$.next(depthInSeconds);
            }, 
            /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */
            _proto.setMaxBufferAhead = function setMaxBufferAhead(depthInSeconds) {
                this._priv_bufferOptions.maxBufferAhead$.next(depthInSeconds);
            }, 
            /**
   * Set the max buffer size for the buffer ahead of the current position.
   * The player will stop downloading chunks when this size is reached.
   * @param {Number} sizeInSeconds
   */
            _proto.setWantedBufferAhead = function setWantedBufferAhead(sizeInSeconds) {
                this._priv_bufferOptions.wantedBufferAhead$.next(sizeInSeconds);
            }, 
            /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */
            _proto.getMaxBufferBehind = function getMaxBufferBehind() {
                return this._priv_bufferOptions.maxBufferBehind$.getValue();
            }, 
            /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */
            _proto.getMaxBufferAhead = function getMaxBufferAhead() {
                return this._priv_bufferOptions.maxBufferAhead$.getValue();
            }, 
            /**
   * Returns the max buffer size for the buffer ahead of the current position.
   * @returns {Number}
   */
            _proto.getWantedBufferAhead = function getWantedBufferAhead() {
                return this._priv_bufferOptions.wantedBufferAhead$.getValue();
            }, 
            /**
   * Returns type of current keysystem (e.g. playready, widevine) if the content
   * is encrypted. null otherwise.
   * @returns {string|null}
   */
            _proto.getCurrentKeySystem = function getCurrentKeySystem() {
                if (!this.videoElement) throw new Error("Disposed player");
                return Object(eme.getCurrentKeySystem)(this.videoElement);
            }, 
            /**
   * Returns every available audio tracks for the current Period.
   * @returns {Array.<Object>|null}
   */
            _proto.getAvailableAudioTracks = function getAvailableAudioTracks() {
                if (!this._priv_contentInfos) return [];
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                return this._priv_trackManager && currentPeriod ? this._priv_trackManager.getAvailableAudioTracks(currentPeriod) : [];
            }, 
            /**
   * Returns every available text tracks for the current Period.
   * @returns {Array.<Object>|null}
   */
            _proto.getAvailableTextTracks = function getAvailableTextTracks() {
                if (!this._priv_contentInfos) return [];
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                return this._priv_trackManager && currentPeriod ? this._priv_trackManager.getAvailableTextTracks(currentPeriod) : [];
            }, 
            /**
   * Returns every available video tracks for the current Period.
   * @returns {Array.<Object>|null}
   */
            _proto.getAvailableVideoTracks = function getAvailableVideoTracks() {
                if (!this._priv_contentInfos) return [];
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                return this._priv_trackManager && currentPeriod ? this._priv_trackManager.getAvailableVideoTracks(currentPeriod) : [];
            }, 
            /**
   * Returns currently chosen audio language for the current Period.
   * @returns {string}
   */
            _proto.getAudioTrack = function getAudioTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_trackManager && currentPeriod) return this._priv_trackManager.getChosenAudioTrack(currentPeriod);
                }
            }, 
            /**
   * Returns currently chosen subtitle for the current Period.
   * @returns {string}
   */
            _proto.getTextTrack = function getTextTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_trackManager && currentPeriod) return this._priv_trackManager.getChosenTextTrack(currentPeriod);
                }
            }, 
            /**
   * Returns currently chosen video track for the current Period.
   * @returns {string}
   */
            _proto.getVideoTrack = function getVideoTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_trackManager && currentPeriod) return this._priv_trackManager.getChosenVideoTrack(currentPeriod);
                }
            }, 
            /**
   * Update the audio language for the current Period.
   * @param {string} audioId
   * @throws Error - the current content has no TrackManager.
   * @throws Error - the given id is linked to no audio track.
   */
            _proto.setAudioTrack = function setAudioTrack(audioId) {
                if (!this._priv_contentInfos) throw new Error("No content loaded");
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                if (!this._priv_trackManager || !currentPeriod) throw new Error("No compatible content launched.");
                try {
                    this._priv_trackManager.setAudioTrackByID(currentPeriod, audioId);
                } catch (e) {
                    throw new Error("player: unknown audio track");
                }
            }, 
            /**
   * Update the text language for the current Period.
   * @param {string} sub
   * @throws Error - the current content has no TrackManager.
   * @throws Error - the given id is linked to no text track.
   */
            _proto.setTextTrack = function setTextTrack(textId) {
                if (!this._priv_contentInfos) throw new Error("No content loaded");
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                if (!this._priv_trackManager || !currentPeriod) throw new Error("No compatible content launched.");
                try {
                    this._priv_trackManager.setTextTrackByID(currentPeriod, textId);
                } catch (e) {
                    throw new Error("player: unknown text track");
                }
            }, 
            /**
   * Disable subtitles for the current content.
   */
            _proto.disableTextTrack = function disableTextTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_trackManager && currentPeriod) return this._priv_trackManager.disableTextTrack(currentPeriod);
                }
            }, 
            /**
   * Update the video track for the current Period.
   * @param {string} videoId
   * @throws Error - the current content has no TrackManager.
   * @throws Error - the given id is linked to no video track.
   */
            _proto.setVideoTrack = function setVideoTrack(videoId) {
                if (!this._priv_contentInfos) throw new Error("No content loaded");
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                if (!this._priv_trackManager || !currentPeriod) throw new Error("No compatible content launched.");
                try {
                    this._priv_trackManager.setVideoTrackByID(currentPeriod, videoId);
                } catch (e) {
                    throw new Error("player: unknown video track");
                }
            }, 
            /**
   * @returns {Array.<Object>|null}
   */
            _proto.getImageTrackData = function getImageTrackData() {
                return this._priv_contentInfos && this._priv_contentInfos.thumbnails;
            }, 
            /**
   * Get minimum seek-able position.
   * @returns {number}
   */
            _proto.getMinimumPosition = function getMinimumPosition() {
                if (!this._priv_contentInfos) return null;
                if (this._priv_contentInfos.isDirectFile) return 0;
                var manifest = this._priv_contentInfos.manifest;
                return manifest ? manifest.getMinimumPosition() : null;
            }, 
            /**
   * Get maximum seek-able position.
   * @returns {number}
   */
            _proto.getMaximumPosition = function getMaximumPosition() {
                if (!this._priv_contentInfos) return null;
                var _this$_priv_contentIn9 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn9.isDirectFile, manifest = _this$_priv_contentIn9.manifest;
                if (isDirectFile) {
                    if (!this.videoElement) throw new Error("Disposed player");
                    return this.videoElement.duration;
                }
                return manifest ? manifest.getMaximumPosition() : null;
            }, 
            /**
   * Reset all state properties relative to a playing content.
   * @private
   */
            _proto._priv_cleanUpCurrentContentState = function _priv_cleanUpCurrentContentState() {
                var _this3 = this;
                // lock creation of new streams while cleaning up is pending
                                this._priv_streamLock$.next(!0), this._priv_contentInfos = null, 
                this._priv_trackManager = null, this._priv_abrManager && (this._priv_abrManager.dispose(), 
                this._priv_abrManager = null), this._priv_contentEventsMemory = {
                    period: null,
                    videoTrack: null,
                    audioTrack: null,
                    textTrack: null,
                    videoBitrate: null,
                    audioBitrate: null,
                    bitrateEstimation: void 0
                };
                // EME cleaning
                var freeUpStreamLock = function freeUpStreamLock() {
                    _this3._priv_streamLock$.next(!1);
                };
                this.videoElement ? Object(eme.clearEMESession)(this.videoElement).pipe(Object(catchError.a)(function() {
                    return empty.a;
                })).subscribe(noop.a, freeUpStreamLock, freeUpStreamLock) : freeUpStreamLock();
            }, _proto._priv_triggerContentEvent = function _priv_triggerContentEvent(type, value) {
                var prev = this._priv_contentEventsMemory[type];
                deep_equal_default()(prev, value) || (this._priv_contentEventsMemory[type] = value, 
                // SAD
                this.trigger(type + "Change", value));
            }, 
            /**
   * Triggered each time the Stream Observable emits.
   *
   * React to various events.
   *
   * @param {Object} streamInfos - payload emitted
   * @private
   */
            _proto._priv_onStreamNext = function _priv_onStreamNext(streamInfos) {
                switch (streamInfos.type) {
                  case "activePeriodChanged":
                    this._priv_onActivePeriodChanged(streamInfos.value);
                    break;

                  case "periodBufferReady":
                    this._priv_onPeriodBufferReady(streamInfos.value);
                    break;

                  case "periodBufferCleared":
                    this._priv_onPeriodBufferCleared(streamInfos.value);
                    break;

                  case "reloading-stream":
                    this._priv_onStreamReload();
                    break;

                  case "representationChange":
                    this._priv_onRepresentationChange(streamInfos.value);
                    break;

                  case "adaptationChange":
                    this._priv_onAdaptationChange(streamInfos.value);
                    break;

                  case "manifestUpdate":
                    this._priv_onManifestUpdate(streamInfos.value);
                    break;

                  case "bitrateEstimationChange":
                    this._priv_onBitrateEstimationChange(streamInfos.value);
                    break;

                  case "manifestReady":
                    this._priv_onManifestReady(streamInfos.value);
                    break;

                  case "warning":
                    this._priv_onStreamWarning(streamInfos.value);
                    break;

                  case "added-segment":
                    if (!this._priv_contentInfos) return void log.a.error("API: Added segment while no content is loaded");
 // Manage image tracks
                    // TODO Better way? Perhaps linked to an ImageSourceBuffer
                    // implementation
                                        var _streamInfos$value = streamInfos.value, bufferType = _streamInfos$value.bufferType, segmentData = _streamInfos$value.segmentData;
                    if ("image" === bufferType && null != segmentData && "bif" === segmentData.type) {
                        var imageData = segmentData.data;
 // TODO merge multiple data from the same track together
                                                this._priv_contentInfos.thumbnails = imageData, this.trigger("imageTrackUpdate", {
                            data: this._priv_contentInfos.thumbnails
                        });
                    }
                }
            }, 
            /**
   * Triggered when the Stream throws (fatal errors).
   *
   * Clean-up ressources and signal that the content has stopped on error.
   *
   * @param {Error} error
   * @private
   */
            _proto._priv_onStreamError = function _priv_onStreamError(error) {
                this._priv_stopCurrentContent$.next(), this._priv_cleanUpCurrentContentState(), 
                this._priv_currentError = error, log.a.error("API: The player stopped because of an error:", error), 
                this._priv_setPlayerState(PLAYER_STATES_STOPPED), // TODO This condition is here because the eventual callback called when the
                // player state is updated can launch a new content, thus the error will not
                // be here anymore, in which case triggering the "error" event is unwanted.
                // This is very ugly though, and we should probable have a better solution
                this._priv_currentError === error && this.trigger("error", error);
            }, 
            /**
   * Triggered when the Stream instance ends.
   *
   * Clean-up ressources and signal that the content has ended.
   * @private
   */
            _proto._priv_onStreamComplete = function _priv_onStreamComplete() {
                this._priv_stopCurrentContent$.next(), this._priv_cleanUpCurrentContentState(), 
                this._priv_setPlayerState(PLAYER_STATES_ENDED);
            }, 
            /**
   * Triggered when the Stream emits a warning.
   *
   * Trigger the right Player event.
   * @param {Object} streamInfos
   * @private
   */
            _proto._priv_onStreamWarning = function _priv_onStreamWarning(error) {
                this.trigger("warning", error);
            }, 
            /**
   * Triggered when the stream starts.
   *
   * Initialize various private properties and emit initial event.
   *
   * @param {Object} value
   * @private
   */
            _proto._priv_onManifestReady = function _priv_onManifestReady(value) {
                if (this._priv_contentInfos) {
                    var manifest = value.manifest, abrManager = value.abrManager;
                    this._priv_contentInfos.manifest = manifest, this._priv_abrManager = abrManager;
                    var _this$_priv_contentIn10 = this._priv_contentInfos, initialAudioTrack = _this$_priv_contentIn10.initialAudioTrack, initialTextTrack = _this$_priv_contentIn10.initialTextTrack;
                    this._priv_trackManager = new track_manager_TrackManager({
                        preferredAudioTracks: void 0 === initialAudioTrack ? void 0 : [ initialAudioTrack ],
                        preferredTextTracks: void 0 === initialTextTrack ? void 0 : [ initialTextTrack ]
                    }), this.trigger("manifestChange", manifest);
                } else log.a.error("API: The manifest is loaded but no content is.");
            }, 
            /**
   * Triggered each times the current Period Changed.
   * Store and emit initial state for the Period.
   *
   * @param {Object} value
   * @private
   */
            _proto._priv_onActivePeriodChanged = function _priv_onActivePeriodChanged(_ref4) {
                var period = _ref4.period;
                if (this._priv_contentInfos) {
                    // Emit intial events for the Period
                    if (this._priv_contentInfos.currentPeriod = period, this._priv_triggerContentEvent("period", period), 
                    this._priv_trackManager) {
                        var audioTrack = this._priv_trackManager.getChosenAudioTrack(period), textTrack = this._priv_trackManager.getChosenTextTrack(period), videoTrack = this._priv_trackManager.getChosenVideoTrack(period);
                        this._priv_triggerContentEvent("audioTrack", audioTrack), this._priv_triggerContentEvent("textTrack", textTrack), 
                        this._priv_triggerContentEvent("videoTrack", videoTrack);
                    } else this._priv_triggerContentEvent("audioTrack", null), this._priv_triggerContentEvent("textTrack", null), 
                    this._priv_triggerContentEvent("videoTrack", null);
                    var activeAudioRepresentations = this.getCurrentRepresentations();
                    if (activeAudioRepresentations && null != activeAudioRepresentations.audio) {
                        var bitrate = activeAudioRepresentations.audio.bitrate;
                        this._priv_triggerContentEvent("audioBitrate", null != bitrate ? bitrate : -1);
                    } else this._priv_triggerContentEvent("audioBitrate", null);
                    var activeVideoRepresentations = this.getCurrentRepresentations();
                    if (activeVideoRepresentations && null != activeVideoRepresentations.video) {
                        var _bitrate = activeVideoRepresentations.video.bitrate;
                        this._priv_triggerContentEvent("videoBitrate", null != _bitrate ? _bitrate : -1);
                    } else this._priv_triggerContentEvent("videoBitrate", null);
                } else log.a.error("API: The active period changed but no content is loaded");
            }, 
            /**
   * Triggered each times the Stream "prepares" a new Period, and
   * needs the API to send it its chosen Adaptation.
   *
   * Choose the right Adaptation for the Period and emit it.
   *
   * @param {Object} value
   * @private
   */
            _proto._priv_onPeriodBufferReady = function _priv_onPeriodBufferReady(value) {
                var type = value.type, period = value.period, adaptation$ = value.adaptation$;
                switch (type) {
                  case "video":
                    this._priv_trackManager ? (this._priv_trackManager.addPeriod(type, period, adaptation$), 
                    this._priv_trackManager.setInitialVideoTrack(period)) : (log.a.error("API: TrackManager not instanciated for a new video period"), 
                    adaptation$.next(null));
                    break;

                  case "audio":
                    this._priv_trackManager ? (this._priv_trackManager.addPeriod(type, period, adaptation$), 
                    this._priv_trackManager.setInitialAudioTrack(period)) : (log.a.error("API: TrackManager not instanciated for a new " + type + " period"), 
                    adaptation$.next(null));
                    break;

                  case "text":
                    this._priv_trackManager ? (this._priv_trackManager.addPeriod(type, period, adaptation$), 
                    this._priv_trackManager.setInitialTextTrack(period)) : (log.a.error("API: TrackManager not instanciated for a new " + type + " period"), 
                    adaptation$.next(null));
                    break;

                  default:
                    var adaptations = period.adaptations[type];
                    adaptations && adaptations.length ? adaptation$.next(adaptations[0]) : adaptation$.next(null);
                }
            }, 
            /**
   * Triggered each times the Stream "removes" a Period.
   *
   * Update the TrackManager to remove the corresponding Period.
   *
   * @param {Object} value
   * @private
   */
            _proto._priv_onPeriodBufferCleared = function _priv_onPeriodBufferCleared(value) {
                var type = value.type, period = value.period;
                switch (type) {
                  case "audio":
                  case "text":
                  case "video":
                    this._priv_trackManager && this._priv_trackManager.removePeriod(type, period);
                }
            }, _proto._priv_onStreamReload = function _priv_onStreamReload() {
                this._priv_trackManager && this._priv_trackManager.resetPeriods();
            }, 
            /**
   * Triggered each times the Manifest is updated.
   *
   * Update the TrackManager and emit events.
   *
   * @param {Object} value
   * @private
   */
            _proto._priv_onManifestUpdate = function _priv_onManifestUpdate(value) {
                if (this._priv_contentInfos) {
                    var manifest = value.manifest;
                    this._priv_contentInfos.manifest = manifest, // Update the tracks chosen if it changed
                    this._priv_trackManager && this._priv_trackManager.update(), this.trigger("manifestUpdate", manifest);
                } else log.a.error("API: The manifest is updated but no content is loaded.");
            }, 
            /**
   * Triggered each times a new Adaptation is considered by the Stream.
   *
   * Store given Adaptation and emit it if from the current Period.
   *
   * @param {Object} value
   * @private
   */
            _proto._priv_onAdaptationChange = function _priv_onAdaptationChange(_ref5) {
                var type = _ref5.type, adaptation = _ref5.adaptation, period = _ref5.period;
                if (this._priv_contentInfos) {
                    // lazily create this._priv_contentInfos.activeAdaptations
                    this._priv_contentInfos.activeAdaptations || (this._priv_contentInfos.activeAdaptations = new Map());
                    var _activeAdaptations$se, _this$_priv_contentIn11 = this._priv_contentInfos, activeAdaptations = _this$_priv_contentIn11.activeAdaptations, currentPeriod = _this$_priv_contentIn11.currentPeriod, activePeriodAdaptations = activeAdaptations.get(period);
                    if (activePeriodAdaptations) activePeriodAdaptations[type] = adaptation; else activeAdaptations.set(period, ((_activeAdaptations$se = {})[type] = adaptation, 
                    _activeAdaptations$se));
                    if (this._priv_trackManager && null != period && period === currentPeriod) switch (type) {
                      case "audio":
                        var audioTrack = this._priv_trackManager.getChosenAudioTrack(currentPeriod);
                        this._priv_triggerContentEvent("audioTrack", audioTrack);
                        break;

                      case "text":
                        var textTrack = this._priv_trackManager.getChosenTextTrack(currentPeriod);
                        this._priv_triggerContentEvent("textTrack", textTrack);
                        break;

                      case "video":
                        var videoTrack = this._priv_trackManager.getChosenVideoTrack(currentPeriod);
                        this._priv_triggerContentEvent("videoTrack", videoTrack);
                    }
                } else log.a.error("API: The adaptations changed but no content is loaded");
            }, 
            /**
   * Triggered each times a new Representation is considered by the Stream.
   *
   * Store given Representation and emit it if from the current Period.
   *
   * @param {Object} obj
   * @private
   */
            _proto._priv_onRepresentationChange = function _priv_onRepresentationChange(_ref6) {
                var type = _ref6.type, period = _ref6.period, representation = _ref6.representation;
                if (this._priv_contentInfos) {
                    // lazily create this._priv_contentInfos.activeRepresentations
                    this._priv_contentInfos.activeRepresentations || (this._priv_contentInfos.activeRepresentations = new Map());
                    var _activeRepresentation, _this$_priv_contentIn12 = this._priv_contentInfos, activeRepresentations = _this$_priv_contentIn12.activeRepresentations, currentPeriod = _this$_priv_contentIn12.currentPeriod, activePeriodRepresentations = activeRepresentations.get(period);
                    if (activePeriodRepresentations) activePeriodRepresentations[type] = representation; else activeRepresentations.set(period, ((_activeRepresentation = {})[type] = representation, 
                    _activeRepresentation));
                    var bitrate = representation && representation.bitrate;
                    null != bitrate && (this._priv_bitrateInfos.lastBitrates[type] = bitrate), null != period && currentPeriod === period && ("video" === type ? this._priv_triggerContentEvent("videoBitrate", null != bitrate ? bitrate : -1) : "audio" === type && this._priv_triggerContentEvent("audioBitrate", null != bitrate ? bitrate : -1));
                } else log.a.error("API: The representations changed but no content is loaded");
            }, 
            /**
   * Triggered each time a bitrate estimate is calculated.
   *
   * Emit it.
   *
   * @param {Object} value
   * @private
   */
            _proto._priv_onBitrateEstimationChange = function _priv_onBitrateEstimationChange(_ref7) {
                var type = _ref7.type, bitrate = _ref7.bitrate;
                this._priv_triggerContentEvent("bitrateEstimation", {
                    type: type,
                    bitrate: bitrate
                });
            }, 
            /**
   * Triggered each time the videoElement alternates between play and pause.
   *
   * Emit the info through the right Subject.
   *
   * @param {Boolean} isPlaying
   * @private
   */
            _proto._priv_onPlayPauseNext = function _priv_onPlayPauseNext(isPlaying) {
                if (!this.videoElement) throw new Error("Disposed player");
                this._priv_playing$.next(isPlaying);
            }, 
            /**
   * Triggered each time a textTrack is added to the video DOM Element.
   *
   * Trigger the right Player Event.
   *
   * @param {Array.<TextTrackElement>} tracks
   * @private
   */
            _proto._priv_onNativeTextTracksNext = function _priv_onNativeTextTracksNext(tracks) {
                this.trigger("nativeTextTracksChange", tracks);
            }, 
            /**
   * Triggered each time the player state updates.
   *
   * Trigger the right Player Event.
   *
   * @param {string} newState
   * @private
   */
            _proto._priv_setPlayerState = function _priv_setPlayerState(newState) {
                this.state !== newState && (this.state = newState, log.a.info("API: playerStateChange event", newState), 
                this.trigger("playerStateChange", newState));
            }, 
            /**
   * Triggered each time a new clock tick object is emitted.
   *
   * Trigger the right Player Event
   *
   * @param {Object} clockTick
   * @private
   */
            _proto._priv_triggerTimeChange = function _priv_triggerTimeChange(clockTick) {
                if (this._priv_contentInfos) {
                    if (this.state !== PLAYER_STATES_RELOADING) {
                        var _this$_priv_contentIn13 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn13.isDirectFile, manifest = _this$_priv_contentIn13.manifest;
                        if ((isDirectFile || manifest) && clockTick) {
                            var positionData = {
                                position: clockTick.currentTime,
                                duration: clockTick.duration,
                                playbackRate: clockTick.playbackRate,
                                // TODO fix higher up?
                                bufferGap: isFinite(clockTick.bufferGap) ? clockTick.bufferGap : 0
                            };
                            manifest && manifest.isLive && 0 < clockTick.currentTime && (positionData.wallClockTime = clockTick.currentTime + (manifest.availabilityStartTime || 0), 
                            positionData.liveGap = manifest.getMaximumPosition() - clockTick.currentTime), this.trigger("positionUpdate", positionData);
                        }
                    }
                } else log.a.warn("API: Cannot perform time update: no content loaded.");
            }, api_createClass(Player, null, [ {
                key: "ErrorTypes",
                get: function get() {
                    return constants.b;
                }
                /**
     * All possible Error codes emitted by the RxPlayer.
     * @type {Object}
     */            }, {
                key: "ErrorCodes",
                get: function get() {
                    return constants.a;
                }
                /**
     * Current log level.
     * Update current log level.
     * Should be either (by verbosity ascending):
     *   - "NONE"
     *   - "ERROR"
     *   - "WARNING"
     *   - "INFO"
     *   - "DEBUG"
     * Any other value will be translated to "NONE".
     * @type {string}
     */            }, {
                key: "LogLevel",
                get: function get() {
                    return log.a.getLevel();
                },
                set: function set(logLevel) {
                    log.a.setLevel(logLevel);
                }
            } ]), Player;
        }(eventemitter.a);
        /**
 * @class Player
 * @extends EventEmitter
 */        
        /**
 * Current version of the RxPlayer.
 * @type {string}
 */
        api_Player.version = "3.9.2";
        /* harmony default export */ var api = api_Player;
        // CONCATENATED MODULE: ./src/features/initialize_features.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Selects the features to include based on environment variables.
 *
 * @param {Object} features
 */        
        // CONCATENATED MODULE: ./src/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file exports a Player class with a default feature set (depends on the
 * environment variables set at build).
 *
 * This is the class used from a regular build.
 */
        // set initial features according to environment variables
        !function initializeFeaturesObject() {
            features.a.emeManager = __webpack_require__(86).default, features.a.imageBuffer = __webpack_require__(111).default, 
            features.a.imageParser = __webpack_require__(112).default, features.a.transports.smooth = __webpack_require__(126).default, 
            features.a.transports.dash = __webpack_require__(125).default, features.a.nativeTextTracksBuffer = __webpack_require__(130).default, 
            features.a.nativeTextTracksParsers.vtt = __webpack_require__(113).default, features.a.nativeTextTracksParsers.ttml = __webpack_require__(114).default, 
            features.a.nativeTextTracksParsers.sami = __webpack_require__(115).default, features.a.nativeTextTracksParsers.srt = __webpack_require__(116).default, 
            features.a.htmlTextTracksBuffer = __webpack_require__(129).default, features.a.htmlTextTracksParsers.sami = __webpack_require__(119).default, 
            features.a.htmlTextTracksParsers.ttml = __webpack_require__(127).default, features.a.htmlTextTracksParsers.srt = __webpack_require__(120).default, 
            features.a.htmlTextTracksParsers.vtt = __webpack_require__(128).default, features.a.directfile = __webpack_require__(121).default;
        }();
        /* harmony default export */ __webpack_exports__.default = api;
        /***/    }, 
    /* 125 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
        var of = __webpack_require__(64), features = __webpack_require__(10), isobmff = __webpack_require__(32), log = __webpack_require__(0);
        // EXTERNAL MODULE: ./src/features/index.ts
                // CONCATENATED MODULE: ./src/parsers/containers/matroska/utils.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function getLength(buffer, offset) {
            for (var length = 1; length <= 8; length++) if (buffer[offset] >= Math.pow(2, 8 - length)) return length;
        }
        function getEBMLID(buffer, offset) {
            var length = getLength(buffer, offset);
            if (null == length) return log.a.warn("webm: unrepresentable length"), null;
            if (offset + length > buffer.length) return log.a.warn("webm: impossible length"), 
            null;
            for (var value = 0, i = 0; i < length; i++) value = buffer[offset + i] * Math.pow(2, 8 * (length - i - 1)) + value;
            return {
                length: length,
                value: value
            };
        }
        function getEBMLValue(buffer, offset) {
            var length = getLength(buffer, offset);
            if (null == length) return log.a.warn("webm: unrepresentable length"), null;
            if (offset + length > buffer.length) return log.a.warn("webm: impossible length"), 
            null;
            for (var value = (buffer[offset] & (1 << 8 - length) - 1) * Math.pow(2, 8 * (length - 1)), i = 1; i < length; i++) value = buffer[offset + i] * Math.pow(2, 8 * (length - i - 1)) + value;
            return {
                length: length,
                value: value
            };
        }
        /**
 * Convert a IEEE754 32 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */        function get_IEEE754_32Bits(buffer, offset) {
            return new DataView(buffer.buffer).getFloat32(offset);
        }
        /**
 * Convert a IEEE754 64 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */        function get_IEEE754_64Bits(buffer, offset) {
            return new DataView(buffer.buffer).getFloat64(offset);
        }
        function bytesToNumber(buffer, offset, length) {
            for (var value = 0, i = 0; i < length; i++) value = buffer[offset + i] * Math.pow(2, 8 * (length - i - 1)) + value;
            return value;
        }
        // CONCATENATED MODULE: ./src/parsers/containers/matroska/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var SEGMENT_ID = 408125543, INFO_ID = 357149030, TIMECODESCALE_ID = 2807729, DURATION_ID = 17545;
        /**
 * Find the offsets of the value linked to the given element ID.
 * @param {number} elementID - ID for the searched element.
 * @param {Array.<number>} parents - eventual IDs of the parent elements. From
 * top level to lower level (from the furthest to the closest).
 * @param {Uint8Array} buffer - buffer where the ID will be searched
 * @param {Array.<number>} range - start and end offsets in the buffer where the
 * ID will be searched.
 * @returns {Array.<number>|null}
 */
        function findNextElement(elementID, parents, buffer, _ref) {
            for (var initialOffset = _ref[0], maxOffset = _ref[1], currentOffset = initialOffset; currentOffset < maxOffset; ) {
                var parsedID = getEBMLID(buffer, currentOffset);
                if (null == parsedID) return null;
                var ebmlTagID = parsedID.value, sizeOffset = currentOffset + parsedID.length, parsedValue = getEBMLValue(buffer, sizeOffset);
                if (null == parsedValue) return null;
                var valueOffset = sizeOffset + parsedValue.length, valueEndOffset = valueOffset + parsedValue.value;
                if (ebmlTagID === elementID) return [ valueOffset, valueEndOffset ];
                if (parents.length) for (var i = 0; i < parents.length; i++) {
                    if (ebmlTagID === parents[i]) return findNextElement(elementID, parents.slice(i + 1, parents.length), buffer, [ valueOffset, valueEndOffset ]);
                }
                currentOffset = valueEndOffset;
            }
            return null;
        }
        /**
 * Return the timecode scale (basically timescale) of the whole file.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */        function getTimeCodeScale(buffer, initialOffset) {
            var timeCodeScaleOffsets = findNextElement(TIMECODESCALE_ID, [ SEGMENT_ID, INFO_ID ], buffer, [ initialOffset, buffer.length ]);
            if (null == timeCodeScaleOffsets) return null;
            var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
            return 1e9 / bytesToNumber(buffer, timeCodeScaleOffsets[0], length);
        }
        /**
 * Return the duration of the concerned media.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */        function getDuration(buffer, initialOffset) {
            var timeCodeScaleOffsets = findNextElement(DURATION_ID, [ SEGMENT_ID, INFO_ID ], buffer, [ initialOffset, buffer.length ]);
            if (null == timeCodeScaleOffsets) return null;
            var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
            return 4 === length ? get_IEEE754_32Bits(buffer, timeCodeScaleOffsets[0]) : 8 === length ? get_IEEE754_64Bits(buffer, timeCodeScaleOffsets[0]) : null;
        }
        /**
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {Array.<Object>|null}
 */        function getSegmentsFromCues(buffer, initialOffset) {
            var segmentRange = findNextElement(SEGMENT_ID, [], buffer, [ initialOffset, buffer.length ]);
            if (null == segmentRange) return null;
            var segmentRangeStart = segmentRange[0], segmentRangeEnd = segmentRange[1], timescale = getTimeCodeScale(buffer, segmentRangeStart);
            if (null == timescale) return null;
            var duration = getDuration(buffer, segmentRangeStart);
            if (null == duration) return null;
            var cuesRange = findNextElement(475249515, [], buffer, [ segmentRangeStart, segmentRangeEnd ]);
            if (null == cuesRange) return null;
            for (var rawInfos = [], currentOffset = cuesRange[0]; currentOffset < cuesRange[1]; ) {
                var cuePointRange = findNextElement(187, [], buffer, [ currentOffset, cuesRange[1] ]);
                if (null == cuePointRange) break;
                var cueTimeRange = findNextElement(179, [], buffer, [ cuePointRange[0], cuePointRange[1] ]);
                if (null == cueTimeRange) return null;
                var time = bytesToNumber(buffer, cueTimeRange[0], cueTimeRange[1] - cueTimeRange[0]), cueOffsetRange = findNextElement(241, [ 183 ], buffer, [ cuePointRange[0], cuePointRange[1] ]);
                if (null == cueOffsetRange) return null;
                var rangeStart = bytesToNumber(buffer, cueOffsetRange[0], cueOffsetRange[1] - cueOffsetRange[0]) + segmentRangeStart;
                rawInfos.push({
                    time: time,
                    rangeStart: rangeStart
                }), currentOffset = cuePointRange[1];
            }
            for (var segments = [], i = 0; i < rawInfos.length; i++) {
                var currentSegment = rawInfos[i];
                i === rawInfos.length - 1 ? segments.push({
                    time: currentSegment.time,
                    count: 0,
                    timescale: timescale,
                    duration: 0 === i ? duration : duration - currentSegment.time,
                    range: [ currentSegment.rangeStart, Infinity ]
                }) : segments.push({
                    time: currentSegment.time,
                    count: 0,
                    timescale: timescale,
                    duration: rawInfos[i + 1].time - currentSegment.time,
                    range: [ currentSegment.rangeStart, rawInfos[i + 1].rangeStart - 1 ]
                });
            }
            return segments;
        }
        // EXTERNAL MODULE: ./node_modules/array-find/find.js
                var find = __webpack_require__(11), find_default = /* */ __webpack_require__.n(find), config = __webpack_require__(2), array_includes = __webpack_require__(13), utils_id = __webpack_require__(21), languages = __webpack_require__(84), utils_url = __webpack_require__(39), check_manifest_ids = __webpack_require__(81), assert = __webpack_require__(14), iso8601Duration = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/, rangeRe = /([0-9]+)-([0-9]+)/;
        /**
 * Parse MPD boolean attributes.
 * @param {string} str
 * @returns {Boolean}
 */
        function parseBoolean(str) {
            return "true" === str;
        }
        /**
 * Parse some MPD attributes.
 * @param {string} str
 * @returns {Boolean|Number}
 */        function parseIntOrBoolean(str) {
            return "true" === str || "false" !== str && parseInt(str, 10);
        }
        /**
 * Parse MPD date attributes.
 * @param {string} str
 * @returns {Date}
 */        function parseDateTime(str) {
            return new Date(Date.parse(str)).getTime() / 1e3;
        }
        /**
 * Parse MPD ISO8601 duration attributes into seconds.
 * @param {string} date
 * @returns {Number}
 */        function parseDuration(date) {
            if (!date) return 0;
            var match = iso8601Duration.exec(date);
            return Object(assert.b)(!!match, date + " is not a valid ISO8601 duration"), 365 * parseFloat(match[2] || "0") * 24 * 60 * 60 + 30 * parseFloat(match[4] || "0") * 24 * 60 * 60 + // not precise +
            24 * parseFloat(match[6] || "0") * 60 * 60 + 60 * parseFloat(match[8] || "0") * 60 + 60 * parseFloat(match[10] || "0") + parseFloat(match[12] || "0");
        }
        /**
 * Parse MPD ratio attributes.
 * @param {string} str
 * @returns {string}
 */        function parseRatio(str) {
            return str;
        }
        /**
 * Parse MPD byterange attributes into arrays of two elements: the start and
 * the end.
 * @param {string} str
 * @returns {Array.<Number>}
 */        function parseByteRange(str) {
            var match = rangeRe.exec(str);
            return match ? [ +match[1], +match[2] ] : null;
        }
        /**
 * Detect if the accessibility given defines an adaptation for the visually
 * impaired.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */        function isVisuallyImpaired(accessibility) {
            return !!accessibility && ("urn:tva:metadata:cs:AudioPurposeCS:2007" === accessibility.schemeIdUri && "1" === accessibility.value);
        }
        /**
 * Detect if the accessibility given defines an adaptation for the hard of
 * hearing.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */        function isHardOfHearing(accessibility) {
            return !!accessibility && ("urn:tva:metadata:cs:AudioPurposeCS:2007" === accessibility.schemeIdUri && "2" === accessibility.value);
        }
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseScheme(root) {
            for (var schemeIdUri, value, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "schemeIdUri":
                    schemeIdUri = attribute.value;
                    break;

                  case "value":
                    value = attribute.value;
                }
            }
            return {
                schemeIdUri: schemeIdUri,
                value: value
            };
        }
        /**
 * Pad with 0 in the left of the given n argument to reach l length
 * @param {Number|string} n
 * @param {Number} l
 * @returns {string}
 */        function pad(n, l) {
            var nToString = n.toString();
            return nToString.length >= l ? nToString : (new Array(l + 1).join("0") + nToString).slice(-l);
        }
        function processFormatedToken(replacer) {
            return function(_match, _format, widthStr) {
                var width = widthStr ? parseInt(widthStr, 10) : 1;
                return pad("" + replacer, width);
            };
        }
        /**
 * @param {string} representationURL
 * @param {string|undefined} media
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */        function createIndexURL(representationURL, media, id, bitrate) {
            return replaceRepresentationDASHTokens(Object(utils_url.b)(representationURL, media), id, bitrate);
        }
        /**
 * Replace "tokens" written in a given path (e.g. $RepresentationID$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */        function replaceRepresentationDASHTokens(path, id, bitrate) {
            return -1 === path.indexOf("$") ? path : path.replace(/\$\$/g, "$").replace(/\$RepresentationID\$/g, String(id)).replace(/\$Bandwidth(|\%0(\d+)d)\$/g, processFormatedToken(bitrate || 0));
        }
        /**
 * Replace "tokens" written in a given path (e.g. $Time$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {number} time
 * @param {number} number
 * @returns {string}
 *
 * @throws Error - Throws if we do not have enough data to construct the URL
 */        function replaceSegmentDASHTokens(path, time, number) {
            return -1 === path.indexOf("$") ? path : path.replace(/\$\$/g, "$").replace(/\$Number(|\%0(\d+)d)\$/g, function(_x, _y, widthStr) {
                if (null == number) throw new Error("Segment number not defined in a $Number$ scheme");
                return processFormatedToken(number)(_x, _y, widthStr);
            }).replace(/\$Time(|\%0(\d+)d)\$/g, function(_x, _y, widthStr) {
                if (null == time) throw new Error("Segment time not defined in a $Time$ scheme");
                return processFormatedToken(time)(_x, _y, widthStr);
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/helpers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Calculate the number of times a timeline element repeat based on the next
 * segment.
 * @param {Object} element
 * @param {Object} nextElement
 * @returns {Number}
 */        function calculateRepeat(element, nextElement) {
            var rep = element.repeatCount || 0;
 // A negative value of the @r attribute of the S element indicates
            // that the duration indicated in @d attribute repeats until the
            // start of the next S element, the end of the Period or until the
            // next MPD update.
                        if (rep < 0) {
                var repEnd = nextElement ? nextElement.start : Infinity;
                rep = Math.ceil((repEnd - element.start) / element.duration) - 1;
            }
            return rep;
        }
        /**
 * Convert from `presentationTime`, the time of the segment at the moment it
 * is decoded to `mediaTime`, the original time the segments point at.
 * @param {Object} index
 * @param {number} time
 * @returns {number}
 */        function toIndexTime(index, time) {
            return time * index.timescale + index.indexTimeOffset;
        }
        /**
 * Convert from `mediaTime`, the original time the segments point at to
 * `presentationTime`, the time of the segment at the moment it is decoded.
 * @param {Object} index
 * @param {number} time
 * @returns {number}
 */        function fromIndexTime(index, time) {
            return (time - index.indexTimeOffset) / index.timescale;
        }
        /**
 * @param {Object} index
 * @param {Number} start
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */        function getTimescaledRange(index, start, duration) {
            var timescale = index.timescale || 1;
            return {
                up: start * timescale,
                to: (start + duration) * timescale
            };
        }
        /**
 * Get start of the given index range, timescaled.
 * @param {Object} element
 * @returns {Number} - absolute start time of the range
 */        function getTimelineItemRangeStart(_ref) {
            var start = _ref.start, duration = _ref.duration, repeatCount = _ref.repeatCount;
            return -1 === duration ? start : start + repeatCount * duration;
        }
        /**
 * Get end of the given index range, timescaled.
 * @param {Object} element
 * @returns {Number} - absolute end time of the range
 */        function getTimelineItemRangeEnd(_ref2) {
            var start = _ref2.start, duration = _ref2.duration, repeatCount = _ref2.repeatCount;
            return -1 === duration ? start : start + (repeatCount + 1) * duration;
        }
        /**
 * Construct init segment for the given index.
 * @param {Object} index
 * @returns {Object}
 */        function helpers_getInitSegment(index) {
            var initialization = index.initialization;
            return {
                id: "init",
                isInit: !0,
                time: 0,
                range: initialization && initialization.range || void 0,
                indexRange: index.indexRange || void 0,
                mediaURL: initialization ? initialization.mediaURL : null,
                timescale: index.timescale,
                timestampOffset: -index.indexTimeOffset / index.timescale
            };
        }
        /**
 * For the given start time and duration of a timeline element, calculate how
 * much this element should be repeated to contain the time given.
 * 0 being the same element, 1 being the next one etc.
 * @param {Number} segmentStartTime
 * @param {Number} segmentDuration
 * @param {Number} wantedTime
 * @returns {Number}
 */        function getWantedRepeatIndex(segmentStartTime, segmentDuration, wantedTime) {
            var diff = wantedTime - segmentStartTime;
            return 0 < diff ? Math.floor(diff / segmentDuration) : 0;
        }
        /**
 * Get a list of Segments for the time range wanted.
 * @param {Object} index - index object, constructed by parsing the manifest.
 * @param {number} from - starting timestamp wanted, in seconds
 * @param {number} duration - duration wanted, in seconds
 * @param {number} indexTimeOffset - offset used to convert from decoding
 * time (used by the `from` argument) to manifest time (used in the `index`
 * argument). Basically, we should be able to convert the `from` argument into
 * manifest time by doing something like:
 * ``from * index.timescale + indexTimeOffset``
 */        function getSegmentsFromTimeline(index, from, durationWanted) {
            for (var scaledUp = toIndexTime(index, from), scaledTo = toIndexTime(index, from + durationWanted), timeline = index.timeline, timescale = index.timescale, mediaURL = index.mediaURL, startNumber = index.startNumber, currentNumber = null != startNumber ? startNumber : void 0, segments = [], timelineLength = timeline.length, maxEncounteredDuration = timeline.length && timeline[0].duration || 0, i = 0; i < timelineLength; i++) {
                var timelineItem = timeline[i], duration = timelineItem.duration, start = timelineItem.start, range = timelineItem.range;
                // live-added segments have @d attribute equals to -1
                if (maxEncounteredDuration = Math.max(maxEncounteredDuration, duration), duration < 0) {
                    // what? May be to play it safe and avoid adding segments which are
                    // not completely generated
                    if (start + maxEncounteredDuration < scaledTo) {
                        var segmentNumber = null != currentNumber ? currentNumber : void 0, segment = {
                            id: "" + start,
                            time: start - index.indexTimeOffset,
                            isInit: !1,
                            range: range,
                            duration: void 0,
                            timescale: timescale,
                            mediaURL: replaceSegmentDASHTokens(mediaURL, start, segmentNumber),
                            number: segmentNumber,
                            timestampOffset: -index.indexTimeOffset / timescale
                        };
                        segments.push(segment);
                    }
                    return segments;
                }
                for (var repeat = calculateRepeat(timelineItem, timeline[i + 1]), segmentNumberInCurrentRange = getWantedRepeatIndex(start, duration, scaledUp), segmentTime = start + segmentNumberInCurrentRange * duration; segmentTime < scaledTo && segmentNumberInCurrentRange <= repeat; ) {
                    var _segmentNumber = null != currentNumber ? currentNumber + segmentNumberInCurrentRange : void 0, _segment = {
                        id: "" + segmentTime,
                        time: segmentTime - index.indexTimeOffset,
                        isInit: !1,
                        range: range,
                        duration: duration,
                        timescale: timescale,
                        mediaURL: replaceSegmentDASHTokens(mediaURL, segmentTime, _segmentNumber),
                        number: _segmentNumber,
                        timestampOffset: -index.indexTimeOffset / timescale
                    };
                    segments.push(_segment), segmentTime = start + // update segment number and segment time for the next segment
                    ++segmentNumberInCurrentRange * duration;
                }
                if (scaledTo <= segmentTime) 
                // we reached ``scaledTo``, we're done
                return segments;
                null != currentNumber && (currentNumber += repeat + 1);
            }
            return segments;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/base.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} segmentInfos
 * @returns {Boolean} - true if the segment has been added
 */        function _addSegmentInfos(index, segmentInfos) {
            if (segmentInfos.timescale !== index.timescale) {
                var timescale = index.timescale;
                index.timeline.push({
                    start: segmentInfos.time / segmentInfos.timescale * timescale,
                    duration: segmentInfos.duration / segmentInfos.timescale * timescale,
                    repeatCount: segmentInfos.count || 0,
                    range: segmentInfos.range
                });
            } else index.timeline.push({
                start: segmentInfos.time,
                duration: segmentInfos.duration,
                repeatCount: segmentInfos.count || 0,
                range: segmentInfos.range
            });
            return !0;
        }
        /**
 * Provide helpers for SegmentBase-based indexes.
 * @type {Object}
 */        var base_BaseRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} index
   * @param {Object} context
   */
            function BaseRepresentationIndex(index, context) {
                var periodStart = context.periodStart, representationURL = context.representationURL, representationId = context.representationId, representationBitrate = context.representationBitrate, indexTimeOffset = (null != index.presentationTimeOffset ? index.presentationTimeOffset : 0) - periodStart * index.timescale;
                this._index = {
                    mediaURL: createIndexURL(representationURL, index.media, representationId, representationBitrate),
                    timeline: index.timeline,
                    timescale: index.timescale,
                    duration: index.duration,
                    indexTimeOffset: indexTimeOffset,
                    indexRange: index.indexRange,
                    startNumber: index.startNumber,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    }
                };
            }
            /**
   * Construct init Segment.
   * @returns {Object}
   */            var _proto = BaseRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return helpers_getInitSegment(this._index);
            }, 
            /**
   * @param {Number} _up
   * @param {Number} _to
   * @returns {Array.<Object>}
   */
            _proto.getSegments = function getSegments(_up, _to) {
                return getSegmentsFromTimeline(this._index, _up, _to);
            }, 
            /**
   * Returns false as no Segment-Base based index should need to be refreshed.
   * @returns {Boolean}
   */
            _proto.shouldRefresh = function shouldRefresh() {
                return !1;
            }, 
            /**
   * Returns first position in index.
   * @returns {Number|undefined}
   */
            _proto.getFirstPosition = function getFirstPosition() {
                var index = this._index;
                if (index.timeline.length) return fromIndexTime(index, index.timeline[0].start);
            }, 
            /**
   * Returns last position in index.
   * @returns {Number|undefined}
   */
            _proto.getLastPosition = function getLastPosition() {
                var index = this._index;
                if (index.timeline.length) return fromIndexTime(index, getTimelineItemRangeStart(index.timeline[index.timeline.length - 1]));
            }, 
            /**
   * We do not check for discontinuity in SegmentBase-based indexes.
   * @returns {Number}
   */
            _proto.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }, 
            /**
   * @param {Array.<Object>} nextSegments
   * @returns {Array.<Object>}
   */
            _proto._addSegments = function _addSegments(nextSegments) {
                for (var i = 0; i < nextSegments.length; i++) _addSegmentInfos(this._index, nextSegments[i]);
            }, 
            /**
   * @param {Object} newIndex
   */
            _proto._update = function _update(newIndex) {
                this._index = newIndex._index;
            }, BaseRepresentationIndex;
        }(), list_ListRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} index
   * @param {Object} context
   */
            function ListRepresentationIndex(index, context) {
                var periodStart = context.periodStart, representationURL = context.representationURL, representationId = context.representationId, representationBitrate = context.representationBitrate;
                this._periodStart = periodStart;
                var indexTimeOffset = (null != index.presentationTimeOffset ? index.presentationTimeOffset : 0) - periodStart * index.timescale;
                this._index = {
                    list: index.list.map(function(lItem) {
                        return {
                            mediaURL: createIndexURL(representationURL, lItem.media, representationId, representationBitrate),
                            mediaRange: lItem.mediaRange
                        };
                    }),
                    timescale: index.timescale,
                    duration: index.duration,
                    indexTimeOffset: indexTimeOffset,
                    indexRange: index.indexRange,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    }
                };
            }
            /**
   * Construct init Segment.
   * @returns {Object}
   */            var _proto = ListRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return helpers_getInitSegment(this._index);
            }, 
            /**
   * @param {Number} fromTime
   * @param {Number} duration
   * @returns {Array.<Object>}
   */
            _proto.getSegments = function getSegments(fromTime, dur) {
                for (var index = this._index, _getTimescaledRange = getTimescaledRange(index, fromTime + this._periodStart, dur), up = _getTimescaledRange.up, to = _getTimescaledRange.to, duration = index.duration, list = index.list, timescale = index.timescale, length = Math.min(list.length - 1, Math.floor(to / duration)), segments = [], i = Math.floor(up / duration); i <= length; ) {
                    var args = {
                        id: "" + i,
                        time: i * duration,
                        isInit: !1,
                        range: list[i].mediaRange,
                        duration: duration,
                        timescale: timescale,
                        mediaURL: list[i].mediaURL,
                        timestampOffset: -index.indexTimeOffset / timescale
                    };
                    segments.push(args), i++;
                }
                return segments;
            }, 
            /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * (If we should re-fetch the manifest)
   * @param {Number} _fromTime
   * @param {Number} toTime
   * @returns {Boolean}
   */
            _proto.shouldRefresh = function shouldRefresh(_fromTime, toTime) {
                var _this$_index = this._index, timescale = _this$_index.timescale, duration = _this$_index.duration, list = _this$_index.list, scaledTo = toTime * timescale, i = Math.floor(scaledTo / duration);
                return !(0 <= i && i < list.length);
            }, 
            /**
   * Returns first position in index.
   * @returns {Number}
   */
            _proto.getFirstPosition = function getFirstPosition() {
                return this._periodStart;
            }, 
            /**
   * Returns last position in index.
   * @returns {Number}
   */
            _proto.getLastPosition = function getLastPosition() {
                var index = this._index, duration = index.duration;
                return index.list.length * duration / index.timescale + this._periodStart;
            }, 
            /**
   * We do not check for discontinuity in SegmentList-based indexes.
   * @returns {Number}
   */
            _proto.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }, 
            /**
   * @param {Object} newIndex
   */
            _proto._update = function _update(newIndex) {
                this._index = newIndex._index;
            }, 
            /**
   * We do not have to add new segments to SegmentList-based indexes.
   * @returns {Array}
   */
            _proto._addSegments = function _addSegments() {
                0;
            }, ListRepresentationIndex;
        }(), template_TemplateRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} index
   * @param {Object} context
   */
            function TemplateRepresentationIndex(index, context) {
                var periodStart = context.periodStart, representationURL = context.representationURL, representationId = context.representationId, representationBitrate = context.representationBitrate;
                this._periodStart = periodStart;
                var presentationTimeOffset = null != index.presentationTimeOffset ? index.presentationTimeOffset : 0, indexTimeOffset = presentationTimeOffset - periodStart * index.timescale;
                this._index = {
                    duration: index.duration,
                    timescale: index.timescale,
                    indexRange: index.indexRange,
                    indexTimeOffset: indexTimeOffset,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    },
                    mediaURL: createIndexURL(representationURL, index.media, representationId, representationBitrate),
                    presentationTimeOffset: presentationTimeOffset,
                    startNumber: index.startNumber
                };
            }
            /**
   * Construct init Segment.
   * @returns {Object}
   */            var _proto = TemplateRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return helpers_getInitSegment(this._index);
            }, 
            /**
   * @param {Number} fromTime
   * @param {Number} dur
   * @returns {Array.<Object>}
   */
            _proto.getSegments = function getSegments(fromTime, dur) {
                var index = this._index, _getTimescaledRange = getTimescaledRange(index, fromTime, dur), up = _getTimescaledRange.up, to = _getTimescaledRange.to;
                if (to <= up) return [];
                for (var duration = index.duration, startNumber = index.startNumber, timescale = index.timescale, mediaURL = index.mediaURL, segments = [], baseTime = up; baseTime <= to; baseTime += duration) {
                    var periodRelativeStart = baseTime - this._periodStart * timescale, baseNumber = Math.floor(periodRelativeStart / duration), number = baseNumber + (null == startNumber ? 1 : startNumber), manifestTime = baseNumber * duration + (this._index.presentationTimeOffset || 0), args = {
                        id: "" + number,
                        number: number,
                        time: baseNumber * duration + this._periodStart * this._index.timescale,
                        isInit: !1,
                        duration: duration,
                        timescale: timescale,
                        mediaURL: replaceSegmentDASHTokens(mediaURL, manifestTime, number),
                        timestampOffset: -index.indexTimeOffset / timescale
                    };
                    segments.push(args);
                }
                return segments;
            }, 
            /**
   * Returns first position in index.
   * @returns {undefined}
   */
            _proto.getFirstPosition = function getFirstPosition() {}, 
            /**
   * Returns last position in index.
   * @returns {undefined}
   */
            _proto.getLastPosition = function getLastPosition() {}, 
            /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * We never have to refresh a SegmentTemplate-based manifest.
   * @returns {Boolean}
   */
            _proto.shouldRefresh = function shouldRefresh() {
                return !1;
            }, 
            /**
   * We cannot check for discontinuity in SegmentTemplate-based indexes.
   * @returns {Number}
   */
            _proto.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }, 
            /**
   * We do not have to add new segments to SegmentList-based indexes.
   * @returns {Array}
   */
            _proto._addSegments = function _addSegments() {
                0;
            }, 
            /**
   * @param {Object} newIndex
   */
            _proto._update = function _update(newIndex) {
                this._index = newIndex._index;
            }, TemplateRepresentationIndex;
        }();
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/list.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Provide helpers for SegmentList-based DASH indexes.
 * @type {Object}
 */        
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} start
 * @returns {Number}
 */
        function getSegmentIndex(index, start) {
            for (var timeline = index.timeline, low = 0, high = timeline.length; low < high; ) {
                var mid = low + high >>> 1;
                timeline[mid].start < start ? low = mid + 1 : high = mid;
            }
            return 0 < low ? low - 1 : low;
        }
        /**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Object} currentSegmentInfos
 * @param {Number} indexTimeOffset
 * @returns {Boolean} - true if the segment has been added
 */        function timeline_addSegmentInfos(index, newSegment, currentSegmentInfos) {
            var scaledCurrentTime, timeline = index.timeline, timescale = index.timescale, timelineLength = timeline.length, lastItem = timeline[timelineLength - 1], scaledNewSegment = newSegment.timescale === timescale ? {
                time: newSegment.time,
                duration: newSegment.duration
            } : {
                time: newSegment.time / newSegment.timescale * timescale,
                duration: newSegment.duration / newSegment.timescale * timescale
            };
            if (currentSegmentInfos && currentSegmentInfos.timescale && (scaledCurrentTime = (currentSegmentInfos.timescale === timescale ? currentSegmentInfos.time : currentSegmentInfos.time / currentSegmentInfos.timescale * timescale) + index.indexTimeOffset), 
            null == scaledCurrentTime || scaledNewSegment.time !== scaledCurrentTime) return scaledNewSegment.time >= getTimelineItemRangeEnd(lastItem) && (lastItem.duration === scaledNewSegment.duration ? lastItem.repeatCount++ : index.timeline.push({
                duration: scaledNewSegment.duration,
                start: scaledNewSegment.time,
                repeatCount: 0
            }), !0);
            var newSegmentStart = scaledNewSegment.time + scaledNewSegment.duration, startDiff = newSegmentStart - (lastItem.start + lastItem.duration * lastItem.repeatCount);
            if (startDiff <= 0) 
            // same segment / behind the lastItem
            return !1;
 // try to use the compact notation with @r attribute on the lastItem
            // to elements of the timeline if we find out they have the same
            // duration
                        if (-1 === lastItem.duration) {
                var prev = timeline[timelineLength - 2];
                prev && prev.duration === startDiff ? (prev.repeatCount++, timeline.pop()) : lastItem.duration = startDiff;
            }
            return index.timeline.push({
                duration: -1,
                start: newSegmentStart,
                repeatCount: 0
            }), !0;
        }
        var timeline_TimelineRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} index
   * @param {Object} context
   */
            function TimelineRepresentationIndex(index, context) {
                var representationURL = context.representationURL, representationId = context.representationId, representationBitrate = context.representationBitrate, periodStart = context.periodStart, indexTimeOffset = (null != index.presentationTimeOffset ? index.presentationTimeOffset : 0) - periodStart * index.timescale;
                this._index = {
                    duration: index.duration,
                    indexTimeOffset: indexTimeOffset,
                    indexRange: index.indexRange,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    },
                    mediaURL: createIndexURL(representationURL, index.media, representationId, representationBitrate),
                    startNumber: index.startNumber,
                    timeline: index.timeline,
                    timescale: index.timescale
                };
            }
            /**
   * Construct init Segment.
   * @returns {Object}
   */            var _proto = TimelineRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return helpers_getInitSegment(this._index);
            }, 
            /**
   * Asks for segments to download for a given time range.
   * @param {Number} from - Beginning of the time wanted, in seconds
   * @param {Number} duration - duration wanted, in seconds
   * @returns {Array.<Object>}
   */
            _proto.getSegments = function getSegments(from, duration) {
                return getSegmentsFromTimeline(this._index, from, duration);
            }, 
            /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * @param {Number} _start
   * @param {Number} end
   * @returns {Boolean}
   */
            _proto.shouldRefresh = function shouldRefresh(_start, end) {
                var timeline = this._index.timeline, scaledTo = toIndexTime(this._index, end), lastItem = timeline[timeline.length - 1];
                return !!lastItem && (lastItem.duration < 0 && (lastItem = {
                    start: lastItem.start,
                    duration: 0,
                    repeatCount: lastItem.repeatCount
                }), scaledTo > getTimelineItemRangeEnd(lastItem));
            }, 
            /**
   * Returns first position in index.
   * @returns {Number|undefined}
   */
            _proto.getFirstPosition = function getFirstPosition() {
                var index = this._index;
                if (index.timeline.length) return fromIndexTime(index, index.timeline[0].start);
            }, 
            /**
   * Returns lastItem position in index.
   * @returns {Number|undefined}
   */
            _proto.getLastPosition = function getLastPosition() {
                var index = this._index;
                if (index.timeline.length) return fromIndexTime(index, getTimelineItemRangeEnd(index.timeline[index.timeline.length - 1]));
            }, 
            /**
   * Checks if the time given is in a discontinuity. That is:
   *   - We're on the upper bound of the current range (end of the range - time
   *     is inferior to the timescale)
   *   - The next range starts after the end of the current range.
   * @param {Number} _time
   * @returns {Number} - If a discontinuity is present, this is the Starting
   * time for the next (discontinuited) range. If not this is equal to -1.
   */
            _proto.checkDiscontinuity = function checkDiscontinuity(_time) {
                var _this$_index = this._index, timeline = _this$_index.timeline, timescale = _this$_index.timescale, scaledTime = toIndexTime(this._index, _time);
                if (scaledTime <= 0) return -1;
                var segmentIndex = getSegmentIndex(this._index, scaledTime);
                if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) return -1;
                var timelineItem = timeline[segmentIndex];
                if (-1 === timelineItem.duration) return -1;
                var nextRange = timeline[segmentIndex + 1];
                if (null == nextRange) return -1;
                var rangeUp = timelineItem.start, rangeTo = getTimelineItemRangeEnd(timelineItem);
                // when we are actually inside the found range and this range has
                // an explicit discontinuity with the next one
                return rangeTo !== nextRange.start && rangeUp <= scaledTime && scaledTime <= rangeTo && rangeTo - scaledTime < timescale ? fromIndexTime(this._index, nextRange.start) : -1;
            }, 
            /**
   * @param {Object} newIndex
   */
            _proto._update = function _update(newIndex) {
                this._index = newIndex._index;
            }, 
            /**
   * We do not have to add new segments to SegmentList-based indexes.
   * @param {Array.<Object>} nextSegments
   * @param {Object|undefined} currentSegmentInfos
   * @returns {Array}
   */
            _proto._addSegments = function _addSegments(nextSegments, currentSegmentInfos) {
                for (var i = 0; i < nextSegments.length; i++) timeline_addSegmentInfos(this._index, nextSegments[i], currentSegmentInfos);
            }, TimelineRepresentationIndex;
        }();
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentComponent.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse a "ContentComponent" Element in a DASH MPD.
 * @param {Element} root
 * @returns {Object}
 */        function parseContentComponent(root) {
            for (var ret = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "id":
                    ret.id = attribute.value;
                    break;

                  case "lang":
                    ret.language = attribute.value;
                    break;

                  case "contentType":
                    ret.contentType = attribute.value;
                    break;

                  case "par":
                    ret.par = parseRatio(attribute.value);
                }
            }
            return ret;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentProtection.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse the "ContentProtection" node of a MPD.
 * @param {Element} root
 * @returns {Object}
 */        function parseContentProtection(root) {
            for (var schemeIdUri, value, keyId, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "schemeIdUri":
                    schemeIdUri = attribute.value;
                    break;

                  case "value":
                    value = attribute.value;
                    break;

                  case "cenc:default_KID":
                    keyId = attribute.value.toString().split("-").join("").toUpperCase();
                }
            }
 // TODO Take systemId from PSSH?
            // for (let i = 0; i < root.childElementCount; i++) {
            //   const child = root.children[i];
            //   if (child.nodeName === "cenc:pssh" && child.textContent) {
            //     pssh = atob(child.textContent);
            //   }
            // }
                        return {
                schemeIdUri: schemeIdUri,
                value: value,
                keyId: keyId
            };
        }
        // EXTERNAL MODULE: ./node_modules/object-assign/index.js
                var object_assign = __webpack_require__(6), object_assign_default = /* */ __webpack_require__.n(object_assign);
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Initialization.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */
        function parseInitialization(root) {
            for (var parsedInitialization = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "range":
                    var range = parseByteRange(attribute.value) || void 0;
                    range ? parsedInitialization.range = range : log.a.warn('DASH: invalid range ("' + attribute.value + '")');
                    break;

                  case "sourceURL":
                    parsedInitialization.media = attribute.value;
                }
            }
            return parsedInitialization;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentBase.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentBase(root) {
            for (var attributes = {}, segmentBaseChildren = root.childNodes, i = 0; i < segmentBaseChildren.length; i++) if (segmentBaseChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = segmentBaseChildren[i];
                "Initialization" === currentNode.nodeName && (attributes.initialization = parseInitialization(currentNode));
            }
            for (var _i = 0; _i < root.attributes.length; _i++) {
                var attribute = root.attributes[_i];
                switch (attribute.name) {
                  case "timescale":
                    var _timescale = parseInt(attribute.value, 10);
                    isNaN(_timescale) ? log.a.warn('DASH: invalid timescale ("' + attribute.value + '")') : attributes.timescale = _timescale;
                    break;

                  case "timeShiftBufferDepth":
                    var timeShiftBufferDepth = parseDuration(attribute.value);
                    isNaN(timeShiftBufferDepth) ? log.a.warn('DASH: invalid timeShiftBufferDepth ("' + attribute.value + '")') : attributes.timeShiftBufferDepth = timeShiftBufferDepth;
                    break;

                  case "presentationTimeOffset":
                    var _presentationTimeOffset = parseFloat(attribute.value);
                    isNaN(_presentationTimeOffset) ? log.a.warn('DASH: invalid presentationTimeOffset ("' + attribute.value + '")') : attributes.presentationTimeOffset = _presentationTimeOffset;
                    break;

                  case "indexRange":
                    attributes.indexRange = parseByteRange(attribute.value) || void 0;
                    break;

                  case "indexRangeExact":
                    attributes.indexRangeExact = parseBoolean(attribute.value);
                    break;

                  case "availabilityTimeOffset":
                    var availabilityTimeOffset = parseFloat(attribute.value);
                    isNaN(availabilityTimeOffset) ? log.a.warn('DASH: invalid availabilityTimeOffset ("' + attribute.value + '")') : attributes.availabilityTimeOffset = availabilityTimeOffset;
                    break;

                  case "availabilityTimeComplete":
                    attributes.availabilityTimeComplete = parseBoolean(attribute.value);
                    break;

                  case "duration":
                    var duration = parseInt(attribute.value, 10);
                    isNaN(duration) ? log.a.warn('DASH: invalid duration ("' + attribute.value + '")') : attributes.duration = duration;
                    break;

                  case "startNumber":
                    var startNumber = parseInt(attribute.value, 10);
                    isNaN(startNumber) ? log.a.warn('DASH: invalid startNumber ("' + attribute.value + '")') : attributes.startNumber = startNumber;
                }
            }
            var timescale = null == attributes.timescale ? 1 : attributes.timescale, indexRangeExact = !!attributes.indexRangeExact, availabilityTimeComplete = null == attributes.availabilityTimeComplete || attributes.availabilityTimeComplete;
            return object_assign_default()(attributes, {
                availabilityTimeComplete: availabilityTimeComplete,
                indexRangeExact: indexRangeExact,
                timeline: [],
                timescale: timescale
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentURL.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentURL(root) {
            for (var parsedSegmentURL = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "media":
                    parsedSegmentURL.media = attribute.value;
                    break;

                  case "indexRange":
                    var indexRange = parseByteRange(attribute.value) || void 0;
                    indexRange ? parsedSegmentURL.indexRange = indexRange : log.a.warn('DASH: invalid indexRange ("' + attribute.value + '")');
                    break;

                  case "index":
                    parsedSegmentURL.index = attribute.value;
                    break;

                  case "mediaRange":
                    var mediaRange = parseByteRange(attribute.value) || void 0;
                    mediaRange ? parsedSegmentURL.mediaRange = mediaRange : log.a.warn('DASH: invalid mediaRange ("' + attribute.value + '")');
                }
            }
            return parsedSegmentURL;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentList.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentList(root) {
            for (var base = parseSegmentBase(root), list = [], segmentListChildren = root.childNodes, i = 0; i < segmentListChildren.length; i++) if (segmentListChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = segmentListChildren[i];
                if ("SegmentURL" === currentNode.nodeName) {
                    var segmentURL = parseSegmentURL(currentNode);
                    list.push(segmentURL);
                }
            }
            var baseDuration = base.duration;
            if (null == baseDuration) throw new Error("Invalid SegmentList: no duration");
            return object_assign_default()(base, {
                list: list,
                duration: baseDuration
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/S.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseS(root) {
            for (var start, duration, repeatCount, j = 0; j < root.attributes.length; j++) {
                var attribute = root.attributes[j];
                switch (attribute.name) {
                  case "t":
                    start = parseInt(attribute.value, 10);
                    break;

                  case "d":
                    duration = parseInt(attribute.value, 10);
                    break;

                  case "r":
                    repeatCount = parseInt(attribute.value, 10);
                }
            }
            return {
                start: start,
                duration: duration,
                repeatCount: repeatCount
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTimeline.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function fromParsedSToTimelineElement(parsedS, previousS, nextS) {
            var start = parsedS.start, duration = parsedS.duration, repeatCount = parsedS.repeatCount;
            return null == start && previousS && null != previousS.duration && (start = previousS.start + previousS.duration * (previousS.repeatCount + 1)), 
            null != duration && !isNaN(duration) || !nextS || null == nextS.start || isNaN(nextS.start) || null == start || isNaN(start) || (duration = nextS.start - start), 
            null == start || isNaN(start) || null == duration || isNaN(duration) || null != repeatCount && isNaN(repeatCount) ? (log.a.warn('DASH: A "S" Element could not have been parsed.'), 
            null) : {
                start: start,
                duration: duration,
                repeatCount: repeatCount || 0
            };
        }
        /**
 * @param {Element} root
 * @returns {Array.<Object>}
 */        function parseSegmentTimeline(root) {
            for (var timeline = [], parsedS = [], timelineChildren = root.childNodes, i = 0; i < timelineChildren.length; i++) if (timelineChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = timelineChildren[i];
                if ("S" === currentElement.nodeName) {
                    var s = parseS(currentElement);
                    s && parsedS.push(s);
                }
            }
            for (var _i = 0; _i < parsedS.length; _i++) {
                var timelineElement = fromParsedSToTimelineElement(parsedS[_i], timeline[timeline.length - 1] || null, parsedS[_i + 1] || null);
                timelineElement && timeline.push(timelineElement);
            }
            return timeline;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTemplate.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse initialization attribute found in segment Template to
 * correspond to the initialization found in a regular segmentBase.
 * @param {string} attrValue
 * @returns {Object}
 */        function parseInitializationAttribute(attrValue) {
            return {
                media: attrValue
            };
        }
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentTemplate(root) {
            for (var ret, index, media, bitstreamSwitching, timeline, base = parseSegmentBase(root), i = 0; i < root.childNodes.length; i++) if (root.childNodes[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = root.childNodes[i];
                "SegmentTimeline" === currentNode.nodeName && (timeline = parseSegmentTimeline(currentNode));
            }
            for (var _i = 0; _i < root.attributes.length; _i++) {
                var attribute = root.attributes[_i];
                switch (attribute.nodeName) {
                  case "initialization":
                    null == base.initialization && (base.initialization = parseInitializationAttribute(attribute.value));
                    break;

                  case "index":
                    index = attribute.value;
                    break;

                  case "media":
                    media = attribute.value;
                    break;

                  case "bitstreamSwitching":
                    bitstreamSwitching = parseBoolean(attribute.value);
                }
            }
            if (null != timeline) ret = object_assign_default()({}, base, {
                indexType: "timeline",
                timeline: timeline
            }); else {
                var segmentDuration = base.duration;
                if (null == segmentDuration) throw new Error("Invalid SegmentTemplate: no duration");
                ret = object_assign_default()({}, base, {
                    indexType: "template",
                    duration: segmentDuration
                });
            }
            return null != index && (ret.index = index), null != media && (ret.media = media), 
            null != bitstreamSwitching && (ret.bitstreamSwitching = bitstreamSwitching), ret;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Representation.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {NodeList} representationChildren
 * @returns {Object}
 */        function parseRepresentationChildren(representationChildren) {
            for (var children = {
                baseURL: ""
            }, i = 0; i < representationChildren.length; i++) if (representationChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = representationChildren[i];
                switch (currentElement.nodeName) {
                  case "BaseURL":
                    children.baseURL = currentElement.textContent || "";
                    break;

                  case "SegmentBase":
                    children.segmentBase = parseSegmentBase(currentElement);
                    break;

                  case "SegmentList":
                    children.segmentList = parseSegmentList(currentElement);
                    break;

                  case "SegmentTemplate":
                    children.segmentTemplate = parseSegmentTemplate(currentElement);
                }
            }
            return children;
        }
        /**
 * @param {Element} representationElement
 * @returns {Object}
 */        function parseRepresentationAttributes(representationElement) {
            for (var attributes = {}, i = 0; i < representationElement.attributes.length; i++) {
                var attribute = representationElement.attributes[i];
                switch (attribute.name) {
                  case "audioSamplingRate":
                    attributes.audioSamplingRate = attribute.value;
                    break;

                  case "bandwidth":
                    var bitrate = parseInt(attribute.value, 10);
                    isNaN(bitrate) ? log.a.warn('DASH: invalid bandwidth ("' + attribute.value + '")') : attributes.bitrate = bitrate;
                    break;

                  case "codecs":
                    attributes.codecs = attribute.value;
                    break;

                  case "codingDependency":
                    attributes.codingDependency = parseBoolean(attribute.value);
                    break;

                  case "frameRate":
                    attributes.frameRate = attribute.value;
                    break;

                  case "height":
                    var height = parseInt(attribute.value, 10);
                    isNaN(height) ? log.a.warn('DASH: invalid height ("' + attribute.value + '")') : attributes.height = height;
                    break;

                  case "id":
                    attributes.id = attribute.value;
                    break;

                  case "maxPlayoutRate":
                    var maxPlayoutRate = parseFloat(attribute.value);
                    isNaN(maxPlayoutRate) ? log.a.warn('DASH: invalid maxPlayoutRate ("' + attribute.value + '")') : attributes.maxPlayoutRate = maxPlayoutRate;
                    break;

                  case "maximumSAPPeriod":
                    var maximumSAPPeriod = parseFloat(attribute.value);
                    isNaN(maximumSAPPeriod) ? log.a.warn('DASH: invalid maximumSAPPeriod ("' + attribute.value + '")') : attributes.maximumSAPPeriod = maximumSAPPeriod;
                    break;

                  case "mimeType":
                    attributes.mimeType = attribute.value;
                    break;

                  case "profiles":
                    attributes.profiles = attribute.value;
                    break;

                  case "qualityRanking":
                    var qualityRanking = parseInt(attribute.value, 10);
                    isNaN(qualityRanking) ? log.a.warn('DASH: invalid qualityRanking ("' + attribute.value + '")') : attributes.qualityRanking = qualityRanking;
                    break;

                  case "segmentProfiles":
                    attributes.segmentProfiles = attribute.value;
                    break;

                  case "width":
                    var width = parseInt(attribute.value, 10);
                    isNaN(width) ? log.a.warn('DASH: invalid width ("' + attribute.value + '")') : attributes.width = width;
                }
            }
            return attributes;
        }
        function createRepresentationIntermediateRepresentation(representationElement) {
            return {
                children: parseRepresentationChildren(representationElement.childNodes),
                attributes: parseRepresentationAttributes(representationElement)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/AdaptationSet.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function parseAdaptationSetChildren(adaptationSetChildren) {
            for (var children = {
                baseURL: "",
                representations: []
            }, contentProtections = [], i = 0; i < adaptationSetChildren.length; i++) if (adaptationSetChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = adaptationSetChildren[i];
                switch (currentElement.nodeName) {
                  case "Accessibility":
                    children.accessibility = parseScheme(currentElement);
                    break;

                  case "BaseURL":
                    children.baseURL = currentElement.textContent || "";
                    break;

                  case "ContentComponent":
                    children.contentComponent = parseContentComponent(currentElement);
                    break;

                  case "Representation":
                    var representation = createRepresentationIntermediateRepresentation(currentElement);
                    children.representations.push(representation);
                    break;

                  case "Role":
                    null == children.roles ? children.roles = [ parseScheme(currentElement) ] : children.roles.push(parseScheme(currentElement));
                    break;

                  case "SegmentBase":
                    children.segmentBase = parseSegmentBase(currentElement);
                    break;

                  case "SegmentList":
                    children.segmentList = parseSegmentList(currentElement);
                    break;

                  case "SegmentTemplate":
                    children.segmentTemplate = parseSegmentTemplate(currentElement);
                    break;

                  case "ContentProtection":
                    var contentProtection = parseContentProtection(currentElement);
                    contentProtection && contentProtections.push(contentProtection);
 // case "Rating":
                    //   children.rating = currentElement;
                    //   break;
                    // case "Viewpoint":
                    //   children.viewpoint = currentElement;
                    //   break;
                                }
            }
            return contentProtections.length && (children.contentProtections = contentProtections), 
            children;
        }
        function parseAdaptationSetAttributes(root) {
            for (var parsedAdaptation = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "id":
                    parsedAdaptation.id = attribute.value;
                    break;

                  case "group":
                    var group = parseInt(attribute.value, 10);
                    isNaN(group) ? log.a.warn('DASH: invalid group ("' + attribute.value + '")') : parsedAdaptation.group = group;
                    break;

                  case "lang":
                    parsedAdaptation.language = attribute.value;
                    break;

                  case "contentType":
                    parsedAdaptation.contentType = attribute.value;
                    break;

                  case "par":
                    parsedAdaptation.par = attribute.value;
                    break;

                  case "minBandwidth":
                    var minBitrate = parseInt(attribute.value, 10);
                    isNaN(minBitrate) ? log.a.warn('DASH: invalid minBandwidth ("' + attribute.value + '")') : parsedAdaptation.minBitrate = minBitrate;
                    break;

                  case "maxBandwidth":
                    var maxBitrate = parseInt(attribute.value, 10);
                    isNaN(maxBitrate) ? log.a.warn('DASH: invalid maxBandwidth ("' + attribute.value + '")') : parsedAdaptation.maxBitrate = maxBitrate;
                    break;

                  case "minWidth":
                    var minWidth = parseInt(attribute.value, 10);
                    isNaN(minWidth) ? log.a.warn('DASH: invalid minWidth ("' + attribute.value + '")') : parsedAdaptation.minWidth = minWidth;
                    break;

                  case "maxWidth":
                    var maxWidth = parseInt(attribute.value, 10);
                    isNaN(maxWidth) ? log.a.warn('DASH: invalid maxWidth ("' + attribute.value + '")') : parsedAdaptation.maxWidth = maxWidth;
                    break;

                  case "minHeight":
                    var minHeight = parseInt(attribute.value, 10);
                    isNaN(minHeight) ? log.a.warn('DASH: invalid minHeight ("' + attribute.value + '")') : parsedAdaptation.minHeight = minHeight;
                    break;

                  case "maxHeight":
                    var maxHeight = parseInt(attribute.value, 10);
                    isNaN(maxHeight) ? log.a.warn('DASH: invalid maxHeight ("' + attribute.value + '")') : parsedAdaptation.maxHeight = maxHeight;
                    break;

                  case "minFrameRate":
                    parsedAdaptation.minFrameRate = attribute.value;
                    break;

                  case "maxFrameRate":
                    parsedAdaptation.maxFrameRate = attribute.value;
                    break;

                  case "segmentAlignment":
                    var segmentAlignment = parseIntOrBoolean(attribute.value);
                    "number" == typeof segmentAlignment && isNaN(segmentAlignment) ? log.a.warn('DASH: invalid segmentAlignment ("' + attribute.value + '")') : parsedAdaptation.segmentAlignment = segmentAlignment;
                    break;

                  case "subsegmentAlignment":
                    var subsegmentAlignment = parseIntOrBoolean(attribute.value);
                    "number" == typeof subsegmentAlignment && isNaN(subsegmentAlignment) ? log.a.warn('DASH: invalid subsegmentAlignment ("' + attribute.value + '")') : parsedAdaptation.subsegmentAlignment = subsegmentAlignment;
                    break;

                  case "bitstreamSwitching":
                    parsedAdaptation.bitstreamSwitching = parseBoolean(attribute.value);
                    break;

                  case "audioSamplingRate":
                    parsedAdaptation.audioSamplingRate = attribute.value;
                    break;

                  case "codecs":
                    parsedAdaptation.codecs = attribute.value;
                    break;

                  case "codingDependency":
                    parsedAdaptation.codingDependency = parseBoolean(attribute.value);
                    break;

                  case "frameRate":
                    parsedAdaptation.frameRate = attribute.value;
                    break;

                  case "height":
                    var height = parseInt(attribute.value, 10);
                    isNaN(height) ? log.a.warn('DASH: invalid height ("' + attribute.value + '")') : parsedAdaptation.height = height;
                    break;

                  case "maxPlayoutRate":
                    var maxPlayoutRate = parseFloat(attribute.value);
                    isNaN(maxPlayoutRate) ? log.a.warn('DASH: invalid maxPlayoutRate ("' + attribute.value + '")') : parsedAdaptation.maxPlayoutRate = maxPlayoutRate;
                    break;

                  case "maximumSAPPeriod":
                    var maximumSAPPeriod = parseFloat(attribute.value);
                    isNaN(maximumSAPPeriod) ? log.a.warn('DASH: invalid maximumSAPPeriod ("' + attribute.value + '")') : parsedAdaptation.maximumSAPPeriod = maximumSAPPeriod;
                    break;

                  case "mimeType":
                    parsedAdaptation.mimeType = attribute.value;
                    break;

                  case "profiles":
                    parsedAdaptation.profiles = attribute.value;
                    break;

                  case "segmentProfiles":
                    parsedAdaptation.segmentProfiles = attribute.value;
                    break;

                  case "width":
                    var width = parseInt(attribute.value, 10);
                    isNaN(width) ? log.a.warn('DASH: invalid width ("' + attribute.value + '")') : parsedAdaptation.width = width;
                }
            }
            return parsedAdaptation;
        }
        function createAdaptationSetIntermediateRepresentation(adaptationSetElement) {
            return {
                children: parseAdaptationSetChildren(adaptationSetElement.childNodes),
                attributes: parseAdaptationSetAttributes(adaptationSetElement)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Period.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {NodeList} periodChildren
 * @returns {Object}
 */        function parsePeriodChildren(periodChildren) {
            for (var baseURL = "", adaptations = [], i = 0; i < periodChildren.length; i++) if (periodChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = periodChildren[i];
                switch (currentElement.nodeName) {
                  case "BaseURL":
                    baseURL = currentElement.textContent || "";
                    break;

                  case "AdaptationSet":
                    var adaptation = createAdaptationSetIntermediateRepresentation(currentElement);
                    adaptations.push(adaptation);
                }
            }
            return {
                baseURL: baseURL,
                adaptations: adaptations
            };
        }
        /**
 * @param {Element} periodElement
 * @returns {Object}
 */        function parsePeriodAttributes(periodElement) {
            for (var res = {}, i = 0; i < periodElement.attributes.length; i++) {
                var attribute = periodElement.attributes[i];
                switch (attribute.name) {
                  case "id":
                    res.id = attribute.value;
                    break;

                  case "start":
                    var tempStart = parseDuration(attribute.value);
                    isNaN(tempStart) ? log.a.warn("DASH: Unrecognized start in the mpd:", attribute.value) : res.start = tempStart;
                    break;

                  case "duration":
                    var tempDuration = parseDuration(attribute.value);
                    isNaN(tempDuration) ? log.a.warn("DASH: Unrecognized duration in the mpd:", attribute.value) : res.duration = tempDuration;
                    break;

                  case "bitstreamSwitching":
                    res.bitstreamSwitching = parseBoolean(attribute.value);
                }
            }
            return res;
        }
        function createPeriodIntermediateRepresentation(periodElement) {
            return {
                children: parsePeriodChildren(periodElement.childNodes),
                attributes: parsePeriodAttributes(periodElement)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/MPD.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse children of the MPD's root into a simple object.
 * @param {NodeList} mpdChildren
 * @returns {Object}
 */        function parseMPDChildren(mpdChildren) {
            for (var baseURL = "", locations = [], periods = [], i = 0; i < mpdChildren.length; i++) if (mpdChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = mpdChildren[i];
                switch (currentNode.nodeName) {
                  case "BaseURL":
                    baseURL = currentNode.textContent || "";
                    break;

                  case "Location":
                    locations.push(currentNode.textContent || "");
                    break;

                  case "Period":
                    var period = createPeriodIntermediateRepresentation(currentNode);
                    periods.push(period);
                }
            }
            return {
                baseURL: baseURL,
                locations: locations,
                periods: periods
            };
        }
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseMPDAttributes(root) {
            for (var res = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "id":
                    res.id = attribute.value;
                    break;

                  case "profiles":
                    res.profiles = attribute.value;
                    break;

                  case "type":
                    res.type = attribute.value;
                    break;

                  case "availabilityStartTime":
                    res.availabilityStartTime = +parseDateTime(attribute.value);
                    break;

                  case "availabilityEndTime":
                    res.availabilityEndTime = +parseDateTime(attribute.value);
                    break;

                  case "publishTime":
                    res.publishTime = +parseDateTime(attribute.value);
                    break;

                  case "mediaPresentationDuration":
                    res.duration = parseDuration(attribute.value);
                    break;

                  case "minimumUpdatePeriod":
                    res.minimumUpdatePeriod = parseDuration(attribute.value);
                    break;

                  case "minBufferTime":
                    res.minBufferTime = parseDuration(attribute.value);
                    break;

                  case "timeShiftBufferDepth":
                    res.timeShiftBufferDepth = parseDuration(attribute.value);
                    break;

                  case "suggestedPresentationDelay":
                    res.suggestedPresentationDelay = parseDuration(attribute.value);
                    break;

                  case "maxSegmentDuration":
                    res.maxSegmentDuration = parseDuration(attribute.value);
                    break;

                  case "maxSubsegmentDuration":
                    res.maxSubsegmentDuration = parseDuration(attribute.value);
                }
            }
            return res;
        }
        function createMPDIntermediateRepresentation(root) {
            return {
                children: parseMPDChildren(root.childNodes),
                attributes: parseMPDAttributes(root)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var KNOWN_ADAPTATION_TYPES = [ "audio", "video", "text", "image" ], SUPPORTED_TEXT_TYPES = [ "subtitle", "caption" ];
        /**
 * Infers the type of adaptation from codec and mimetypes found in it.
 *
 * This follows the guidelines defined by the DASH-IF IOP:
 *   - one adaptation set contains a single media type
 *   - The order of verifications are:
 *       1. mimeType
 *       2. Role
 *       3. codec
 *
 * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.
 * @param {Object} adaptation
 * @returns {string} - "audio"|"video"|"text"|"image"|"metadata"|"unknown"
 */
        function inferAdaptationType(adaptationMimeType, representationMimeTypes, adaptationCodecs, representationCodecs, adaptationRoles) {
            function fromMimeType(mimeType, roles) {
                var topLevel = mimeType.split("/")[0];
                return Object(array_includes.a)(KNOWN_ADAPTATION_TYPES, topLevel) ? topLevel : "application/bif" === mimeType ? "image" : "application/ttml+xml" === mimeType ? "text" : // manage DASH-IF mp4-embedded subtitles and metadata
                "application/mp4" === mimeType ? null != roles && null != find_default()(roles, function(role) {
                    return "urn:mpeg:dash:role:2011" === role.schemeIdUri && Object(array_includes.a)(SUPPORTED_TEXT_TYPES, role.value);
                }) ? "text" : "metadata" : void 0;
            }
            function fromCodecs(codecs) {
                switch (codecs.substr(0, 3)) {
                  case "avc":
                  case "hev":
                  case "hvc":
                  case "vp8":
                  case "vp9":
                  case "av1":
                    return "video";

                  case "vtt":
                    return "text";

                  case "bif":
                    return "image";
                }
                switch (codecs.substr(0, 4)) {
                  case "mp4a":
                    return "audio";

                  case "wvtt":
                  case "stpp":
                    return "text";
                }
            }
            if (null != adaptationMimeType) {
                var typeFromMimeType = fromMimeType(adaptationMimeType, adaptationRoles);
                if (null != typeFromMimeType) return typeFromMimeType;
            }
            if (null != adaptationCodecs) {
                var typeFromCodecs = fromCodecs(adaptationCodecs);
                if (null != typeFromCodecs) return typeFromCodecs;
            }
            for (var i = 0; i < representationMimeTypes.length; i++) {
                var representationMimeType = representationMimeTypes[i];
                if (null != representationMimeType) {
                    var _typeFromMimeType = fromMimeType(representationMimeType, adaptationRoles);
                    if (null != _typeFromMimeType) return _typeFromMimeType;
                }
            }
            for (var _i = 0; _i < representationCodecs.length; _i++) {
                var codecs = representationCodecs[_i];
                if (null != codecs) {
                    var _typeFromMimeType2 = fromCodecs(codecs);
                    if (null != _typeFromMimeType2) return _typeFromMimeType2;
                }
            }
            return "unknown";
        }
        /**
 * Returns "last time of reference" from the adaptation given, considering a
 * live content.
 * Undefined if a time could not be found.
 *
 * We consider the earliest last time from every representations in the given
 * adaptation.
 *
 * This is done to calculate a liveGap which is valid for the whole manifest,
 * even in weird ones.
 * @param {Object} adaptation
 * @returns {Number|undefined}
 */        var getLastLiveTimeReference = function getLastLiveTimeReference(adaptation) {
            // Here's how we do, for each possibility:
            //  1. only the adaptation has an index (no representation has):
            //    - returns the index last time reference
            //
            //  2. every representations have an index:
            //    - returns minimum for every representations
            //
            //  3. not all representations have an index but the adaptation has
            //    - returns minimum between all representations and the adaptation
            //
            //  4. no index for 1+ representation(s) and no adaptation index:
            //    - returns undefined
            //
            //  5. Invalid index found somewhere:
            //    - returns undefined
            if (adaptation) {
                var lastLiveTimeReferences = (adaptation.representations || []).map(function(representation) {
                    var lastPosition = representation.index.getLastPosition();
                    return null != lastPosition ? lastPosition - 10 : void 0;
                });
                if (!lastLiveTimeReferences.some(function(x) {
                    return null == x;
                })) {
                    var representationsMin = Math.min.apply(Math, lastLiveTimeReferences);
                    if (!isNaN(representationsMin)) return representationsMin;
                }
            }
        };
        function parseManifest(root, uri) {
            for (
            // Transform whole MPD into a parsed JS object representation
            var _createMPDIntermediat = createMPDIntermediateRepresentation(root), rootChildren = _createMPDIntermediat.children, rootAttributes = _createMPDIntermediat.attributes, mpdRootURL = Object(utils_url.b)(Object(utils_url.a)(uri), rootChildren.baseURL), parsedPeriods = [], _loop = function _loop(i) {
                var period = rootChildren.periods[i], periodRootURL = Object(utils_url.b)(mpdRootURL, period.children.baseURL), periodID = void 0;
 // 1. Construct partial URL for contents
                                periodID = null == period.attributes.id ? (log.a.warn("DASH: No usable id found in the Period. Generating one."), 
                "gen-dash-period-" + Object(utils_id.a)()) : period.attributes.id;
 // 3. Find the start of the Period (required)
                                var periodStart = void 0;
                if (null != period.attributes.start) periodStart = period.attributes.start; else if (0 === i) periodStart = "static" === rootAttributes.type || null == rootAttributes.availabilityStartTime ? 0 : rootAttributes.availabilityStartTime; else {
                    var prevPeriod = parsedPeriods[i - 1];
                    if (null == prevPeriod.duration) throw new Error("Not enough informations on the periods: cannot find start.");
                    periodStart = prevPeriod.start + prevPeriod.duration;
                }
                var periodDuration = void 0;
                if (null != period.attributes.duration) periodDuration = period.attributes.duration; else {
                    var nextPeriod = parsedPeriods[i + 1];
                    nextPeriod && null != nextPeriod.start ? periodDuration = nextPeriod.start - periodStart : 0 === i && rootAttributes.duration && !nextPeriod && (periodDuration = rootAttributes.duration);
                }
 // 4. Construct underlying adaptations
                                var adaptations = period.children.adaptations.reduce(function(acc, adaptation) {
                    var parsedAdaptations = acc.adaptations, adaptationRootURL = Object(utils_url.b)(periodRootURL, adaptation.children.baseURL), adaptationChildren = adaptation.children;
                    // 4-1. Find Index
                    function findAdaptationIndex(representation) {
                        var adaptationIndex, repId = representation.attributes.id || "", repBitrate = representation.attributes.bitrate, baseURL = representation.children.baseURL, representationURL = Object(utils_url.b)(adaptationRootURL, baseURL);
                        if (null != adaptationChildren.segmentBase) {
                            var segmentBase = adaptationChildren.segmentBase;
                            adaptationIndex = new base_BaseRepresentationIndex(segmentBase, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            });
                        } else if (null != adaptationChildren.segmentList) {
                            var segmentList = adaptationChildren.segmentList;
                            adaptationIndex = new list_ListRepresentationIndex(segmentList, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            });
                        } else if (null != adaptationChildren.segmentTemplate) {
                            var segmentTemplate = adaptationChildren.segmentTemplate;
                            adaptationIndex = "timeline" === segmentTemplate.indexType ? new timeline_TimelineRepresentationIndex(segmentTemplate, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            }) : new template_TemplateRepresentationIndex(segmentTemplate, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            });
                        } else adaptationIndex = new template_TemplateRepresentationIndex({
                            duration: Number.MAX_VALUE,
                            timescale: 1,
                            startNumber: 0,
                            initialization: {
                                media: ""
                            },
                            media: ""
                        }, {
                            periodStart: periodStart,
                            representationURL: representationURL,
                            representationId: repId,
                            representationBitrate: repBitrate
                        });
                        return adaptationIndex;
                    }
 // 4-2. Construct Representations
                                        var representations = adaptation.children.representations.map(function(representation) {
                        var representationBitrate, representationIndex, repId = representation.attributes.id || "", repBitrate = representation.attributes.bitrate, baseURL = representation.children.baseURL, representationURL = Object(utils_url.b)(adaptationRootURL, baseURL);
                        if (representationBitrate = null == representation.attributes.bitrate ? (log.a.warn("DASH: No usable bitrate found in the Representation."), 
                        0) : representation.attributes.bitrate, null != representation.children.segmentBase) {
                            var segmentBase = representation.children.segmentBase;
                            representationIndex = new base_BaseRepresentationIndex(segmentBase, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            });
                        } else if (null != representation.children.segmentList) {
                            var segmentList = representation.children.segmentList;
                            representationIndex = new list_ListRepresentationIndex(segmentList, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            });
                        } else if (null != representation.children.segmentTemplate) {
                            var segmentTemplate = representation.children.segmentTemplate;
                            representationIndex = "timeline" === segmentTemplate.indexType ? new timeline_TimelineRepresentationIndex(segmentTemplate, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            }) : new template_TemplateRepresentationIndex(segmentTemplate, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            });
                        } else representationIndex = findAdaptationIndex(representation);
 // 4-2-3. Set ID
                                                var codecs, parsedRepresentation = {
                            bitrate: representationBitrate,
                            index: representationIndex,
                            id: null != representation.attributes.id ? representation.attributes.id : representation.attributes.bitrate + (null != representation.attributes.height ? "-" + representation.attributes.height : "") + (null != representation.attributes.width ? "-" + representation.attributes.width : "") + (null != representation.attributes.mimeType ? "-" + representation.attributes.mimeType : "") + (null != representation.attributes.codecs ? "-" + representation.attributes.codecs : "")
                        };
 // 4-2-4. Construct Representation Base
                                                if (null != representation.attributes.codecs ? codecs = representation.attributes.codecs : null != adaptation.attributes.codecs && (codecs = adaptation.attributes.codecs), 
                        null != codecs && (codecs = "mp4a.40.02" === codecs ? "mp4a.40.2" : codecs, parsedRepresentation.codecs = codecs), 
                        null != representation.attributes.audioSamplingRate ? parsedRepresentation.audioSamplingRate = representation.attributes.audioSamplingRate : null != adaptation.attributes.audioSamplingRate && (parsedRepresentation.audioSamplingRate = adaptation.attributes.audioSamplingRate), 
                        null != representation.attributes.codingDependency ? parsedRepresentation.codingDependency = representation.attributes.codingDependency : null != adaptation.attributes.codingDependency && (parsedRepresentation.codingDependency = adaptation.attributes.codingDependency), 
                        null != representation.attributes.frameRate ? parsedRepresentation.frameRate = representation.attributes.frameRate : null != adaptation.attributes.frameRate && (parsedRepresentation.frameRate = adaptation.attributes.frameRate), 
                        null != representation.attributes.height ? parsedRepresentation.height = representation.attributes.height : null != adaptation.attributes.height && (parsedRepresentation.height = adaptation.attributes.height), 
                        null != representation.attributes.maxPlayoutRate ? parsedRepresentation.maxPlayoutRate = representation.attributes.maxPlayoutRate : null != adaptation.attributes.maxPlayoutRate && (parsedRepresentation.maxPlayoutRate = adaptation.attributes.maxPlayoutRate), 
                        null != representation.attributes.maximumSAPPeriod ? parsedRepresentation.maximumSAPPeriod = representation.attributes.maximumSAPPeriod : null != adaptation.attributes.maximumSAPPeriod && (parsedRepresentation.maximumSAPPeriod = adaptation.attributes.maximumSAPPeriod), 
                        null != representation.attributes.mimeType ? parsedRepresentation.mimeType = representation.attributes.mimeType : null != adaptation.attributes.mimeType && (parsedRepresentation.mimeType = adaptation.attributes.mimeType), 
                        null != representation.attributes.profiles ? parsedRepresentation.profiles = representation.attributes.profiles : null != adaptation.attributes.profiles && (parsedRepresentation.profiles = adaptation.attributes.profiles), 
                        null != representation.attributes.qualityRanking && (parsedRepresentation.qualityRanking = representation.attributes.qualityRanking), 
                        null != representation.attributes.segmentProfiles ? parsedRepresentation.segmentProfiles = representation.attributes.segmentProfiles : null != adaptation.attributes.segmentProfiles && (parsedRepresentation.segmentProfiles = adaptation.attributes.segmentProfiles), 
                        null != representation.attributes.width ? parsedRepresentation.width = representation.attributes.width : null != adaptation.attributes.width && (parsedRepresentation.width = adaptation.attributes.width), 
                        adaptation.children.contentProtections) {
                            for (var contentProtections = [], k = 0; k < adaptation.children.contentProtections.length; k++) {
                                var protection = adaptation.children.contentProtections[k];
                                null != protection.keyId && contentProtections.push({
                                    keyId: protection.keyId
                                });
                            }
                            contentProtections.length && (parsedRepresentation.contentProtections = contentProtections);
                        }
                        return parsedRepresentation;
                    }), adaptationMimeType = adaptation.attributes.mimeType, adaptationCodecs = adaptation.attributes.codecs, type = inferAdaptationType(adaptationMimeType || null, representations.map(function(representation) {
                        return representation.mimeType;
                    }).filter(function(mimeType) {
                        return null != mimeType;
                    }), adaptationCodecs || null, representations.map(function(representation) {
                        return representation.codecs;
                    }).filter(function(codecs) {
                        return null != codecs;
                    }), adaptationChildren.roles || null), roles = adaptationChildren.roles, isMainAdaptation = !!roles && !!find_default()(roles, function(role) {
                        return "main" === role.value;
                    }) && !!find_default()(roles, function(role) {
                        return "urn:mpeg:dash:role:2011" === role.schemeIdUri;
                    }), videoMainAdaptation = acc.videoMainAdaptation;
                    if ("video" === type && null !== videoMainAdaptation && isMainAdaptation) {
                        var _videoMainAdaptation$;
                        (_videoMainAdaptation$ = videoMainAdaptation.representations).push.apply(_videoMainAdaptation$, representations);
                    } else {
                        var closedCaption, audioDescription, adaptationID;
                        if ("text" === type && adaptationChildren.accessibility && isHardOfHearing(adaptationChildren.accessibility) && (closedCaption = !0), 
                        "audio" === type && adaptationChildren.accessibility && isVisuallyImpaired(adaptationChildren.accessibility) && (audioDescription = !0), 
                        null != adaptation.attributes.id) adaptationID = adaptation.attributes.id; else {
                            var idString = type;
                            adaptation.attributes.language && (idString += "-" + adaptation.attributes.language), 
                            closedCaption && (idString += "-cc"), audioDescription && (idString += "-ad"), adaptation.attributes.contentType && (idString += "-" + adaptation.attributes.contentType), 
                            adaptation.attributes.codecs && (idString += "-" + adaptation.attributes.codecs), 
                            adaptation.attributes.mimeType && (idString += "-" + adaptation.attributes.mimeType), 
                            adaptation.attributes.frameRate && (idString += "-" + adaptation.attributes.frameRate), 
                            idString.length === type.length && (idString += representations.length ? "-" + representations[0].id : "-empty"), 
                            adaptationID = "adaptation-" + idString;
                        }
                        var parsedAdaptationSet = {
                            id: adaptationID,
                            representations: representations,
                            type: type
                        };
                        null != adaptation.attributes.language && (parsedAdaptationSet.language = adaptation.attributes.language, 
                        parsedAdaptationSet.normalizedLanguage = Object(languages.a)(adaptation.attributes.language)), 
                        null != closedCaption && (parsedAdaptationSet.closedCaption = closedCaption), null != audioDescription && (parsedAdaptationSet.audioDescription = audioDescription);
                        var parsedAdaptation = parsedAdaptations[type];
                        parsedAdaptation ? isMainAdaptation && "video" === type ? (
                        // put "main" adaptation as the first
                        parsedAdaptation.unshift(parsedAdaptationSet), acc.videoMainAdaptation = parsedAdaptationSet) : parsedAdaptation.push(parsedAdaptationSet) : (parsedAdaptations[type] = [ parsedAdaptationSet ], 
                        isMainAdaptation && "video" === type && (acc.videoMainAdaptation = parsedAdaptationSet));
                    }
                    return {
                        adaptations: parsedAdaptations,
                        videoMainAdaptation: acc.videoMainAdaptation
                    };
                }, {
                    videoMainAdaptation: null,
                    adaptations: {}
                }).adaptations, parsedPeriod = {
                    id: periodID,
                    start: periodStart,
                    duration: periodDuration,
                    adaptations: adaptations
                };
                null != period.attributes.bitstreamSwitching && (parsedPeriod.bitstreamSwitching = period.attributes.bitstreamSwitching), 
                parsedPeriods.push(parsedPeriod);
            }, i = 0; i < rootChildren.periods.length; i++) _loop(i);
            var isLive = "dynamic" === rootAttributes.type, duration = function() {
                if (null != rootAttributes.duration) return rootAttributes.duration;
                if (isLive) return Infinity;
                if (parsedPeriods.length) {
                    var lastPeriod = parsedPeriods[parsedPeriods.length - 1];
                    if (null != lastPeriod.end) return lastPeriod.end;
                    if (null != lastPeriod.duration) return lastPeriod.start + lastPeriod.duration;
                }
                return Infinity;
            }(), parsedMPD = {
                availabilityStartTime: "static" === rootAttributes.type || null == rootAttributes.availabilityStartTime ? 0 : rootAttributes.availabilityStartTime,
                duration: duration,
                id: null != rootAttributes.id ? rootAttributes.id : "gen-dash-manifest-" + Object(utils_id.a)(),
                periods: parsedPeriods,
                transportType: "dash",
                isLive: isLive,
                uris: [ uri ].concat(rootChildren.locations),
                suggestedPresentationDelay: null != rootAttributes.suggestedPresentationDelay ? rootAttributes.suggestedPresentationDelay : config.a.DEFAULT_SUGGESTED_PRESENTATION_DELAY.DASH
            };
            if (// -- add optional fields --
            null != rootAttributes.profiles && (parsedMPD.profiles = rootAttributes.profiles), 
            "static" !== rootAttributes.type && null != rootAttributes.availabilityEndTime && (parsedMPD.availabilityEndTime = rootAttributes.availabilityEndTime), 
            null != rootAttributes.publishTime && (parsedMPD.publishTime = rootAttributes.publishTime), 
            null != rootAttributes.duration && (parsedMPD.duration = rootAttributes.duration), 
            null != rootAttributes.minBufferTime && (parsedMPD.minBufferTime = rootAttributes.minBufferTime), 
            null != rootAttributes.timeShiftBufferDepth && (parsedMPD.timeShiftBufferDepth = rootAttributes.timeShiftBufferDepth), 
            null != rootAttributes.maxSegmentDuration && (parsedMPD.maxSegmentDuration = rootAttributes.maxSegmentDuration), 
            null != rootAttributes.maxSubsegmentDuration && (parsedMPD.maxSubsegmentDuration = rootAttributes.maxSubsegmentDuration), 
            null != rootAttributes.minimumUpdatePeriod && 0 < rootAttributes.minimumUpdatePeriod && (parsedMPD.lifetime = rootAttributes.minimumUpdatePeriod), 
            parsedMPD.isLive) {
                var lastPeriodAdaptations = parsedMPD.periods[parsedMPD.periods.length - 1].adaptations, firstAdaptationsFromLastPeriod = lastPeriodAdaptations.video || lastPeriodAdaptations.audio;
                if (!firstAdaptationsFromLastPeriod || !firstAdaptationsFromLastPeriod.length) throw new Error("Can't find first adaptation from last period");
                var firstAdaptationFromLastPeriod = firstAdaptationsFromLastPeriod[0], lastRef = getLastLiveTimeReference(firstAdaptationFromLastPeriod);
                parsedMPD.presentationLiveGap = null != lastRef ? Date.now() / 1e3 - (lastRef + parsedMPD.availabilityStartTime) : 10;
            }
            return Object(check_manifest_ids.a)(parsedMPD), parsedMPD;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Document} manifest - Original manifest as returned by the server
 * @param {string} uri
 * @returns {Object} - parsed manifest
 */        function parseFromDocument(document, uri) {
            var root = document.documentElement;
            if (!root || "MPD" !== root.nodeName) throw new Error("document root should be MPD");
            return parseManifest(root, uri);
        }
        // EXTERNAL MODULE: ./src/utils/request/index.ts
                var request = __webpack_require__(25), manifest_loader = __webpack_require__(87);
        // EXTERNAL MODULE: ./src/net/utils/manifest_loader.ts
                /* harmony default export */ var isobmff_timing_infos = 
        // CONCATENATED MODULE: ./src/net/dash/isobmff_timing_infos.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get precize start and duration of a segment from ISOBMFF.
 *   1. get start from tfdt
 *   2. get duration from trun
 *   3. if at least one is missing, get both informations from sidx
 *   4. As a fallback take segment infos.
 * @param {Object} segment
 * @param {UInt8Array} buffer - The entire isobmff container
 * @param {Array.<Object>|undefined} sidxSegments - Segments from sidx. Here
 * pre-parsed for performance reasons as it is usually available when
 * this function is called.
 * @param {Object} initInfos
 * @returns {Object}
 */
        function getISOBMFFTimingInfos(segment, buffer, sidxSegments, initInfos) {
            var startTime, duration, maxDecodeTimeDelta, segmentDuration, segmentStart, _sidxSegments = sidxSegments || [], baseDecodeTime = Object(isobmff.d)(buffer), trunDuration = Object(isobmff.a)(buffer), timescale = initInfos && initInfos.timescale ? initInfos.timescale : segment.timescale;
            if (segmentDuration = timescale === segment.timescale ? (maxDecodeTimeDelta = Math.min(.9 * timescale, null != segment.duration ? segment.duration / 4 : .25), 
            segmentStart = segment.time, segment.duration) : (maxDecodeTimeDelta = Math.min(.9 * timescale, null != segment.duration ? segment.duration / segment.timescale * timescale / 4 : .25), 
            segmentStart = (segment.time || 0) / segment.timescale * timescale, null != segment.duration ? segment.duration / segment.timescale * timescale : void 0), 
            0 <= baseDecodeTime && (startTime = null != segment.timestampOffset ? baseDecodeTime + segment.timestampOffset * timescale : baseDecodeTime), 
            0 <= trunDuration && (null == segmentDuration || Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta) && (duration = trunDuration), 
            null == startTime) if (0 === _sidxSegments.length) startTime = segmentStart; else {
                var sidxStart = _sidxSegments[0].time;
                if (0 <= sidxStart) {
                    var sidxTimescale = _sidxSegments[0].timescale, baseStartTime = null != sidxTimescale && sidxTimescale !== timescale ? sidxStart / sidxTimescale * timescale : sidxStart;
                    startTime = null != segment.timestampOffset ? baseStartTime + segment.timestampOffset * timescale : baseStartTime;
                } else startTime = segmentStart;
            }
            if (null == duration) if (_sidxSegments.length) {
                var sidxDuration = _sidxSegments.reduce(function(a, b) {
                    return a + (b.duration || 0);
                }, 0);
                duration = 0 <= sidxDuration ? sidxDuration : segmentDuration;
            } else duration = segmentDuration;
            return {
                timescale: timescale,
                time: startTime || 0,
                duration: duration || 0
            };
        }, Observable = __webpack_require__(9);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                // CONCATENATED MODULE: ./src/net/dash/utils.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */
        function addNextSegments(representation, nextSegments, currentSegment) {
            representation.index._addSegments(nextSegments, currentSegment);
        }
        /**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */        function isMP4EmbeddedTrack(representation) {
            return "application/mp4" === representation.mimeType;
        }
        /**
 * Returns text-formatted byteRange (`bytes=$start-$end?)`
 * @param {Array.<string|Number>} arr
 * @returns {string}
 */        function byteRange(_ref) {
            var start = _ref[0], end = _ref[1];
            return Infinity === end ? "bytes=" + +start + "-" : "bytes=" + +start + "-" + +end;
        }
        // CONCATENATED MODULE: ./src/net/dash/segment_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */        function regularSegmentLoader(_ref) {
            var url = _ref.url, segment = _ref.segment, range = segment.range, indexRange = segment.indexRange;
            // fire a single time for init and index ranges
            return null != range && null != indexRange ? Object(request.a)({
                url: url,
                responseType: "arraybuffer",
                headers: {
                    Range: byteRange([ Math.min(range[0], indexRange[0]), Math.max(range[1], indexRange[1]) ])
                }
            }) : Object(request.a)({
                url: url,
                responseType: "arraybuffer",
                headers: range ? {
                    Range: byteRange(range)
                } : null
            });
        }
        /**
 * Generate a segment loader for the application
 * @param {Function} [customSegmentLoader]
 * @returns {Function}
 */        var segment_loader = function segmentPreLoader(customSegmentLoader) {
            return function(_ref2) {
                var adaptation = _ref2.adaptation, manifest = _ref2.manifest, period = _ref2.period, representation = _ref2.representation, segment = _ref2.segment, mediaURL = segment.mediaURL;
                if (null == mediaURL) return Object(of.a)({
                    type: "data",
                    value: {
                        responseData: null
                    }
                });
                var args = {
                    adaptation: adaptation,
                    manifest: manifest,
                    period: period,
                    representation: representation,
                    segment: segment,
                    transport: "dash",
                    url: mediaURL
                };
                return customSegmentLoader ? Observable.a.create(function(obs) {
                    var hasFinished = !1, hasFallbacked = !1, abort = customSegmentLoader(args, {
                        reject: function reject(err) {
                            void 0 === err && (err = {}), hasFallbacked || (hasFinished = !0, obs.error(err));
                        },
                        resolve: function resolve(_args) {
                            hasFallbacked || (hasFinished = !0, obs.next({
                                type: "response",
                                value: {
                                    responseData: _args.data,
                                    size: _args.size,
                                    duration: _args.duration
                                }
                            }), obs.complete());
                        },
                        fallback: function fallback() {
                            hasFallbacked = !0, regularSegmentLoader(args).subscribe(obs);
                        }
                    });
                    return function() {
                        hasFinished || hasFallbacked || "function" != typeof abort || abort();
                    };
                }) : regularSegmentLoader(args);
            };
        }, strings = __webpack_require__(88), read = __webpack_require__(38);
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/net/dash/texttracks.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Perform requests for "text" segments
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */
        function TextTrackLoader(_ref) {
            var segment = _ref.segment, representation = _ref.representation, mediaURL = segment.mediaURL, range = segment.range, indexRange = segment.indexRange, responseType = isMP4EmbeddedTrack(representation) ? "arraybuffer" : "text";
            // init segment without initialization media/range/indexRange:
            // we do nothing on the network
            return null == mediaURL ? Object(of.a)({
                type: "data",
                value: {
                    responseData: null
                }
            }) : // fire a single time for init and index ranges
            null != range && null != indexRange ? Object(request.a)({
                url: mediaURL,
                responseType: responseType,
                headers: {
                    Range: byteRange([ Math.min(range[0], indexRange[0]), Math.max(range[1], indexRange[1]) ])
                }
            }) : Object(request.a)({
                url: mediaURL,
                responseType: responseType,
                headers: range ? {
                    Range: byteRange(range)
                } : null
            });
        }
        /**
 * Parse TextTrack data.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */        function TextTrackParser(_ref2) {
            var responseData, nextSegments, segmentInfos, segmentData, response = _ref2.response, segment = _ref2.segment, adaptation = _ref2.adaptation, representation = _ref2.representation, init = _ref2.init, language = adaptation.language, isInit = segment.isInit, indexRange = segment.indexRange;
            if (null == response.responseData) return Object(of.a)({
                segmentData: null,
                segmentInfos: 0 < segment.timescale ? {
                    duration: segment.isInit ? 0 : segment.duration,
                    time: segment.isInit ? -1 : segment.time,
                    timescale: segment.timescale
                } : null,
                segmentOffset: segment.timestampOffset || 0
            });
            var isMP4 = isMP4EmbeddedTrack(representation);
            if (isMP4) {
                Object(assert.b)(response.responseData instanceof ArrayBuffer), responseData = new Uint8Array(response.responseData);
                var sidxSegments = Object(isobmff.c)(responseData, indexRange ? indexRange[0] : 0);
                sidxSegments && (nextSegments = sidxSegments), segmentInfos = isInit ? {
                    time: -1,
                    duration: 0,
                    timescale: segment.timescale
                } : isobmff_timing_infos(segment, responseData, sidxSegments, init);
            } else 
            // if not MP4
            Object(assert.b)("string" == typeof response.responseData), responseData = response.responseData, 
            segmentInfos = isInit ? {
                time: -1,
                duration: 0,
                timescale: segment.timescale
            } : {
                time: segment.time,
                duration: segment.duration,
                timescale: segment.timescale
            };
            if (isInit) {
                if (isMP4) {
                    var timescale = Object(isobmff.b)(responseData);
                    0 < timescale && (segmentInfos = {
                        time: -1,
                        duration: 0,
                        timescale: timescale
                    });
                }
                segmentData = null;
            } else {
                // if not init
                Object(assert.b)(null != segmentInfos);
                var segmentDataBase = {
                    start: segmentInfos.time,
                    end: segmentInfos.time + (segmentInfos.duration || 0),
                    language: language,
                    timescale: segmentInfos.timescale
                };
                if (isMP4) {
                    var type, _representation$codec = representation.codec, codec = void 0 === _representation$codec ? "" : _representation$codec;
                    switch (codec.toLowerCase()) {
                      case "stpp":
 // stpp === TTML in MP4
                                              case "stpp.ttml.im1t":
                        type = "ttml";
                        break;

                      case "wvtt":
                        // wvtt === WebVTT in MP4
                        type = "vtt";
                    }
                    if (!type) throw new Error('The codec used for the subtitles, "' + codec + '", is not managed yet.');
                    segmentData = object_assign_default()({
                        data: Object(strings.a)(Object(read.a)(responseData)),
                        type: type
                    }, {
                        timescale: 1
                    }, segmentDataBase);
                } else {
                    // not MP4: check for plain text subtitles
                    var _type, _representation$mimeT = representation.mimeType, mimeType = void 0 === _representation$mimeT ? "" : _representation$mimeT;
                    switch (representation.mimeType) {
                      case "application/ttml+xml":
                        _type = "ttml";
                        break;

                      case "application/x-sami":
                      case "application/smil":
                        _type = "sami";
                        break;

                      case "text/vtt":
                        _type = "vtt";
                    }
                    if (!_type) {
                        var _representation$codec2 = representation.codec;
                        if ("srt" !== (void 0 === _representation$codec2 ? "" : _representation$codec2).toLowerCase()) throw new Error("could not find a text-track parser for the type " + mimeType);
                        _type = "srt";
                    }
                    segmentData = object_assign_default()({
                        data: responseData,
                        type: _type
                    }, {
                        timescale: 1
                    }, segmentDataBase);
                }
            }
            return nextSegments && addNextSegments(representation, nextSegments, segmentInfos), 
            Object(of.a)({
                segmentData: segmentData,
                segmentInfos: segmentInfos,
                segmentOffset: segment.timestampOffset || 0
            });
        }
        // CONCATENATED MODULE: ./src/net/dash/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * Returns pipelines used for DASH streaming.
 * @param {Object} options
 * implementation. Used for each generated http request.
 * @returns {Object}
 */
        /* harmony default export */        __webpack_exports__.default = function(options) {
            void 0 === options && (options = {});
            var manifestLoader = Object(manifest_loader.a)({
                customManifestLoader: options.manifestLoader
            }), segmentLoader = segment_loader(options.segmentLoader), segmentPipeline = {
                loader: function loader(_ref3) {
                    var adaptation = _ref3.adaptation, manifest = _ref3.manifest, period = _ref3.period, representation = _ref3.representation, segment = _ref3.segment;
                    return segmentLoader({
                        adaptation: adaptation,
                        manifest: manifest,
                        period: period,
                        representation: representation,
                        segment: segment
                    });
                },
                parser: function parser(_ref4) {
                    var segment = _ref4.segment, representation = _ref4.representation, response = _ref4.response, init = _ref4.init, responseData = response.responseData;
                    if (null == responseData) return Object(of.a)({
                        segmentData: null,
                        segmentInfos: null,
                        segmentOffset: 0
                    });
                    var segmentData = responseData instanceof Uint8Array ? responseData : new Uint8Array(responseData), indexRange = segment.indexRange, isWEBM = "video/webm" === representation.mimeType || "audio/webm" === representation.mimeType, nextSegments = isWEBM ? getSegmentsFromCues(segmentData, 0) : Object(isobmff.c)(segmentData, indexRange ? indexRange[0] : 0);
                    if (!segment.isInit) {
                        var segmentInfos = isWEBM ? {
                            time: segment.time,
                            duration: segment.duration,
                            timescale: segment.timescale
                        } : isobmff_timing_infos(segment, segmentData, nextSegments, init), segmentOffset = segment.timestampOffset || 0;
                        return Object(of.a)({
                            segmentData: segmentData,
                            segmentInfos: segmentInfos,
                            segmentOffset: segmentOffset
                        });
                    }
                    nextSegments && addNextSegments(representation, nextSegments);
                    var timescale = isWEBM ? getTimeCodeScale(segmentData, 0) : Object(isobmff.b)(segmentData);
                    return Object(of.a)({
                        segmentData: segmentData,
                        segmentInfos: timescale && 0 < timescale ? {
                            time: -1,
                            duration: 0,
                            timescale: timescale
                        } : null,
                        segmentOffset: segment.timestampOffset || 0
                    });
                }
            };
            return {
                manifest: {
                    loader: function loader(_ref) {
                        var url = _ref.url;
                        return manifestLoader(url);
                    },
                    parser: function parser(_ref2) {
                        var response = _ref2.response, reqURL = _ref2.url, url = null == response.url ? reqURL : response.url, data = "string" == typeof response.responseData ? new DOMParser().parseFromString(response.responseData, "text/xml") : response.responseData;
                        return Object(of.a)({
                            manifest: parseFromDocument(data, url),
                            url: url
                        });
                    }
                },
                audio: segmentPipeline,
                video: segmentPipeline,
                text: {
                    loader: TextTrackLoader,
                    parser: TextTrackParser
                },
                image: {
                    loader: function loader(_ref5) {
                        var segment = _ref5.segment;
                        if (segment.isInit || null == segment.mediaURL) return Object(of.a)({
                            type: "data",
                            value: {
                                responseData: null
                            }
                        });
                        var mediaURL = segment.mediaURL;
                        return Object(request.a)({
                            url: mediaURL,
                            responseType: "arraybuffer"
                        });
                    },
                    parser: function parser(_ref6) {
                        var response = _ref6.response, segment = _ref6.segment, responseData = response.responseData;
                        // TODO image Parsing should be more on the sourceBuffer side, no?
                        if (null === responseData || null == features.a.imageParser) return Object(of.a)({
                            segmentData: null,
                            segmentInfos: 0 < segment.timescale ? {
                                duration: segment.isInit ? 0 : segment.duration,
                                time: segment.isInit ? -1 : segment.time,
                                timescale: segment.timescale
                            } : null,
                            segmentOffset: segment.timestampOffset || 0
                        });
                        var bifObject = features.a.imageParser(new Uint8Array(responseData)), data = bifObject.thumbs;
                        return Object(of.a)({
                            segmentData: {
                                data: data,
                                start: 0,
                                end: Number.MAX_VALUE,
                                timescale: 1,
                                type: "bif"
                            },
                            segmentInfos: {
                                time: 0,
                                duration: Number.MAX_VALUE,
                                timescale: bifObject.timescale
                            },
                            segmentOffset: segment.timestampOffset || 0
                        });
                    }
                }
            };
        };
        /***/    }, 
    /* 126 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
        var of = __webpack_require__(64), map = __webpack_require__(42), features = __webpack_require__(10), log = __webpack_require__(0), object_assign = __webpack_require__(6), object_assign_default = /* */ __webpack_require__.n(object_assign), config = __webpack_require__(2), assert = __webpack_require__(14), utils_id = __webpack_require__(21), languages = __webpack_require__(84), utils_url = __webpack_require__(39), check_manifest_ids = __webpack_require__(81);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
                // CONCATENATED MODULE: ./src/parsers/manifest/smooth/get_codecs.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {string} fourCC
 * @param {string} codecPrivateData
 * @returns {string}
 */
        function getAudioCodecs(fourCC, codecPrivateData) {
            var mpProfile;
            return (mpProfile = "AACH" === fourCC ? 5 : codecPrivateData ? (248 & parseInt(codecPrivateData.substr(0, 2), 16)) >> 3 : 2) ? "mp4a.40." + mpProfile : "";
        }
        /**
 * @param {string} codecPrivateData
 * @returns {string}
 */        function getVideoCodecs(codecPrivateData) {
            // we can extract codes only if fourCC is on of "H264", "X264", "DAVC", "AVC1"
            var _ref$ = (/00000001\d7([0-9a-fA-F]{6})/.exec(codecPrivateData) || [])[1], avcProfile = void 0 === _ref$ ? "" : _ref$;
            return avcProfile && "avc1." + avcProfile;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_C_nodes.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse C nodes to build index timeline.
 * @param {Element} nodes
 */        function parseCNodes(nodes) {
            return nodes.reduce(function(timeline, node, i) {
                var dAttr = node.getAttribute("d"), tAttr = node.getAttribute("t"), rAttr = node.getAttribute("r"), repeatCount = rAttr ? +rAttr - 1 : 0, start = tAttr ? +tAttr : void 0, duration = dAttr ? +dAttr : void 0;
                if (0 === i) 
                // first node
                start = start || 0; else {
                    // from second node to the end
                    var prev = timeline[i - 1];
                    if (null == start || isNaN(start)) {
                        if (null == prev.duration || isNaN(prev.duration)) throw new Error("Smooth: Invalid CNodes. Missing timestamp.");
                        start = prev.start + prev.duration * (prev.repeatCount + 1);
                    }
                }
                if (null == duration || isNaN(duration)) {
                    var nextNode = nodes[i + 1];
                    if (!nextNode) return timeline;
                    var nextTAttr = nextNode.getAttribute("t"), nextStart = nextTAttr ? +nextTAttr : null;
                    if (null === nextStart) throw new Error("Can't build index timeline from Smooth Manifest.");
                    duration = nextStart - start;
                }
                return timeline.push({
                    duration: duration,
                    start: start,
                    repeatCount: repeatCount
                }), timeline;
            }, []);
        }
        // EXTERNAL MODULE: ./src/utils/bytes.ts
                var bytes = __webpack_require__(1);
        // CONCATENATED MODULE: ./src/parsers/containers/isobmff/drm/playready.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse PlayReady privateData to get its Hexa-coded KeyID.
 * @param {Uint8Array} privateData
 * @returns {string}
 */        function getPlayReadyKIDFromPrivateData(data) {
            var xmlLength = Object(bytes.n)(data, 8), xml = Object(bytes.g)(data.subarray(10, xmlLength + 10)), kidElement = new DOMParser().parseFromString(xml, "application/xml").querySelector("KID");
            if (!kidElement) throw new Error("Cannot parse PlayReady private data: invalid XML");
            var kid = kidElement.textContent || "";
            return Object(bytes.i)(atob(kid)).toLowerCase();
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_protection_node.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Uint8Array} keyIdBytes
 * @returns {Array.<Object>}
 */        function createWidevineKeySystem(keyIdBytes) {
            return [ {
                systemId: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
                privateData: Object(bytes.h)([ 8, 1, 18, 16 ], keyIdBytes)
            } ];
        }
        /**
 * Parse "Protection" Node, which contains DRM informations
 * @param {Element} protectionNode
 * @returns {Object}
 */        function parseProtectionNode(protectionNode, keySystemCreator) {
            if (void 0 === keySystemCreator && (keySystemCreator = createWidevineKeySystem), 
            !protectionNode.firstElementChild || "ProtectionHeader" !== protectionNode.firstElementChild.nodeName) throw new Error("Protection should have ProtectionHeader child");
            var header = protectionNode.firstElementChild, privateData = Object(bytes.p)(atob(header.textContent || "")), keyIdHex = getPlayReadyKIDFromPrivateData(privateData), keyIdBytes = Object(bytes.j)(keyIdHex);
            return {
                keyId: keyIdHex,
                keySystems: [ {
                    systemId: (header.getAttribute("SystemID") || "").toLowerCase().replace(/\{|\}/g, ""),
                    privateData: privateData
                } ].concat(keySystemCreator(keyIdBytes))
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/tokens.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {string} url
 * @param {string|number} bitrate
 * @returns {string}
 */        function replaceRepresentationSmoothTokens(url, bitrate) {
            return url.replace(/\{bitrate\}/g, String(bitrate));
        }
        /**
 * @param {string} url
 * @param {number} time
 * @returns {string}
 */        function replaceSegmentSmoothTokens(url, time) {
            return url.replace(/\{start time\}/g, String(time));
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/representationIndex.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Object} currentSegment
 * @returns {Boolean} - true if the segment has been added
 */        function _addSegmentInfos(index, newSegment, currentSegment) {
            var scaledCurrentTime, timeline = index.timeline, timescale = index.timescale, timelineLength = timeline.length, last = timeline[timelineLength - 1], scaledNewSegment = newSegment.timescale === timescale ? {
                time: newSegment.time,
                duration: newSegment.duration
            } : {
                time: newSegment.time / newSegment.timescale * timescale,
                duration: newSegment.duration / newSegment.timescale * timescale
            };
            if (currentSegment && currentSegment.timescale && (scaledCurrentTime = currentSegment.timescale === timescale ? currentSegment.time : currentSegment.time / currentSegment.timescale * timescale), 
            null == scaledCurrentTime || scaledNewSegment.time !== scaledCurrentTime) return scaledNewSegment.time >= getTimelineRangeEnd(last) && (last.duration === scaledNewSegment.duration ? last.repeatCount++ : index.timeline.push({
                duration: scaledNewSegment.duration,
                start: scaledNewSegment.time,
                repeatCount: 0
            }), !0);
            var newSegmentStart = scaledNewSegment.time + scaledNewSegment.duration, startDiff = newSegmentStart - (last.start + (last.duration || 0) * last.repeatCount);
            if (startDiff <= 0) 
            // same segment / behind the last
            return !1;
 // try to use the compact notation with @r attribute on the last
            // to elements of the timeline if we find out they have the same
            // duration
                        if (-1 === last.duration) {
                var prev = timeline[timelineLength - 2];
                prev && prev.duration === startDiff ? (prev.repeatCount++, timeline.pop()) : last.duration = startDiff;
            }
            return index.timeline.push({
                duration: -1,
                start: newSegmentStart,
                repeatCount: 0
            }), !0;
        }
        /**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} start
 * @returns {Number}
 */        function getSegmentIndex(index, start) {
            for (var timeline = index.timeline, low = 0, high = timeline.length; low < high; ) {
                var mid = low + high >>> 1;
                timeline[mid].start < start ? low = mid + 1 : high = mid;
            }
            return 0 < low ? low - 1 : low;
        }
        /**
 * @param {Number} start
 * @param {Number} up
 * @param {Number} duration
 * @returns {Number}
 */        function getSegmentNumber(start, up, duration) {
            if (!duration) return 0;
            var diff = up - start;
            return 0 < diff ? Math.floor(diff / duration) : 0;
        }
        /**
 * Get end of the given index range, timescaled.
 * @param {Object} range
 * @returns {Number} - absolute end time of the range
 */        function getTimelineRangeEnd(_ref) {
            var start = _ref.start, duration = _ref.duration, repeatCount = _ref.repeatCount;
            return null == duration || -1 === duration ? start : start + (repeatCount + 1) * duration;
        }
 // interface ISmoothIndex {
        //   presentationTimeOffset? : number;
        //   timescale : number;
        //   media? : string;
        //   timeline : IIndexSegment[];
        //   startNumber? : number;
        // }
        /**
 * Convert second-based start time and duration to the timescale of the
 * manifest's index.
 * @param {Object} index
 * @param {Number} start
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */        function normalizeRange(index, start, duration) {
            var timescale = index.timescale || 1;
            return {
                up: start * timescale,
                to: (start + duration) * timescale
            };
        }
        /**
 * Calculate the number of times a segment repeat based on the next segment.
 * @param {Object} segment
 * @param {Object} nextSegment
 * @returns {Number}
 */        function calculateRepeat(segment, nextSegment) {
            var repeatCount = segment.repeatCount || 0;
 // A negative value of the @r attribute of the S element indicates
            // that the duration indicated in @d attribute repeats until the
            // start of the next S element, the end of the Period or until the
            // next MPD update.
            // TODO Also for SMOOTH????
                        if (null != segment.duration && repeatCount < 0) {
                var repeatEnd = nextSegment ? nextSegment.start : Infinity;
                repeatCount = Math.ceil((repeatEnd - segment.start) / segment.duration) - 1;
            }
            return repeatCount;
        }
        /**
 * RepresentationIndex implementation for Smooth Manifests.
 *
 * Allows to interact with the index to create new Segments.
 *
 * @class SmoothRepresentationIndex
 */        var representationIndex_SmoothRepresentationIndex = 
        /* */
        function() {
            function SmoothRepresentationIndex(index, infos) {
                if (this._index = index, this._indexValidityTime = index.manifestReceivedTime || performance.now(), 
                this._bitsPerSample = infos.bitsPerSample, this._channels = infos.channels, this._codecPrivateData = infos.codecPrivateData, 
                this._packetSize = infos.packetSize, this._samplingRate = infos.samplingRate, this._protection = infos.protection, 
                index.timeline.length) {
                    var _index$timeline = index.timeline[index.timeline.length - 1], start = _index$timeline.start, duration = _index$timeline.duration;
                    this._initialLastPosition = (start + duration) / index.timescale;
                }
            }
            /**
   * Construct init Segment compatible with a Smooth Manifest.
   * @returns {Object}
   */            var _proto = SmoothRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return {
                    id: "init",
                    isInit: !0,
                    time: 0,
                    timescale: this._index.timescale,
                    privateInfos: {
                        smoothInit: {
                            bitsPerSample: this._bitsPerSample,
                            channels: this._channels,
                            codecPrivateData: this._codecPrivateData,
                            packetSize: this._packetSize,
                            samplingRate: this._samplingRate,
                            protection: this._protection
                        }
                    },
                    mediaURL: null
                };
            }, 
            /**
   * Generate a list of Segments for a particular period of time.
   *
   * @param {Number} _up
   * @param {Number} _to
   * @returns {Array.<Object>}
   */
            _proto.getSegments = function getSegments(_up, _to) {
                for (var currentNumber, index = this._index, _normalizeRange = normalizeRange(index, _up, _to), up = _normalizeRange.up, to = _normalizeRange.to, timeline = index.timeline, timescale = index.timescale, media = index.media, segments = [], timelineLength = timeline.length, maxEncounteredDuration = timeline.length && timeline[0].duration || 0, i = 0; i < timelineLength; i++) {
                    var segmentRange = timeline[i], duration = segmentRange.duration, start = segmentRange.start;
                    // live-added segments have @d attribute equals to -1
                    if (maxEncounteredDuration = Math.max(maxEncounteredDuration, duration || 0), null != duration && duration < 0) {
                        // what? May be to play it safe and avoid adding segments which are
                        // not completely generated
                        if (start + maxEncounteredDuration < to) {
                            var segment = {
                                id: "" + start,
                                time: start,
                                isInit: !1,
                                timescale: timescale,
                                number: null != currentNumber ? currentNumber : void 0,
                                mediaURL: replaceSegmentSmoothTokens(media, start)
                            };
                            segments.push(segment);
                        }
                        return segments;
                    }
                    for (var repeat = calculateRepeat(segmentRange, timeline[i + 1]), segmentNumberInCurrentRange = getSegmentNumber(start, up, duration), segmentTime = start + segmentNumberInCurrentRange * (null == duration ? 0 : duration); segmentTime < to && segmentNumberInCurrentRange <= repeat; ) {
                        var _segment = {
                            id: "" + segmentTime,
                            time: segmentTime,
                            isInit: !1,
                            duration: duration,
                            timescale: timescale,
                            number: null != currentNumber ? currentNumber + segmentNumberInCurrentRange : void 0,
                            mediaURL: replaceSegmentSmoothTokens(media, segmentTime)
                        };
                        segments.push(_segment), segmentTime = start + // update segment number and segment time for the next segment
                        ++segmentNumberInCurrentRange * duration;
                    }
                    if (to <= segmentTime) 
                    // we reached ``to``, we're done
                    return segments;
                    null != currentNumber && (currentNumber += repeat + 1);
                }
                return segments;
            }, 
            /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * (If we should re-fetch the manifest)
   * @param {Number} from
   * @param {Number} to
   * @returns {Boolean}
   */
            _proto.shouldRefresh = function shouldRefresh(up, to) {
                var _this$_index = this._index, timeline = _this$_index.timeline, timescale = _this$_index.timescale, lastSegmentInCurrentTimeline = timeline[timeline.length - 1];
                if (!lastSegmentInCurrentTimeline) return !1;
                var repeat = lastSegmentInCurrentTimeline.repeatCount || 0, endOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + (repeat + 1) * lastSegmentInCurrentTimeline.duration;
                return !(to * timescale < endOfLastSegmentInCurrentTimeline) && (endOfLastSegmentInCurrentTimeline <= up * timescale || lastSegmentInCurrentTimeline.start + repeat * lastSegmentInCurrentTimeline.duration < up * timescale);
            }, 
            /**
   * Returns first position in the index.
   *
   * @param {Object} index
   * @returns {Number}
   */
            _proto.getFirstPosition = function getFirstPosition() {
                var index = this._index;
                if (index.timeline.length) return index.timeline[0].start / index.timescale;
            }, 
            /**
   * Returns last position in the index.
   * @param {Object} index
   * @returns {Number}
   */
            _proto.getLastPosition = function getLastPosition() {
                var index = this._index;
                if (index.timeline.length) return getTimelineRangeEnd(index.timeline[index.timeline.length - 1]) / index.timescale;
            }, 
            /**
   * Checks if the time given is in a discontinuity. That is:
   *   - We're on the upper bound of the current range (end of the range - time
   *     is inferior to the timescale)
   *   - The next range starts after the end of the current range.
   *
   * @param {Number} _time
   * @returns {Number} - If a discontinuity is present, this is the Starting
   * time for the next (discontinuited) range. If not this is equal to -1.
   */
            _proto.checkDiscontinuity = function checkDiscontinuity(_time) {
                var index = this._index, timeline = index.timeline, _index$timescale = index.timescale, timescale = void 0 === _index$timescale ? 1 : _index$timescale, time = _time * timescale;
                if (time <= 0) return -1;
                var segmentIndex = getSegmentIndex(index, time);
                if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) return -1;
                var range = timeline[segmentIndex];
                if (-1 === range.duration) return -1;
                var rangeUp = range.start, rangeTo = getTimelineRangeEnd(range), nextRange = timeline[segmentIndex + 1];
                // when we are actually inside the found range and this range has
                // an explicit discontinuity with the next one
                return rangeTo !== nextRange.start && rangeUp <= time && time <= rangeTo && rangeTo - time < timescale ? nextRange.start / timescale : -1;
            }, 
            /**
   * Update this RepresentationIndex by a newly downloaded one.
   * Check if the old index had more informations about new segments and
   * re-add them if that's the case.
   * @param {Object} newIndex
   */
            _proto._update = function _update(newIndex) {
                var oldTimeline = this._index.timeline, newTimeline = newIndex._index.timeline, oldTimescale = this._index.timescale, newTimescale = newIndex._index.timescale;
                if (this._index = newIndex._index, this._initialLastPosition = newIndex._initialLastPosition, 
                this._indexValidityTime = newIndex._indexValidityTime, oldTimeline.length && newTimeline.length && oldTimescale === newTimescale) {
                    var lastOldTimelineElement = oldTimeline[oldTimeline.length - 1], lastNewTimelineElement = newTimeline[newTimeline.length - 1], newEnd = getTimelineRangeEnd(lastNewTimelineElement);
                    if (!(getTimelineRangeEnd(lastOldTimelineElement) <= newEnd)) for (var i = 0; i < oldTimeline.length; i++) {
                        var oldTimelineRange = oldTimeline[i], oldEnd = getTimelineRangeEnd(oldTimelineRange);
                        if (oldEnd === newEnd) 
                        // just add the supplementary segments
                        return void (this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i + 1)));
                        if (newEnd < oldEnd) {
                            // adjust repeatCount + add supplementary segments
                            if (oldTimelineRange.duration !== lastNewTimelineElement.duration) return;
                            var rangeDuration = newEnd - oldTimelineRange.start;
                            if (0 === rangeDuration) return log.a.warn("Smooth Parser: a discontinuity detected in the previous manifest has been resolved."), 
                            void (this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i)));
                            if (rangeDuration < 0 || rangeDuration % oldTimelineRange.duration != 0) return;
                            var repeatWithOld = rangeDuration / oldTimelineRange.duration - 1, relativeRepeat = oldTimelineRange.repeatCount - repeatWithOld;
                            if (relativeRepeat < 0) return;
                            lastNewTimelineElement.repeatCount += relativeRepeat;
                            var supplementarySegments = oldTimeline.slice(i + 1);
                            return void (this._index.timeline = this._index.timeline.concat(supplementarySegments));
                        }
                    }
                }
            }, _proto._addSegments = function _addSegments(nextSegments, currentSegment) {
                for (var i = 0; i < nextSegments.length; i++) _addSegmentInfos(this._index, nextSegments[i], currentSegment);
 // clean segments before time shift buffer depth
                                if (null != this._initialLastPosition) {
                    var timeShiftBufferDepth = this._index.timeShiftBufferDepth, lastPositionEstimate = (performance.now() - this._indexValidityTime) / 1e3 + this._initialLastPosition;
                    if (null != timeShiftBufferDepth) for (var threshold = (lastPositionEstimate - timeShiftBufferDepth) * this._index.timescale, _i = 0; _i < this._index.timeline.length; _i++) {
                        var segment = this._index.timeline[_i];
                        if (segment.start + segment.duration >= threshold) {
                            this._index.timeline = this._index.timeline.slice(_i, this._index.timeline.length);
                            break;
                        }
                    }
                }
            }, SmoothRepresentationIndex;
        }();
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/parseBoolean.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {*} parseBoolean
 * @returns {Boolean}
 */        function parseBoolean(val) {
            return "boolean" == typeof val ? val : "string" == typeof val && "TRUE" === val.toUpperCase();
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/reduceChildren.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Reduce implementation for the children of the given element.
 * @param {Element} root
 * @param {Function} fn
 * @param {*} init
 * @returns {*}
 */        function reduceChildren(root, fn, init) {
            for (var node = root.firstElementChild, accumulator = init; node; ) accumulator = fn(accumulator, node.nodeName, node), 
            node = node.nextElementSibling;
            return accumulator;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var DEFAULT_MIME_TYPES = {
            audio: "audio/mp4",
            video: "video/mp4",
            text: "application/ttml+xml"
        }, DEFAULT_CODECS = {
            audio: "mp4a.40.2",
            video: "avc1.4D401E"
        }, MIME_TYPES = {
            AACL: "audio/mp4",
            AVC1: "video/mp4",
            H264: "video/mp4",
            TTML: "application/ttml+xml+mp4"
        };
        /* harmony default export */ var smooth = 
        /**
 * @param {Object|undefined} parserOptions
 * @returns {Function}
 */
        function createSmoothStreamingParser(parserOptions) {
            void 0 === parserOptions && (parserOptions = {});
            var SUGGESTED_PERSENTATION_DELAY = null == parserOptions.suggestedPresentationDelay ? config.a.DEFAULT_SUGGESTED_PRESENTATION_DELAY.SMOOTH : parserOptions.suggestedPresentationDelay, REFERENCE_DATE_TIME = parserOptions.referenceDateTime || Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1e3, MIN_REPRESENTATION_BITRATE = parserOptions.minRepresentationBitrate || 0;
            /**
   * @param {Element} q
   * @param {string} type
   * @return {Object}
   */
            function parseQualityLevel(q, type) {
                /**
     * @param {string} name
     * @returns {string|undefined}
     */
                function getAttribute(name) {
                    var attr = q.getAttribute(name);
                    return null == attr ? void 0 : attr;
                }
                switch (type) {
                  case "audio":
                    var audiotag = getAttribute("AudioTag"), bitrate = getAttribute("Bitrate"), bitsPerSample = getAttribute("BitsPerSample"), channels = getAttribute("Channels"), codecPrivateData = getAttribute("CodecPrivateData"), fourCC = getAttribute("FourCC"), packetSize = getAttribute("PacketSize"), samplingRate = getAttribute("SamplingRate");
                    return {
                        audiotag: void 0 !== audiotag ? parseInt(audiotag, 10) : audiotag,
                        bitrate: bitrate && parseInt(bitrate, 10) || 0,
                        bitsPerSample: void 0 !== bitsPerSample ? parseInt(bitsPerSample, 10) : bitsPerSample,
                        channels: void 0 !== channels ? parseInt(channels, 10) : channels,
                        codecPrivateData: codecPrivateData || "",
                        mimeType: void 0 !== fourCC ? MIME_TYPES[fourCC] : fourCC,
                        packetSize: void 0 !== packetSize ? parseInt(packetSize, 10) : packetSize,
                        samplingRate: void 0 !== samplingRate ? parseInt(samplingRate, 10) : samplingRate
                    };

                  case "video":
                    var _bitrate = getAttribute("Bitrate"), _codecPrivateData = getAttribute("CodecPrivateData"), _fourCC = getAttribute("FourCC"), width = getAttribute("MaxWidth"), height = getAttribute("MaxHeight");
                    return {
                        bitrate: _bitrate && parseInt(_bitrate, 10) || 0,
                        mimeType: void 0 !== _fourCC ? MIME_TYPES[_fourCC] : _fourCC,
                        codecPrivateData: _codecPrivateData || "",
                        codecs: getVideoCodecs(_codecPrivateData || ""),
                        width: void 0 !== width ? parseInt(width, 10) : void 0,
                        height: void 0 !== height ? parseInt(height, 10) : void 0
                    };

                  case "text":
                    var _bitrate2 = getAttribute("Bitrate"), _codecPrivateData2 = getAttribute("CodecPrivateData"), _fourCC2 = getAttribute("FourCC");
                    return {
                        bitrate: _bitrate2 && parseInt(_bitrate2, 10) || 0,
                        mimeType: void 0 !== _fourCC2 ? MIME_TYPES[_fourCC2] : _fourCC2,
                        codecPrivateData: _codecPrivateData2 || ""
                    };

                  default:
                    throw new Error("Unrecognized StreamIndex type: " + type);
                }
            }
            /**
   * Parse the adaptations (<StreamIndex>) tree containing
   * representations (<QualityLevels>) and timestamp indexes (<c>).
   * Indexes can be quite huge, and this function needs to
   * to be optimized.
   * @param {Object} args
   * @returns {Object}
   */            function parseAdaptation(args) {
                var root = args.root, timescale = args.timescale, rootURL = args.rootURL, protections = args.protections, timeShiftBufferDepth = args.timeShiftBufferDepth, manifestReceivedTime = args.manifestReceivedTime, _timescale = root.hasAttribute("Timescale") ? +(root.getAttribute("Timescale") || 0) : timescale, adaptationType = root.getAttribute("Type");
                if (null == adaptationType) throw new Error("StreamIndex without type.");
                var subType = root.getAttribute("Subtype"), name = root.getAttribute("Name"), language = root.getAttribute("Language"), normalizedLanguage = null == language ? language : Object(languages.a)(language), baseURL = root.getAttribute("Url") || "", _reduceChildren = reduceChildren(root, function(res, _name, node) {
                    switch (_name) {
                      case "QualityLevel":
                        var qualityLevel = parseQualityLevel(node, adaptationType);
                        if ("audio" === adaptationType) {
                            var fourCC = node.getAttribute("FourCC") || "";
                            qualityLevel.codecs = getAudioCodecs(fourCC, qualityLevel.codecPrivateData);
                        }
 // filter out video qualityLevels with small bitrates
                                                ("video" !== adaptationType || qualityLevel.bitrate > MIN_REPRESENTATION_BITRATE) && res.qualityLevels.push(qualityLevel);
                        break;

                      case "c":
                        res.cNodes.push(node);
                    }
                    return res;
                }, {
                    qualityLevels: [],
                    cNodes: []
                }), qualityLevels = _reduceChildren.qualityLevels, index = {
                    timeline: parseCNodes(_reduceChildren.cNodes),
                    timescale: _timescale
                };
                // we assume that all qualityLevels have the same
                // codec and mimeType
                Object(assert.b)(0 !== qualityLevels.length, "adaptation should have at least one representation");
                var adaptationID = adaptationType + (language ? "_" + language : ""), representations = qualityLevels.map(function(qualityLevel) {
                    var firstProtection, path = Object(utils_url.b)(rootURL, baseURL), repIndex = {
                        timeline: index.timeline,
                        timescale: index.timescale,
                        media: replaceRepresentationSmoothTokens(path, qualityLevel.bitrate),
                        timeShiftBufferDepth: timeShiftBufferDepth,
                        manifestReceivedTime: manifestReceivedTime
                    }, mimeType = qualityLevel.mimeType || DEFAULT_MIME_TYPES[adaptationType], codecs = qualityLevel.codecs || DEFAULT_CODECS[adaptationType], id = adaptationID + "_" + adaptationType + "-" + mimeType + "-" + codecs + "-" + qualityLevel.bitrate, contentProtections = [];
                    protections.length && (firstProtection = protections[0], protections.forEach(function(protection) {
                        var keyId = protection.keyId;
                        protection.keySystems.forEach(function(keySystem) {
                            contentProtections.push({
                                keyId: keyId,
                                systemId: keySystem.systemId
                            });
                        });
                    }));
                    var initSegmentInfos = {
                        bitsPerSample: qualityLevel.bitsPerSample,
                        channels: qualityLevel.channels,
                        codecPrivateData: qualityLevel.codecPrivateData || "",
                        packetSize: qualityLevel.packetSize,
                        samplingRate: qualityLevel.samplingRate,
                        // TODO set multiple protections here instead of the first one
                        protection: null != firstProtection ? {
                            keyId: firstProtection.keyId,
                            keySystems: firstProtection.keySystems
                        } : void 0
                    }, representation = object_assign_default()({}, qualityLevel, {
                        index: new representationIndex_SmoothRepresentationIndex(repIndex, initSegmentInfos),
                        mimeType: mimeType,
                        codecs: codecs,
                        id: id
                    });
                    return contentProtections.length && (representation.contentProtections = contentProtections), 
                    representation;
                });
                // TODO(pierre): real ad-insert support
                if ("ADVT" === subType) return null;
                var parsedAdaptation = {
                    id: adaptationID,
                    type: adaptationType,
                    representations: representations,
                    name: null == name ? void 0 : name,
                    language: null == language ? void 0 : language,
                    normalizedLanguage: null == normalizedLanguage ? void 0 : normalizedLanguage
                };
                return "text" === adaptationType && "DESC" === subType && (parsedAdaptation.closedCaption = !0), 
                parsedAdaptation;
            }
            return function parseFromDocument(doc, url, manifestReceivedTime) {
                var rootURL = Object(utils_url.a)(url), root = doc.documentElement;
                if (!root || "SmoothStreamingMedia" !== root.nodeName) throw new Error("document root should be SmoothStreamingMedia");
                if (!/^[2]-[0-2]$/.test(root.getAttribute("MajorVersion") + "-" + root.getAttribute("MinorVersion"))) throw new Error("Version should be 2.0, 2.1 or 2.2");
                var suggestedPresentationDelay, presentationLiveGap, availabilityStartTime, duration, firstTimeReference, lastTimeReference, timescale = +(root.getAttribute("Timescale") || 1e7), _reduceChildren2 = reduceChildren(root, function(res, name, node) {
                    switch (name) {
                      case "Protection":
                        res.protections.push(parseProtectionNode(node, parserOptions.keySystems));
                        break;

                      case "StreamIndex":
                        res.adaptationNodes.push(node);
                    }
                    return res;
                }, {
                    adaptationNodes: [],
                    protections: []
                }), protections = _reduceChildren2.protections, adaptationNodes = _reduceChildren2.adaptationNodes, isLive = parseBoolean(root.getAttribute("IsLive")), timeShiftBufferDepth = isLive ? +(root.getAttribute("DVRWindowLength") || 0) / timescale : void 0, adaptations = adaptationNodes.map(function(node) {
                    return parseAdaptation({
                        root: node,
                        rootURL: rootURL,
                        timescale: timescale,
                        protections: protections,
                        timeShiftBufferDepth: timeShiftBufferDepth,
                        manifestReceivedTime: manifestReceivedTime
                    });
                }).filter(function(adaptation) {
                    return null != adaptation;
                }).reduce(function(acc, adaptation) {
                    var type = adaptation.type;
                    return void 0 === acc[type] ? acc[type] = [ adaptation ] : (acc[type] || []).push(adaptation), 
                    acc;
                }, {}), firstVideoAdaptation = adaptations.video ? adaptations.video[0] : void 0, firstAudioAdaptation = adaptations.audio ? adaptations.audio[0] : void 0;
                if (firstVideoAdaptation || firstAudioAdaptation) {
                    var firstTimeReferences = [], lastTimeReferences = [];
                    if (firstVideoAdaptation) {
                        var firstVideoRepresentation = firstVideoAdaptation.representations[0];
                        if (firstVideoRepresentation) {
                            var firstVideoTimeReference = firstVideoRepresentation.index.getFirstPosition(), lastVideoTimeReference = firstVideoRepresentation.index.getLastPosition();
                            null != firstVideoTimeReference && firstTimeReferences.push(firstVideoTimeReference), 
                            null != lastVideoTimeReference && lastTimeReferences.push(lastVideoTimeReference);
                        }
                    }
                    if (firstAudioAdaptation) {
                        var firstAudioRepresentation = firstAudioAdaptation.representations[0];
                        if (firstAudioRepresentation) {
                            var firstAudioTimeReference = firstAudioRepresentation.index.getFirstPosition(), lastAudioTimeReference = firstAudioRepresentation.index.getLastPosition();
                            null != firstAudioTimeReference && firstTimeReferences.push(firstAudioTimeReference), 
                            null != lastAudioTimeReference && lastTimeReferences.push(lastAudioTimeReference);
                        }
                    }
                    firstTimeReferences.length && (firstTimeReference = Math.max.apply(Math, firstTimeReferences)), 
                    lastTimeReferences.length && (lastTimeReference = Math.max.apply(Math, lastTimeReferences));
                }
                if (isLive) {
                    suggestedPresentationDelay = SUGGESTED_PERSENTATION_DELAY, availabilityStartTime = REFERENCE_DATE_TIME, 
                    presentationLiveGap = Date.now() / 1e3 - (null != lastTimeReference ? lastTimeReference + availabilityStartTime : 10);
                    var manifestDuration = root.getAttribute("Duration");
                    duration = null != manifestDuration && 0 != +manifestDuration ? +manifestDuration / timescale : Infinity;
                } else {
                    // if non-live and first time reference different than 0. Add first time reference
                    // to duration
                    var _manifestDuration = root.getAttribute("Duration");
                    duration = null != _manifestDuration && 0 != +_manifestDuration ? null == lastTimeReference ? +_manifestDuration / timescale + (firstTimeReference || 0) : lastTimeReference : Infinity;
                }
                var minimumTime = null != firstTimeReference ? firstTimeReference : void 0, manifest = {
                    id: "gen-smooth-manifest-" + Object(utils_id.a)(),
                    availabilityStartTime: availabilityStartTime || 0,
                    duration: duration,
                    presentationLiveGap: presentationLiveGap,
                    suggestedPresentationDelay: suggestedPresentationDelay,
                    timeShiftBufferDepth: timeShiftBufferDepth,
                    transportType: "smooth",
                    isLive: isLive,
                    uris: [ url ],
                    minimumTime: minimumTime,
                    periods: [ {
                        id: "gen-smooth-period-0",
                        duration: duration,
                        adaptations: adaptations,
                        start: 0
                    } ]
                };
                return Object(check_manifest_ids.a)(manifest), manifest;
            };
        }, request = __webpack_require__(25), strings = __webpack_require__(88), warnOnce = __webpack_require__(45), manifest_loader = __webpack_require__(87), isobmff = __webpack_require__(32), constants = __webpack_require__(24), read = __webpack_require__(38), SAMPLING_FREQUENCIES = [ 96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350 ], boxNamesMem = {};
        // EXTERNAL MODULE: ./src/utils/request/index.ts
                /**
 * Convert the string name of an ISOBMFF box into the corresponding bytes.
 * Has a memorization mechanism to speed-up if you want to translate the
 * same string multiple times.
 * @param {string} str
 * @returns {Uint8Array}
 */
        function boxName(str) {
            if (boxNamesMem[str]) return boxNamesMem[str];
            var nameInBytes = Object(bytes.p)(str);
            return boxNamesMem[str] = nameInBytes;
        }
        /**
 * Create a new ISOBMFF "box" with the given name.
 * @param {string} name - name of the box you want to create, must always
 * be 4 characters (uuid boxes not supported)
 * @param {Uint8Array} buff - content of the box
 * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)
 */        function Atom(name, buff) {
            var len = buff.length + 8;
            return Object(bytes.h)(Object(bytes.l)(len), boxName(name), buff);
        }
        /**
 * @param {Uint8Array} buf
 * @param {Number} id1
 * @param {Number} id2
 * @param {Number} id3
 * @param {Number} id4
 * @returns {Uint8Array|undefined}
 */        function readUuid(buf, id1, id2, id3, id4) {
            for (var len, l = buf.length, i = 0; i < l; ) {
                if (len = Object(bytes.c)(buf, i), 1970628964
                /* === "uuid" */ === Object(bytes.c)(buf, i + 4) && Object(bytes.c)(buf, i + 8) === id1 && Object(bytes.c)(buf, i + 12) === id2 && Object(bytes.c)(buf, i + 16) === id3 && Object(bytes.c)(buf, i + 20) === id4) return buf.subarray(i + 24, i + len);
                i += len;
            }
        }
        var atoms = {
            /**
   * @param {string} name
   * @param {Array.<Uint8Array>} children
   * @returns {Uint8Array}
   */
            mult: function mult(name, children) {
                return Atom(name, bytes.h.apply(null, children));
            },
            /**
   * @param {string} name - "avc1" or "encv"
   * @param {Number} drefIdx - shall be 1
   * @param {Number} width
   * @param {Number} height
   * @param {Number} hRes - horizontal resolution, eg 72
   * @param {Number} vRes - horizontal resolution, eg 72
   * @param {string} encDepth
   * @param {Number} colorDepth - eg 24
   * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
   * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
   * only if name == "encv"
   * @returns {Uint8Array}
   */
            avc1encv: function avc1encv(name, drefIdx, width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {
                return Atom(name, Object(bytes.h)(6, // 6 bytes reserved
                Object(bytes.k)(drefIdx), 16, // drefIdx + QuickTime reserved, zeroes
                Object(bytes.k)(width), // size 2 w
                Object(bytes.k)(height), // size 2 h
                Object(bytes.k)(hRes), 2, // reso 4 h
                Object(bytes.k)(vRes), 6, // reso 4 v + QuickTime reserved, zeroes
                [ 0, 1, encName.length ], // frame count (default 1)
                Object(bytes.p)(encName), // 1byte len + encoder name str
                31 - encName.length, // + padding
                Object(bytes.k)(colorDepth), // color depth
                [ 255, 255 ], // reserved ones
                avcc, // avcc atom,
                "encv" === name && sinf || []));
            },
            /**
   * @param {Uint8Array} sps
   * @param {Uint8Array} pps
   * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes
   * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, "674d400d96560c0efcb80a70505050a0",
   * 1, "68ef3880")
   * @returns {Uint8Array}
   */
            avcc: function avcc(sps, pps, nalLen) {
                var nal = 2 === nalLen ? 1 : 4 === nalLen ? 3 : 0, h264Profile = sps[1], h264CompatibleProfile = sps[2], h264Level = sps[3];
 // Deduce AVC Profile from SPS
                                return Atom("avcC", Object(bytes.h)([ 1, h264Profile, h264CompatibleProfile, h264Level, 252 | nal, 225 ], Object(bytes.k)(sps.length), sps, [ 1 ], Object(bytes.k)(pps.length), pps));
            },
            /**
   * @param {url} Uint8Array
   * @returns {Uint8Array}
   */
            dref: function dref(url) {
                // only one description here... FIXME
                return Atom("dref", Object(bytes.h)(7, [ 1 ], url));
            },
            /**
   * @param {Number} stream
   * @param {string} codecPrivateData - hex string
   * eg: esds(1, 98800, "1190")
   * @returns {Uint8Array}
   */
            esds: function esds(stream, codecPrivateData) {
                return Atom("esds", Object(bytes.h)(4, [ 3, 25 ], Object(bytes.k)(stream), [ 0, 4, 17, 64, 21 ], 11, [ 5, 2 ], Object(bytes.j)(codecPrivateData), [ 6, 1, 2 ]));
            },
            /**
   * @param {string} dataFormat - four letters (eg "avc1")
   * @returns {Uint8Array}
   */
            frma: function frma(dataFormat) {
                return Atom("frma", Object(bytes.p)(dataFormat));
            },
            /**
   * @param {Number} length
   * @returns {Uint8Array}
   */
            free: function free(length) {
                return Atom("free", new Uint8Array(length - 8));
            },
            /**
   * @param {string} majorBrand
   * @param {Array.<string>} brands
   * @returns {Uint8Array}
   */
            ftyp: function ftyp(majorBrand, brands) {
                return Atom("ftyp", bytes.h.apply(null, [ Object(bytes.p)(majorBrand), [ 0, 0, 0, 1 ] ].concat(brands.map(bytes.p))));
            },
            /**
   * @param {string} type - "video" or "audio"
   * @returns {Uint8Array}
   */
            hdlr: function hdlr(type) {
                var name, handlerName;
                switch (type) {
                  case "video":
                    name = "vide", handlerName = "VideoHandler";
                    break;

                  case "audio":
                    name = "soun", handlerName = "SoundHandler";
                    break;

                  default:
                    name = "hint", handlerName = "";
                }
                return Atom("hdlr", Object(bytes.h)(8, Object(bytes.p)(name), 12, Object(bytes.p)(handlerName), 1));
            },
            /**
   * @param {number} timescale
   * @returns {Uint8Array}
   */
            mdhd: function mdhd(timescale) {
                return Atom("mdhd", Object(bytes.h)(12, Object(bytes.l)(timescale), 8));
            },
            /**
   * @param {Uint8Array} mfhd
   * @param {Uint8Array} traf
   * @returns {Uint8Array}
   */
            moof: function moof(mfhd, traf) {
                return atoms.mult("moof", [ mfhd, traf ]);
            },
            /**
   * @param {string} name - "mp4a" or "enca"
   * @param {Number} drefIdx
   * @param {Number} channelsCount
   * @param {Number} sampleSize
   * @param {Number} packetSize
   * @param {Number} sampleRate
   * @param {Uint8Array} esds - Uint8Array representing the esds atom
   * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
   * only if name == "enca"
   * @returns {Uint8Array}
   */
            mp4aenca: function mp4aenca(name, drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {
                return Atom(name, Object(bytes.h)(6, Object(bytes.k)(drefIdx), 8, Object(bytes.k)(channelsCount), Object(bytes.k)(sampleSize), 2, Object(bytes.k)(packetSize), Object(bytes.k)(sampleRate), 2, esds, "enca" === name && sinf || []));
            },
            /**
   * @param {Number} timescale
   * @param {Number} trackId
   * @returns {Uint8Array}
   */
            mvhd: function mvhd(timescale, trackId) {
                return Atom("mvhd", Object(bytes.h)(12, Object(bytes.l)(timescale), 4, [ 0, 1 ], 2, // we assume rate = 1;
                [ 1, 0 ], 10, // we assume volume = 100%;
                [ 0, 1 ], 14, // default matrix
                [ 0, 1 ], 14, // default matrix
                [ 64, 0, 0, 0 ], 26, Object(bytes.k)(trackId + 1)));
            },
            /**
   * @param {string} systemId - Hex string representing the CDM, 16 bytes.
   * @param {Uint8Array|undefined} privateData - Data associated to protection
   * specific system.
   * @param {Array.<Uint8Array>} keyIds - List of key ids contained in the PSSH
   * @returns {Uint8Array}
   */
            pssh: function pssh(systemId, privateData, keyIds) {
                void 0 === privateData && (privateData = new Uint8Array(0)), void 0 === keyIds && (keyIds = new Uint8Array(0));
                var version, kidList, _systemId = systemId.replace(/-/g, "");
                Object(assert.b)(32 === _systemId.length, "wrong system id length");
                var kidCount = keyIds.length;
                return kidList = 0 < kidCount ? (version = 1, bytes.h.apply(void 0, [ Object(bytes.l)(kidCount) ].concat(keyIds))) : (version = 0, 
                []), Atom("pssh", Object(bytes.h)([ version, 0, 0, 0 ], Object(bytes.j)(_systemId), kidList, Object(bytes.l)(privateData.length), privateData));
            },
            /**
   * @param {Uint8Array} mfhd
   * @param {Uint8Array} tfhd
   * @param {Uint8Array} tfdt
   * @param {Uint8Array} trun
   * @returns {Uint8Array}
   */
            saio: function saio(mfhd, tfhd, tfdt, trun) {
                return Atom("saio", Object(bytes.h)(4, [ 0, 0, 0, 1 ], // ??
                Object(bytes.l)(mfhd.length + tfhd.length + tfdt.length + trun.length + 8 + 8 + 8 + 8)));
            },
            /**
   * @param {Uint8Array} sencData - including 8 bytes flags and entries count
   * @returns {Uint8Array}
   */
            saiz: function saiz(senc) {
                if (0 === senc.length) return Atom("saiz", new Uint8Array(0));
                var flags = Object(bytes.c)(senc, 0), entries = Object(bytes.c)(senc, 4), arr = new Uint8Array(entries + 9);
                arr.set(Object(bytes.l)(entries), 5);
                for (var pairsCnt, pairsLen, i = 9, j = 8; j < senc.length; ) j += 8, // assuming IV is 8 bytes TODO handle 16 bytes IV
                // if we have extradata for each entry
                2 == (2 & flags) ? (pairsLen = 2, j += 6 * (pairsCnt = Object(bytes.a)(senc, j)) + 2) : pairsLen = pairsCnt = 0, 
                arr[i] = 6 * pairsCnt + 8 + pairsLen, i++;
                return Atom("saiz", arr);
            },
            /**
   * @param {string} schemeType - four letters (eg "cenc" for Common Encryption)
   * @param {Number} schemeVersion - eg 65536
   * @returns {Uint8Array}
   */
            schm: function schm(schemeType, schemeVersion) {
                return Atom("schm", Object(bytes.h)(4, Object(bytes.p)(schemeType), Object(bytes.l)(schemeVersion)));
            },
            /**
   * @param {Uint8Array} buf
   * @returns {Uint8Array}
   */
            senc: function senc(buf) {
                return Atom("senc", buf);
            },
            /**
   * @returns {Uint8Array}
   */
            smhd: function smhd() {
                return Atom("smhd", new Uint8Array(8));
            },
            /**
   * @param {Array.<Uint8Array>} representations - arrays of Uint8Array,
   * typically [avc1] or [encv, avc1]
   * @returns {Uint8Array}
   */
            stsd: function stsd(reps) {
                // only one description here... FIXME
                var arrBase = [ 7, [ reps.length ] ];
                return Atom("stsd", bytes.h.apply(void 0, arrBase.concat(reps)));
            },
            /**
   * @param {Number} width
   * @param {Number} height
   * @param {Number} trackId
   * @returns {Uint8Array}
   */
            tkhd: function tkhd(width, height, trackId) {
                return Atom("tkhd", Object(bytes.h)(Object(bytes.l)(7), 8, // we assume track is enabled,
                // in media and in preview.
                Object(bytes.l)(trackId), 20, // we assume trackId = 1;
                [ 1, 0, 0, 0 ], // we assume volume = 100%;
                [ 0, 1, 0, 0 ], 12, // default matrix
                [ 0, 1, 0, 0 ], 12, // default matrix
                [ 64, 0, 0, 0 ], // ??
                Object(bytes.k)(width), 2, // width (TODO handle fixed)
                Object(bytes.k)(height), 2));
            },
            /**
   * @param {Number} trackId
   * @returns {Uint8Array}
   */
            trex: function trex(trackId) {
                // default sample desc idx = 1
                return Atom("trex", Object(bytes.h)(4, Object(bytes.l)(trackId), [ 0, 0, 0, 1 ], 12));
            },
            /**
   * @param {Number} decodeTime
   * @returns {Uint8Array}
   */
            tfdt: function tfdt(decodeTime) {
                return Atom("tfdt", Object(bytes.h)([ 1, 0, 0, 0 ], Object(bytes.m)(decodeTime)));
            },
            /**
   * @param {Number} algId - eg 1
   * @param {Number} ivSize - eg 8
   * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546
   * @returns {Uint8Array}
   */
            tenc: function tenc(algId, ivSize, keyId) {
                return Atom("tenc", Object(bytes.h)(6, [ algId, ivSize ], Object(bytes.j)(keyId)));
            },
            /**
   * @param {Uint8Array} tfhd
   * @param {Uint8Array} tfdt
   * @param {Uint8Array} trun
   * @param {Uint8Array} senc
   * @param {Uint8Array} mfhd
   * @returns {Uint8Array}
   */
            traf: function traf(tfhd, tfdt, trun, mfhd, senc) {
                var trafs = [ tfhd, tfdt, trun ];
                return senc && trafs.push(atoms.senc(senc), atoms.saiz(senc), atoms.saio(mfhd, tfhd, tfdt, trun)), 
                atoms.mult("traf", trafs);
            },
            /**
   * @param {Uint8Array} oldtrun
   * @returns {Uint8Array}
   */
            trun: function trun(oldtrun) {
                if (1 & oldtrun[11]) return oldtrun;
 // If no dataoffset is present, we change the headers and add one
                                var trun = new Uint8Array(oldtrun.length + 4);
                return trun.set(Object(bytes.l)(oldtrun.length + 4), 0), trun.set(oldtrun.subarray(4, 16), 4), 
                // name + (version + headers) +
                // samplecount
                trun[11] = 1 | trun[11], // add data offset header info
                trun.set([ 0, 0, 0, 0 ], 16), // data offset
                trun.set(oldtrun.subarray(16, oldtrun.length), 20), trun;
            },
            /**
   * @returns {Uint8Array}
   */
            vmhd: function vmhd() {
                var arr = new Uint8Array(12);
                // QuickTime...
                return arr[3] = 1, Atom("vmhd", arr);
            }
        }, reads_senc = function senc(traf) {
            return readUuid(traf, 2721664850, 1520127764, 2722393154, 2086964724);
        }, reads_tfxd = function tfxd(traf) {
            return readUuid(traf, 1830656773, 1121273062, 2162299933, 2952222642);
        }, reads_tfrf = function tfrf(traf) {
            return readUuid(traf, 3565190898, 3392751253, 2387879627, 2655430559);
        };
        /**
 * Return AAC ES Header (hexstr form)
 *
 * @param {Number} type
 *          1 = AAC Main
 *          2 = AAC LC
 *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio
 * @param {Number} frequency
 * @param {Number} chans (1 or 2)
 * @returns {string}
 */
        function aacesHeader(type, frequency, chans) {
            var val;
            return val = ((val = ((val = (63 & type) << 4) | 31 & SAMPLING_FREQUENCIES.indexOf(frequency)) << 4) | 31 & chans) << 3, 
            Object(bytes.e)(Object(bytes.k)(val));
        }
        /**
 * @param {Uint8Array} mvhd
 * @param {Uint8Array} mvex
 * @param {Uint8Array} trak
 * @param {Object} pssList
 * @returns {Array.<Uint8Array>}
 */        function moovChildren(mvhd, mvex, trak, pssList) {
            var moov = [ mvhd, mvex, trak ];
            return pssList.forEach(function(pss) {
                var pssh = atoms.pssh(pss.systemId, pss.privateData, pss.keyIds);
                moov.push(pssh);
            }), moov;
        }
        /**
 * /!\ Mutates given segment
 * @param {Uint8Array} segment
 * @param {Number} trunoffset
 * @param {Number} dataoffset
 */        function patchTrunDataOffset(segment, trunoffset, dataOffset) {
            // patch trun dataoffset with new moof atom size
            segment.set(Object(bytes.l)(dataOffset), trunoffset + 16);
        }
        /**
 * @param {Uint8Array} segment
 * @param {Uint8Array} newmoof
 * @param {Uint8Array} oldmoof
 * @param {Number} trunoffset
 * @returns {Uint8Array}
 */        function createNewSegment(segment, newmoof, oldmoof, trunoffset) {
            var segmentlen = segment.length, newmooflen = newmoof.length, oldmooflen = oldmoof.length, mdat = segment.subarray(oldmooflen, segmentlen), newSegment = new Uint8Array(newmooflen + (segmentlen - oldmooflen));
            return newSegment.set(newmoof, 0), newSegment.set(mdat, newmooflen), patchTrunDataOffset(newSegment, trunoffset, newmoof.length + 8), 
            newSegment;
        }
        /**
 * /!\ Mutates given segment
 * @param {Uint8Array} segment
 * @param {Uint8Array} newmoof
 * @param {Uint8Array} oldmoof
 * @param {Number} trunoffset
 * @returns {Uint8Array}
 */        function patchSegmentInPlace(segment, newmoof, oldmoof, trunoffset) {
            var free = oldmoof.length - newmoof.length;
            return segment.set(newmoof, 0), segment.set(atoms.free(free), newmoof.length), patchTrunDataOffset(segment, trunoffset, newmoof.length + 8 + free), 
            segment;
        }
        /**
 * @param {Number} timescale
 * @param {string} type
 * @param {Uint8Array} stsd
 * @param {Uint8Array} mhd
 * @param {Number} width
 * @param {Number} height
 * @param {Array.<Object>} pssList - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */        function createInitSegment(timescale, type, stsd, mhd, width, height, pssList) {
            var stbl = atoms.mult("stbl", [ stsd, Atom("stts", new Uint8Array(8)), Atom("stsc", new Uint8Array(8)), Atom("stsz", new Uint8Array(12)), Atom("stco", new Uint8Array(8)) ]), url = Atom("url ", new Uint8Array([ 0, 0, 0, 1 ])), dref = atoms.dref(url), dinf = atoms.mult("dinf", [ dref ]), minf = atoms.mult("minf", [ mhd, dinf, stbl ]), hdlr = atoms.hdlr(type), mdhd = atoms.mdhd(timescale), mdia = atoms.mult("mdia", [ mdhd, hdlr, minf ]), tkhd = atoms.tkhd(width, height, 1), trak = atoms.mult("trak", [ tkhd, mdia ]), trex = atoms.trex(1), mvex = atoms.mult("mvex", [ trex ]), mvhd = atoms.mvhd(timescale, 1), moov = atoms.mult("moov", moovChildren(mvhd, mvex, trak, pssList)), ftyp = atoms.ftyp("isom", [ "isom", "iso2", "iso6", "avc1", "dash" ]);
            return Object(bytes.h)(ftyp, moov);
        }
        /* harmony default export */        var mp4 = {
            getMdat: read.a,
            getTraf: read.c,
            /**
   * @param {Uint8Array} traf
   * @returns {Array.<Object>}
   */
            parseTfrf: function parseTfrf(traf) {
                var tfrf = reads_tfrf(traf);
                if (!tfrf) return [];
                for (var frags = [], version = tfrf[0], fragCount = tfrf[4], i = 0; i < fragCount; i++) {
                    var duration = void 0, time = void 0;
                    duration = 1 === version ? (time = Object(bytes.d)(tfrf, 16 * i + 5), Object(bytes.d)(tfrf, 16 * i + 5 + 8)) : (time = Object(bytes.c)(tfrf, 8 * i + 5), 
                    Object(bytes.c)(tfrf, 8 * i + 5 + 4)), frags.push({
                        time: time,
                        duration: duration
                    });
                }
                return frags;
            },
            /**
   * @param {Uint8Array} traf
   * @returns {Object|undefined}
   */
            parseTfxd: function parseTfxd(traf) {
                var tfxd = reads_tfxd(traf);
                if (tfxd) return {
                    duration: Object(bytes.d)(tfxd, 12),
                    time: Object(bytes.d)(tfxd, 4)
                };
            },
            /**
   * Return full video Init segment as Uint8Array
   * @param {Number} timescale - lowest number, this one will be set into mdhd
   * *10000 in mvhd, e.g. 1000
   * @param {Number} width
   * @param {Number} height
   * @param {Number} hRes
   * @param {Number} vRes
   * @param {Number} nalLength (1, 2 or 4)
   * @param {string} codecPrivateData
   * @param {string} keyId - hex string representing the key Id,
   * 32 chars. eg. a800dbed49c12c4cb8e0b25643844b9b
   * @param {Array.<Object>} [pssList] - List of dict, example:
   * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
   * @returns {Uint8Array}
   */
            createVideoInitSegment: function createVideoInitSegment(timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId, pssList) {
                var stsd, _pssList = pssList || [], _codecPrivateData$spl = codecPrivateData.split("00000001"), spsHex = _codecPrivateData$spl[1], ppsHex = _codecPrivateData$spl[2], sps = Object(bytes.j)(spsHex), pps = Object(bytes.j)(ppsHex), avcc = atoms.avcc(sps, pps, nalLength);
                if (_pssList.length && null != keyId) {
                    var tenc = atoms.tenc(1, 8, keyId), schi = atoms.mult("schi", [ tenc ]), schm = atoms.schm("cenc", 65536), frma = atoms.frma("avc1"), sinf = atoms.mult("sinf", [ frma, schm, schi ]), encv = atoms.avc1encv("encv", 1, width, height, hRes, vRes, "AVC Coding", 24, avcc, sinf);
                    stsd = atoms.stsd([ encv ]);
                } else {
                    var avc1 = atoms.avc1encv("avc1", // name
                    1, // drefIdx
                    width, height, hRes, vRes, "AVC Coding", // encName
                    24, // color depth
                    avcc);
                    stsd = atoms.stsd([ avc1 ]);
                }
                return createInitSegment(timescale, "video", stsd, atoms.vmhd(), width, height, _pssList);
            },
            /**
   * Return full audio Init segment as Uint8Array
   * @param {Number} timescale
   * @param {Number} channelsCount
   * @param {Number} sampleSize
   * @param {Number} packetSize
   * @param {Number} sampleRate
   * @param {string} codecPrivateData
   * @param {string} keyId - hex string representing the key Id, 32 chars.
   * eg. a800dbed49c12c4cb8e0b25643844b9b
   * @param {Array.<Object>} [pssList] - List of dict, example:
   * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF"}
   * @returns {Uint8Array}
   */
            createAudioInitSegment: function createAudioInitSegment(timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId, pssList) {
                var stsd, _pssList = pssList || [], _codecPrivateData = codecPrivateData || aacesHeader(2, sampleRate, channelsCount), esds = atoms.esds(1, _codecPrivateData);
                if (_pssList.length && null != keyId) {
                    var tenc = atoms.tenc(1, 8, keyId), schi = atoms.mult("schi", [ tenc ]), schm = atoms.schm("cenc", 65536), frma = atoms.frma("mp4a"), sinf = atoms.mult("sinf", [ frma, schm, schi ]), enca = atoms.mp4aenca("enca", 1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf);
                    stsd = atoms.stsd([ enca ]);
                } else {
                    var mp4a = atoms.mp4aenca("mp4a", 1, channelsCount, sampleSize, packetSize, sampleRate, esds);
                    stsd = atoms.stsd([ mp4a ]);
                }
                return createInitSegment(timescale, "audio", stsd, atoms.smhd(), 0, 0, _pssList);
            },
            /**
   * Add decodeTime info in a segment (tfdt box)
   * @param {Uint8Array} segment
   * @param {Number} decodeTime
   * @return {Uint8Array}
   */
            patchSegment: function patchSegment(segment, decodeTime) {
                var oldmoof = segment.subarray(0, Object(bytes.c)(segment, 0)), newtfdt = atoms.tfdt(decodeTime), tfdtlen = newtfdt.length, mfhdlen = Object(bytes.c)(oldmoof, 8), traflen = Object(bytes.c)(oldmoof, mfhdlen + 8), tfhdlen = Object(bytes.c)(oldmoof, mfhdlen + 8 + 8), trunlen = Object(bytes.c)(oldmoof, mfhdlen + 8 + 8 + tfhdlen), oldmfhd = oldmoof.subarray(8, mfhdlen + 8), oldtraf = oldmoof.subarray(mfhdlen + 8 + 8, mfhdlen + 8 + 8 + traflen - 8), oldtfhd = oldtraf.subarray(0, tfhdlen), oldtrun = oldtraf.subarray(tfhdlen, tfhdlen + trunlen);
                // force trackId=1 since trackIds are not always reliable...
                oldtfhd.set([ 0, 0, 0, 1 ], 12);
                // TODO fallback?
                var oldsenc = reads_senc(oldtraf), newtrun = atoms.trun(oldtrun), newtraf = atoms.traf(oldtfhd, newtfdt, newtrun, oldmfhd, oldsenc), newmoof = atoms.moof(oldmfhd, newtraf), trunoffset = mfhdlen + 8 + 8 + tfhdlen + tfdtlen;
 // writes [moof[mfhd|traf[tfhd|tfdt|trun|senc|saiz|saio]]]
                                // TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe
                // try to put free atom inside traf children
                return constants.g ? createNewSegment(segment, newmoof, oldmoof, trunoffset) : 8
                /* minimum "free" atom size */ <= oldmoof.length - newmoof.length ? patchSegmentInPlace(segment, newmoof, oldmoof, trunoffset) : createNewSegment(segment, newmoof, oldmoof, trunoffset);
            }
        }, getTraf = mp4.getTraf, isobmff_timings_infos_parseTfrf = mp4.parseTfrf, isobmff_timings_infos_parseTfxd = mp4.parseTfxd;
        // CONCATENATED MODULE: ./src/net/smooth/isobmff_timings_infos.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /* harmony default export */ var isobmff_timings_infos = function extractTimingsInfos(responseData, segment, isLive) {
            var segmentInfos, tfxdSegment, tfrfSegments, nextSegments = [];
            if (isLive) {
                var traf = getTraf(responseData);
                traf ? (tfrfSegments = isobmff_timings_infos_parseTfrf(traf), tfxdSegment = isobmff_timings_infos_parseTfxd(traf)) : log.a.warn("smooth: could not find traf atom");
            }
            if (tfxdSegment) segmentInfos = {
                time: tfxdSegment.time,
                duration: tfxdSegment.duration,
                timescale: segment.timescale
            }; else {
                // we could always make a mistake when reading a container.
                // If the estimate is too far from what the segment seems to imply, take
                // the segment infos instead.
                var maxDecodeTimeDelta = Math.min(.9 * segment.timescale, null != segment.duration ? segment.duration / 4 : .25), trunDuration = Object(isobmff.a)(responseData);
                segmentInfos = 0 <= trunDuration && (null == segment.duration || Math.abs(trunDuration - segment.duration) <= maxDecodeTimeDelta) ? {
                    time: segment.time,
                    duration: trunDuration,
                    timescale: segment.timescale
                } : {
                    time: segment.time,
                    duration: segment.duration,
                    timescale: segment.timescale
                };
            }
            if (tfrfSegments) for (var i = 0; i < tfrfSegments.length; i++) nextSegments.push({
                time: tfrfSegments[i].time,
                duration: tfrfSegments[i].duration,
                timescale: segment.timescale
            });
            return {
                nextSegments: nextSegments,
                segmentInfos: segmentInfos
            };
        }, Observable = __webpack_require__(9), ISM_REG = /(\.isml?)(\?token=\S+)?$/, TOKEN_REG = /\?token=(\S+)/;
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                function byteRange(_ref) {
            var start = _ref[0], end = _ref[1];
            return end && Infinity !== end ? "bytes=" + +start + "-" + +end : "bytes=" + +start + "-";
        }
        /**
 * TODO Remove this logic completely from the player
 * @returns {string|null}
 */        function extractISML(doc) {
            return doc.getElementsByTagName("media")[0].getAttribute("src");
        }
        /**
 * Returns string corresponding to the token contained in the url's querystring.
 * Empty string if no token is found.
 * @param {string} url
 * @returns {string}
 */        function extractToken(url) {
            var tokenMatch = url.match(TOKEN_REG);
            return tokenMatch && tokenMatch[1] || "";
        }
        /**
 * Replace/Remove token from the url's querystring
 * @param {string} url
 * @param {string} [token]
 * @returns {string}
 */        function replaceToken(url, token) {
            return token ? url.replace(TOKEN_REG, "?token=" + token) : url.replace(TOKEN_REG, "");
        }
        /**
 * @param {string} url
 * @returns {string}
 */        function resolveManifest(url) {
            return ISM_REG.test(url) ? (Object(warnOnce.a)("Giving a isml URL to loadVideo is deprecated. Please give the Manifest URL directly"), 
            url.replace(ISM_REG, "$1/manifest$2")) : url;
        }
        // CONCATENATED MODULE: ./src/net/smooth/segment_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var segment_loader_createVideoInitSegment = mp4.createVideoInitSegment, createAudioInitSegment = mp4.createAudioInitSegment;
        /**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */        function regularSegmentLoader(_ref) {
            var headers, url = _ref.url, range = _ref.segment.range;
            return range && (headers = {
                Range: byteRange(range)
            }), Object(request.a)({
                url: url,
                responseType: "arraybuffer",
                headers: headers
            });
        }
        /**
 * Defines the url for the request, load the right loader (custom/default
 * one).
 */        var segment_loader = function generateSegmentLoader(customSegmentLoader) {
            return function(_ref2) {
                var segment = _ref2.segment, representation = _ref2.representation, adaptation = _ref2.adaptation, period = _ref2.period, manifest = _ref2.manifest;
                if (segment.isInit) {
                    if (!segment.privateInfos || null == segment.privateInfos.smoothInit) throw new Error("Smooth: Invalid segment format");
                    var responseData, smoothInitPrivateInfos = segment.privateInfos.smoothInit, protection = smoothInitPrivateInfos.protection;
                    switch (adaptation.type) {
                      case "video":
                        responseData = segment_loader_createVideoInitSegment(segment.timescale, representation.width || 0, representation.height || 0, 72, 72, 4, // vRes, hRes, nal
                        smoothInitPrivateInfos.codecPrivateData || "", protection && protection.keyId, // keyId
                        protection && protection.keySystems);
                        break;

                      case "audio":
                        responseData = createAudioInitSegment(segment.timescale, smoothInitPrivateInfos.channels || 0, smoothInitPrivateInfos.bitsPerSample || 0, smoothInitPrivateInfos.packetSize || 0, smoothInitPrivateInfos.samplingRate || 0, smoothInitPrivateInfos.codecPrivateData || "", protection && protection.keyId, // keyId
                        protection && protection.keySystems);
                        break;

                      default:
                        responseData = new Uint8Array(0);
                    }
                    return Object(of.a)({
                        type: "data",
                        value: {
                            responseData: responseData
                        }
                    });
                }
                if (null == segment.mediaURL) return Object(of.a)({
                    type: "data",
                    value: {
                        responseData: null
                    }
                });
                var args = {
                    adaptation: adaptation,
                    manifest: manifest,
                    period: period,
                    representation: representation,
                    segment: segment,
                    transport: "smooth",
                    url: segment.mediaURL
                };
                return customSegmentLoader ? Observable.a.create(function(obs) {
                    var hasFinished = !1, hasFallbacked = !1, abort = customSegmentLoader(args, {
                        reject: function reject(err) {
                            void 0 === err && (err = {}), hasFallbacked || (hasFinished = !0, obs.error(err));
                        },
                        resolve: function resolve(_args) {
                            hasFallbacked || (hasFinished = !0, obs.next({
                                type: "response",
                                value: {
                                    responseData: _args.data,
                                    size: _args.size,
                                    duration: _args.duration
                                }
                            }), obs.complete());
                        },
                        fallback: function fallback() {
                            hasFallbacked = !0, regularSegmentLoader(args).subscribe(obs);
                        }
                    });
                    return function() {
                        hasFinished || hasFallbacked || "function" != typeof abort || abort();
                    };
                }) : regularSegmentLoader(args);
            };
        }, smooth_patchSegment = mp4.patchSegment, getMdat = mp4.getMdat, WSX_REG = /\.wsx?(\?token=\S+)?/;
        /* harmony default export */        
        /**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */
        function addNextSegments(adaptation, nextSegments, dlSegment) {
            log.a.debug("Smooth Parser: update segments informations.");
            for (var representations = adaptation.representations, i = 0; i < representations.length; i++) {
                representations[i].index._addSegments(nextSegments, dlSegment);
            }
        }
        /* harmony default export */        __webpack_exports__.default = function(options) {
            void 0 === options && (options = {});
            var smoothManifestParser = smooth(options), segmentLoader = segment_loader(options.segmentLoader), manifestLoaderOptions = {
                customManifestLoader: options.manifestLoader,
                ignoreProgressEvents: !0
            }, manifestLoader = Object(manifest_loader.a)(manifestLoaderOptions), segmentPipeline = {
                loader: function loader(_ref5) {
                    var adaptation = _ref5.adaptation, manifest = _ref5.manifest, period = _ref5.period, representation = _ref5.representation, segment = _ref5.segment;
                    return segmentLoader({
                        adaptation: adaptation,
                        manifest: manifest,
                        period: period,
                        representation: representation,
                        segment: segment
                    });
                },
                parser: function parser(_ref6) {
                    var segment = _ref6.segment, response = _ref6.response, adaptation = _ref6.adaptation, manifest = _ref6.manifest, responseData = response.responseData;
                    if (null == responseData) return Object(of.a)({
                        segmentData: null,
                        segmentInfos: null,
                        segmentOffset: 0
                    });
                    if (segment.isInit) {
                        // smooth init segments are crafted by hand. Their timescale is the one
                        // from the manifest.
                        var initSegmentInfos = {
                            timescale: segment.timescale,
                            time: -1,
                            duration: 0
                        };
                        return Object(of.a)({
                            segmentData: responseData,
                            segmentInfos: initSegmentInfos,
                            segmentOffset: 0
                        });
                    }
                    var responseBuffer = responseData instanceof Uint8Array ? responseData : new Uint8Array(responseData), _extractTimingsInfos = isobmff_timings_infos(responseBuffer, segment, manifest.isLive), nextSegments = _extractTimingsInfos.nextSegments, segmentInfos = _extractTimingsInfos.segmentInfos, segmentData = smooth_patchSegment(responseBuffer, segmentInfos.time);
                    return nextSegments && addNextSegments(adaptation, nextSegments, segmentInfos), 
                    Object(of.a)({
                        segmentData: segmentData,
                        segmentInfos: segmentInfos,
                        segmentOffset: 0
                    });
                }
            };
            return {
                manifest: {
                    resolver: function resolver(_ref) {
                        var url = _ref.url, token = extractToken(url);
                        // TODO Remove WSX logic
                        return (WSX_REG.test(url) ? (Object(warnOnce.a)("Giving WSX URL to loadVideo is deprecated. You should only give Manifest URLs."), 
                        Object(request.a)({
                            url: replaceToken(url, ""),
                            responseType: "document",
                            ignoreProgressEvents: !0
                        }).pipe(Object(map.a)(function(_ref2) {
                            var extractedURL = extractISML(_ref2.value.responseData);
                            if (!extractedURL) throw new Error("Invalid ISML");
                            return extractedURL;
                        }))) : Object(of.a)(url)).pipe(Object(map.a)(function(_url) {
                            return {
                                url: replaceToken(resolveManifest(_url), token)
                            };
                        }));
                    },
                    loader: function loader(_ref3) {
                        var url = _ref3.url;
                        return manifestLoader(url);
                    },
                    parser: function parser(_ref4) {
                        var response = _ref4.response, reqURL = _ref4.url, url = null == response.url ? reqURL : response.url, data = "string" == typeof response.responseData ? new DOMParser().parseFromString(response.responseData, "text/xml") : response.responseData, manifestReceivedTime = response.receivedTime, manifest = smoothManifestParser(data, url, manifestReceivedTime);
                        return Object(of.a)({
                            manifest: manifest,
                            url: url
                        });
                    }
                },
                audio: segmentPipeline,
                video: segmentPipeline,
                text: {
                    loader: function loader(_ref7) {
                        var segment = _ref7.segment, representation = _ref7.representation;
                        if (segment.isInit || null == segment.mediaURL) return Object(of.a)({
                            type: "data",
                            value: {
                                responseData: null
                            }
                        });
                        var responseType = isMP4EmbeddedTrack(representation) ? "arraybuffer" : "text";
                        return Object(request.a)({
                            url: segment.mediaURL,
                            responseType: responseType
                        });
                    },
                    parser: function parser(_ref8) {
                        var response = _ref8.response, segment = _ref8.segment, representation = _ref8.representation, adaptation = _ref8.adaptation, manifest = _ref8.manifest, language = adaptation.language, _representation$mimeT = representation.mimeType, mimeType = void 0 === _representation$mimeT ? "" : _representation$mimeT, _representation$codec = representation.codec, codec = void 0 === _representation$codec ? "" : _representation$codec;
                        var parsedResponse, nextSegments, responseData = response.responseData;
                        if (null === responseData) return Object(of.a)({
                            segmentData: null,
                            segmentInfos: 0 < segment.timescale ? {
                                duration: segment.isInit ? 0 : segment.duration,
                                time: segment.isInit ? -1 : segment.time,
                                timescale: segment.timescale
                            } : null,
                            segmentOffset: 0
                        });
                        var _sdStart, _sdEnd, _sdTimescale, _sdData, _sdType, segmentInfos = null, isMP4 = 0 <= mimeType.indexOf("mp4");
                        if (isMP4) {
                            0, parsedResponse = new Uint8Array(responseData);
                            var timings = isobmff_timings_infos(parsedResponse, segment, manifest.isLive);
                            nextSegments = timings.nextSegments, _sdStart = (segmentInfos = timings.segmentInfos).time, 
                            _sdEnd = null != segmentInfos.duration ? segmentInfos.time + segmentInfos.duration : void 0, 
                            _sdTimescale = segmentInfos.timescale;
                        } else {
                            0, parsedResponse = responseData;
                            var segmentTime = segment.time || 0;
 // vod is simple WebVTT or TTML text
                                                        _sdStart = segmentTime, _sdEnd = null != segment.duration ? segmentTime + segment.duration : void 0, 
                            _sdTimescale = segment.timescale;
                        }
                        if (isMP4) {
                            var lcCodec = codec.toLowerCase();
                            if ("application/ttml+xml+mp4" === mimeType || "stpp" === lcCodec || "stpp.ttml.im1t" === lcCodec) _sdType = "ttml"; else {
                                if ("wvtt" !== lcCodec) throw new Error("could not find a text-track parser for the type " + mimeType);
                                _sdType = "vtt";
                            }
                            var mdat = getMdat(parsedResponse);
                            _sdData = Object(strings.a)(mdat);
                        } else {
                            switch (mimeType) {
                              case "application/x-sami":
                              case "application/smil":
                                // TODO SMIL should be its own format, no?
                                _sdType = "sami";
                                break;

                              case "application/ttml+xml":
                                _sdType = "ttml";
                                break;

                              case "text/vtt":
                                _sdType = "vtt";
                            }
                            if (!_sdType) {
                                if ("srt" !== codec.toLowerCase()) throw new Error("could not find a text-track parser for the type " + mimeType);
                                _sdType = "srt";
                            }
                            _sdData = responseData;
                        }
                        return null != segmentInfos && nextSegments && addNextSegments(adaptation, nextSegments, segmentInfos), 
                        Object(of.a)({
                            segmentData: {
                                type: _sdType,
                                data: _sdData,
                                language: language,
                                timescale: _sdTimescale,
                                start: _sdStart,
                                end: _sdEnd
                            },
                            segmentInfos: segmentInfos,
                            segmentOffset: _sdStart / _sdTimescale
                        });
                    }
                },
                image: {
                    loader: function loader(_ref9) {
                        var segment = _ref9.segment;
                        return segment.isInit || null == segment.mediaURL ? Object(of.a)({
                            type: "data",
                            value: {
                                responseData: null
                            }
                        }) : Object(request.a)({
                            url: segment.mediaURL,
                            responseType: "arraybuffer"
                        });
                    },
                    parser: function parser(_ref10) {
                        var response = _ref10.response, segment = _ref10.segment, responseData = response.responseData;
                        // TODO image Parsing should be more on the sourceBuffer side, no?
                        if (null === responseData || null == features.a.imageParser) return Object(of.a)({
                            segmentData: null,
                            segmentInfos: 0 < segment.timescale ? {
                                duration: segment.isInit ? 0 : segment.duration,
                                time: segment.isInit ? -1 : segment.time,
                                timescale: segment.timescale
                            } : null,
                            segmentOffset: 0
                        });
                        var bifObject = features.a.imageParser(new Uint8Array(responseData)), data = bifObject.thumbs;
                        return Object(of.a)({
                            segmentData: {
                                data: data,
                                start: 0,
                                end: Number.MAX_VALUE,
                                timescale: 1,
                                type: "bif"
                            },
                            segmentInfos: {
                                time: 0,
                                duration: Number.MAX_VALUE,
                                timescale: bifObject.timescale
                            },
                            segmentOffset: 0
                        });
                    }
                }
            };
        };
        /**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */        function isMP4EmbeddedTrack(representation) {
            return !!representation.mimeType && 0 <= representation.mimeType.indexOf("mp4");
        }
        /***/    }, 
    /* 127 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/array-find/find.js
        var find = __webpack_require__(11), find_default = /* */ __webpack_require__.n(find), object_assign = __webpack_require__(6), object_assign_default = /* */ __webpack_require__.n(object_assign), getParameters = __webpack_require__(90), getParentElementsByTagName = __webpack_require__(60), nodes = __webpack_require__(83), ttml_style = __webpack_require__(58), STYLE_ATTRIBUTES = [ "backgroundColor", "color", "direction", "display", "displayAlign", "extent", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "opacity", "origin", "overflow", "padding", "textAlign", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption", "writingMode" ], getTimeDelimiters = __webpack_require__(100), regexps = __webpack_require__(29), SPAN_LEVEL_ATTRIBUTES = [ "color", "direction", "display", "fontFamily", "fontSize", "fontStyle", "fontWeight", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption" ];
        /**
 * Translate a color indicated in TTML-style to a CSS-style color.
 * @param {string} color
 * @returns {string} color
 */
        function ttmlColorToCSSColor(color) {
            // TODO check all possible color fomats
            var regRes;
            return null != (regRes = regexps.b.exec(color)) ? "rgba(" + parseInt(regRes[1], 16) + "," + parseInt(regRes[2], 16) + "," + parseInt(regRes[3], 16) + "," + parseInt(regRes[4], 16) / 255 + ")" : null != (regRes = regexps.a.exec(color)) ? "rgba(" + parseInt(regRes[1] + regRes[1], 16) + "," + parseInt(regRes[2] + regRes[2], 16) + "," + parseInt(regRes[3] + regRes[3], 16) + "," + parseInt(regRes[4] + regRes[4], 16) / 255 + ")" : color;
        }
        /**
 * Try to replicate the textOutline TTML style property into CSS.
 *
 * We mock it throught the text-shadow property, translating the TTML thickness
 * into blur radius and the blur-radius into... nothing.
 *
 * @param {string} color
 * @param {string|number} thickness
 * @returns {string}
 */        function generateCSSTextOutline(color, thickness) {
            return "-1px -1px " + thickness + " " + color + ",1px -1px " + thickness + " " + color + ",-1px 1px " + thickness + " " + color + ",1px 1px " + thickness + " " + color;
        }
 // TODO
        // tts:showBackground (applies to region)
        // tts:zIndex (applies to region)
        /**
 * Apply style set for a singular text span of the current cue.
 * @param {HTMLElement} element - The text span
 * @param {Object} style - The style to apply
 */        function applyTextStyle(element, style, shouldTrimWhiteSpace) {
            // applies to span
            var color = style.color;
            color && (element.style.color = ttmlColorToCSSColor(color));
 // applies to body, div, p, region, span
                        var backgroundColor = style.backgroundColor;
            backgroundColor && (element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor));
 // applies to span
                        var textOutline = style.textOutline;
            if (textOutline) {
                var outlineData = textOutline.trim().replace(/\s+/g, " ").split(" "), len = outlineData.length;
                if (3 === len) {
                    var outlineColor = ttmlColorToCSSColor(outlineData[0]), thickness = outlineData[1];
                    element.style.textShadow = generateCSSTextOutline(outlineColor, thickness);
                } else if (color && 1 === len) {
                    var _thickness = outlineData[0];
                    element.style.textShadow = generateCSSTextOutline(color, _thickness);
                } else if (2 === len) {
                    var isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);
                    // XOR-ing to be sure we get what we have
                    if (isFirstArgAColor !== /^[0-9]/.test(outlineData[0])) if (isFirstArgAColor) {
                        var _outlineColor = ttmlColorToCSSColor(outlineData[0]), _thickness2 = outlineData[1];
                        element.style.textShadow = generateCSSTextOutline(_outlineColor, _thickness2);
                    } else if (color) {
                        var _thickness3 = outlineData[0];
                        element.style.textShadow = generateCSSTextOutline(color, _thickness3);
                    }
                }
            }
 // applies to span
                        var textDecoration = style.textDecoration;
            if (textDecoration) switch (textDecoration) {
              case "noUnderline":
              case "noLineThrough":
              case "noOverline":
                element.style.textDecoration = "none";
                break;

              case "lineThrough":
                element.style.textDecoration = "line-through";
                break;

              default:
                element.style.textDecoration = textDecoration;
            }
 // applies to span
                        var fontFamily = style.fontFamily;
            if (fontFamily) switch (fontFamily) {
              case "proportionalSansSerif":
                element.style.fontFamily = "Arial, Helvetica, Liberation Sans, sans-serif";
                break;

                // TODO monospace or sans-serif or font with both?
                              case "monospaceSansSerif":
              case "sansSerif":
                element.style.fontFamily = "sans-serif";
                break;

              case "monospaceSerif":
              case "default":
                element.style.fontFamily = "Courier New, Liberation Mono, monospace";
                break;

                // TODO font with both?
                              case "proportionalSerif":
                element.style.fontFamily = "serif";
                break;

              default:
                element.style.fontFamily = fontFamily;
            }
 // applies to span
                        var fontStyle = style.fontStyle;
            fontStyle && (element.style.fontStyle = fontStyle);
 // applies to span
                        var fontWeight = style.fontWeight;
            fontWeight && (element.style.fontWeight = fontWeight);
 // applies to span
                        var fontSize = style.fontSize;
            fontSize && (
            // TODO Check if formats are always really 1:1
            element.style.fontSize = fontSize);
 // applies to p, span
                        var direction = style.direction;
            direction && (element.style.direction = direction);
 // applies to p, span
                        var unicodeBidi = style.unicodeBidi;
            if (unicodeBidi) switch (unicodeBidi) {
              case "bidiOverride":
                element.style.unicodeBidi = "bidi-override";
                break;

              case "embed":
                element.style.unicodeBidi = "embed";
                break;

              default:
                element.style.unicodeBidi = "normal";
            }
 // applies to body, div, p, region, span
                        var visibility = style.visibility;
            visibility && (element.style.visibility = visibility), "none" === style.display && (element.style.display = "none");
 // applies to body, div, p, region, span
                        // applies to body, div, p, region, span
            var wrapOption = style.wrapOption;
            element.style.whiteSpace = "noWrap" === wrapOption ? shouldTrimWhiteSpace ? "nowrap" : "pre" : shouldTrimWhiteSpace ? "normal" : "pre-wrap";
        }
        /**
 * Apply style for the general text track div.
 * @param {HTMLElement} element - The <div> the style will be applied on.
 * @param {Object} style - The general style object of the paragraph.
 */        function applyGeneralStyle(element, style) {
            // applies to tt, region
            var extent = style.extent;
            if (extent) {
                var results = regexps.c.exec(extent);
                null != results && (element.style.width = results[1] + "%", element.style.height = results[2] + "%");
            }
 // applies to region
                        style.writingMode;
            var overflow = style.overflow;
            element.style.overflow = overflow || "hidden";
            // applies to region
            var padding = style.padding;
            padding && (element.style.padding = padding);
 // applies to region
                        var origin = style.origin;
            if (origin) {
                var resultsPercent = regexps.c.exec(origin);
                null != resultsPercent && (element.style.position = "relative", element.style.left = resultsPercent[1] + "%", 
                element.style.top = resultsPercent[2] + "%");
            }
 // applies to region
                        var displayAlign = style.displayAlign;
            if (element.style.display = "flex", element.style.flexDirection = "column", displayAlign) switch (displayAlign) {
              case "before":
                element.style.justifyContent = "flex-start";
                break;

              case "center":
                element.style.justifyContent = "center";
                break;

              case "after":
                element.style.justifyContent = "flex-end";
            }
 // applies to region
                        var opacity = style.opacity;
            opacity && (element.style.opacity = opacity);
 // applies to body, div, p, region, span
                        var visibility = style.visibility;
            visibility && (element.style.visibility = visibility), "none" === style.display && (element.style.display = "none");
 // applies to body, div, p, region, span
                }
        /**
 * Apply style set for a <p> element
 * @param {HTMLElement} element - The <p> element
 * @param {Object} style - The general style object of the paragraph.
 */        function applyPStyle(element, style) {
            // applies to body, div, p, region, span
            var paragraphBackgroundColor = style.backgroundColor;
            paragraphBackgroundColor && (element.style.backgroundColor = ttmlColorToCSSColor(paragraphBackgroundColor));
 // applies to p
                        var lineHeight = style.lineHeight;
            lineHeight && (element.style.lineHeight = lineHeight);
 // applies to p
                        var textAlign = style.textAlign;
            if (textAlign) switch (textAlign) {
              case "center":
                element.style.textAlign = "center";
                break;

              case "left":
              case "start":
                // TODO check what start means (difference with left, writing direction?)
                element.style.textAlign = "left";
                break;

              case "right":
              case "end":
                // TODO check what end means (difference with right, writing direction?)
                element.style.textAlign = "right";
            }
        }
        /**
 * Creates span of text for the given #text element, with the right style.
 *
 * TODO create text elements as string? Might help performances.
 * @param {Element} el - the #text element, which text content should be
 * displayed
 * @param {Object} style - the style object for the given text
 * @param {Boolean} shouldTrimWhiteSpace - True if the space should be
 * trimmed.
 * @returns {HTMLElement}
 */        function createTextElement(el, style, shouldTrimWhiteSpace) {
            var textElement = document.createElement("span"), textContent = el.textContent || "";
            if (shouldTrimWhiteSpace) {
                // 1. Trim leading and trailing whitespace.
                // 2. Collapse multiple spaces into one.
                var trimmed = textContent.trim();
                textContent = trimmed = trimmed.replace(/\s+/g, " ");
            }
            return textElement.innerHTML = textContent, textElement.className = "rxp-texttrack-span", 
            applyTextStyle(textElement, style, shouldTrimWhiteSpace), textElement;
        }
        /**
 * Generate every text elements to display in a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle - The general style object of the paragraph.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {Array.<HTMLElement>}
 */        function generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
            /**
   * Recursive function, taking a node in argument and returning the
   * corresponding array of HTMLElement in order.
   * @param {Node} node - the node in question
   * @param {Object} style - the current state of the style for the node.
   * /!\ The style object can be mutated, provide a copy of it.
   * @param {Array.<Element>} spans - The spans parent of this node.
   * @param {Boolean} shouldTrimWhiteSpaceFromParent - True if the space should be
   * trimmed by default. From the parent xml:space parameter.
   * @returns {Array.<HTMLElement>}
   */
            return function loop(node, style, spans, shouldTrimWhiteSpaceFromParent) {
                for (var childNodes = node.childNodes, elements = [], i = 0; i < childNodes.length; i++) {
                    var currentNode = childNodes[i];
                    if ("#text" === currentNode.nodeName) {
                        var backgroundColor = Object(ttml_style.a)([ "backgroundColor" ], spans, styles, regions).backgroundColor;
                        backgroundColor ? style.backgroundColor = backgroundColor : delete style.backgroundColor;
                        var el = createTextElement(currentNode, style, shouldTrimWhiteSpaceFromParent);
                        elements.push(el);
                    } else if ("br" === currentNode.nodeName) {
                        var br = document.createElement("BR");
                        elements.push(br);
                    } else if ("span" === currentNode.nodeName && currentNode.nodeType === Node.ELEMENT_NODE && 0 < currentNode.childNodes.length) {
                        var spaceAttribute = currentNode.getAttribute("xml:space"), shouldTrimWhiteSpaceOnSpan = spaceAttribute ? "default" === spaceAttribute : shouldTrimWhiteSpaceFromParent, newStyle = object_assign_default()({}, style, Object(ttml_style.a)(SPAN_LEVEL_ATTRIBUTES, [ currentNode ], styles, regions));
                        elements.push.apply(elements, loop(currentNode, newStyle, [ currentNode ].concat(spans), shouldTrimWhiteSpaceOnSpan));
                    }
                }
                return elements;
            }(paragraph, object_assign_default()({}, paragraphStyle), [], shouldTrimWhiteSpace);
        }
        /**
 * @param {Element} paragraph
 * @param {Element} body
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {HTMLElement}
 */        function createElement(paragraph, body, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
            var divs = Object(getParentElementsByTagName.a)(paragraph, "div"), parentElement = document.createElement("DIV");
            if (parentElement.className = "rxp-texttrack-region", applyGeneralStyle(parentElement, paragraphStyle), 
            body) {
                // applies to body, div, p, region, span
                var bodyBackgroundColor = Object(ttml_style.a)([ "backgroundColor" ], divs.concat([ body ]), styles, regions).bodyBackgroundColor;
                bodyBackgroundColor && (parentElement.style.backgroundColor = ttmlColorToCSSColor(bodyBackgroundColor));
            }
            var pElement = document.createElement("p");
            pElement.className = "rxp-texttrack-p", applyPStyle(pElement, paragraphStyle);
            for (var textContent = generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace), i = 0; i < textContent.length; i++) pElement.appendChild(textContent[i]);
 // NOTE:
            // The following code is for the inclusion of div elements. This has no
            // advantage for now, and might only with future evolutions.
            // (This is only an indication of what the base of the code could look like).
            // if (divs.length) {
            //   let container = parentElement;
            //   for (let i = divs.length - 1; i >= 0; i--) {
            //     // TODO manage style at div level?
            //     // They are: visibility, display and backgroundColor
            //     // All these do not have any difference if applied to the <p> element
            //     // instead of the div.
            //     // The advantage might only be for multiple <p> elements dispatched
            //     // in multiple div Which we do not manage anyway for now.
            //     const divEl = document.createElement("DIV");
            //     divEl.className = "rxp-texttrack-div";
            //     container.appendChild(divEl);
            //     container = divEl;
            //   }
            //   container.appendChild(pElement);
            //   parentElement.appendChild(container);
            // } else {
            //   parentElement.appendChild(pElement);
            // }
                        return parentElement.appendChild(pElement), parentElement;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parseCue.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Element} body
 * @param {Object} styleBase
 * @param {Object} ttParams
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {Object|null}
 */        function parseCue(paragraph, offset, styles, regions, body, styleBase, ttParams, shouldTrimWhiteSpace) {
            // Disregard empty elements:
            // TTML allows for empty elements like <div></div>.
            // If paragraph has neither time attributes, nor
            // non-whitespace text, don't try to make a cue out of it.
            if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent || "")) return null;
            var _getTimeDelimiters = Object(getTimeDelimiters.a)(paragraph, ttParams);
            return {
                start: _getTimeDelimiters.start + offset,
                end: _getTimeDelimiters.end + offset,
                element: createElement(paragraph, body, regions, styles, styleBase, shouldTrimWhiteSpace)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/index.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * Create array of objects which should represent the given TTML text track.
 * These objects have the following structure
 *   - start {Number}: start time, in seconds, at which the cue should
 *     be displayed
 *   - end {Number}: end time, in seconds, at which the cue should
 *     be displayed
 *   - element {HTMLElement}: <div> element representing the cue, with the
 *     right style. This div should then be appended to an element having
 *     the exact size of the wanted region the text track provide cues for.
 *
 * TODO TTML parsing is still pretty heavy on the CPU.
 * Optimizations have been done, principally to avoid using too much XML APIs,
 * but we can still do better.
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
        function parseTTMLStringToDIV(str, timeOffset) {
            var ret = [], xml = new DOMParser().parseFromString(str, "text/xml");
            if (xml) {
                var tt = xml.getElementsByTagName("tt")[0];
                if (!tt) throw new Error("invalid XML");
                for (var body = Object(nodes.a)(tt), styleNodes = Object(nodes.c)(tt), regionNodes = Object(nodes.b)(tt), paragraphNodes = Object(nodes.d)(tt), params = Object(getParameters.a)(tt), styles = [], i = 0; i <= styleNodes.length - 1; i++) {
                    var styleNode = styleNodes[i];
                    if (styleNode instanceof Element) {
                        var styleID = styleNode.getAttribute("xml:id");
                        null !== styleID && 
                        // TODO styles referencing other styles
                        styles.push({
                            id: styleID,
                            style: Object(ttml_style.b)(styleNode)
                        });
                    }
                }
 // construct regions array based on the xml as an optimization
                                for (var regions = [], _i = 0; _i <= regionNodes.length - 1; _i++) {
                    var regionNode = regionNodes[_i];
                    if (regionNode instanceof Element) {
                        var regionID = regionNode.getAttribute("xml:id");
                        null !== regionID && function() {
                            var regionStyle = Object(ttml_style.b)(regionNode), associatedStyle = regionNode.getAttribute("style");
                            if (associatedStyle) {
                                var style = find_default()(styles, function(x) {
                                    return x.id === associatedStyle;
                                });
                                style && (regionStyle = object_assign_default()({}, style.style, regionStyle));
                            }
                            regions.push({
                                id: regionID,
                                style: regionStyle
                            });
                        }();
                    }
                }
 // Computing the style takes a lot of ressources.
                // To avoid too much re-computation, let's compute the body style right
                // now and do the rest progressively.
                // TODO Compute corresponding CSS style here (as soon as we now the TTML
                // style) to speed up the process even
                // more.
                                for (var bodyStyle = null !== body ? Object(ttml_style.a)(STYLE_ATTRIBUTES, [ body ], styles, regions) : Object(ttml_style.a)(STYLE_ATTRIBUTES, [], styles, regions), shouldTrimWhiteSpaceOnBody = "default" === (body ? body.getAttribute("xml:space") : void 0) || "default" === params.spaceStyle, _i2 = 0; _i2 < paragraphNodes.length; _i2++) {
                    var paragraph = paragraphNodes[_i2];
                    if (paragraph instanceof Element) {
                        var divs = Object(getParentElementsByTagName.a)(paragraph, "div"), paragraphStyle = object_assign_default()({}, bodyStyle, Object(ttml_style.a)(STYLE_ATTRIBUTES, [ paragraph ].concat(divs), styles, regions)), paragraphSpaceAttribute = paragraph.getAttribute("xml:space"), cue = parseCue(paragraph, timeOffset, styles, regions, body, paragraphStyle, params, paragraphSpaceAttribute ? "default" === paragraphSpaceAttribute : shouldTrimWhiteSpaceOnBody);
                        cue && ret.push(cue);
                    }
                }
            }
            return ret;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseTTMLStringToDIV;
        });
    }, 
    /* 128 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/getCueBlocks.ts
        var getCueBlocks = __webpack_require__(89), utils = __webpack_require__(51);
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/utils.ts
                // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/getStyleBlocks.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */
        function getStyleBlocks(linified, headerOffset) {
            for (var styleBlocks = [], i = headerOffset; i < linified.length; i++) 
            //
            if (Object(utils.d)(linified, i)) {
                var startOfStyleBlock = i;
                // continue incrementing i until either:
                //   - empty line
                //   - end of file
                for (i++; linified[i]; ) i++;
                var styleBlock = linified.slice(startOfStyleBlock, i);
                styleBlocks.push(styleBlock);
            } else if (linified[i]) 
            // continue incrementing i until either:
            //   - empty line
            //   - end
            for (;linified[i]; ) i++;
            return styleBlocks;
        }
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/parseCueBlock.ts + 1 modules
                var parseCueBlock = __webpack_require__(99), array_includes = __webpack_require__(13);
        // EXTERNAL MODULE: ./src/utils/array-includes.ts
                // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/convertPayloadToHTML.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Construct an HTMLElement/TextNode representing the given node and apply
 * the right styling on it.
 * @param {Node} baseNode
 * @param {Array.<Object>} styleElements
 * @param {Array.<string>} styleClasses
 * @returns {Node}
 */
        function createStyledElement(baseNode, styleElements, styleClasses) {
            var nodeWithStyle, HTMLTags = [ "u", "i", "b" ], mainNodeName = baseNode.nodeName.toLowerCase().split(".")[0];
            if (Object(array_includes.a)([ "u", "i", "b", "c", "#text" ], mainNodeName)) if ("#text" === mainNodeName) {
                var linifiedText = baseNode.wholeText.split("\n");
                nodeWithStyle = document.createElement("span");
                for (var i = 0; i < linifiedText.length; i++) if (i && nodeWithStyle.appendChild(document.createElement("br")), 
                0 < linifiedText[i].length) {
                    var textNode = document.createTextNode(linifiedText[i]);
                    nodeWithStyle.appendChild(textNode);
                }
            } else {
                var nodeClasses = baseNode.nodeName.toLowerCase().split("."), classIndexes = [];
                if (nodeClasses.forEach(function(nodeClass) {
                    -1 !== styleClasses.indexOf(nodeClass) && classIndexes.push(styleClasses.indexOf(nodeClass));
                }), 0 !== classIndexes.length) {
                    // If style must be applied
                    var attr = document.createAttribute("style");
                    classIndexes.forEach(function(index) {
                        styleElements[index] && (attr.value += styleElements[index].styleContent);
                    });
                    var nameClass = Object(array_includes.a)(HTMLTags, mainNodeName) ? mainNodeName : "span";
                    (nodeWithStyle = document.createElement(nameClass)).setAttributeNode(attr);
                } else {
                    // If style mustn't be applied. Rebuild element with tag name
                    var elementTag = Object(array_includes.a)(HTMLTags, mainNodeName) ? mainNodeName : "span";
                    nodeWithStyle = document.createElement(elementTag);
                }
                for (var j = 0; j < baseNode.childNodes.length; j++) {
                    var child = createStyledElement(baseNode.childNodes[j], styleElements, styleClasses);
                    nodeWithStyle.appendChild(child);
                }
            } else {
                nodeWithStyle = document.createElement("span");
                for (var _j = 0; _j < baseNode.childNodes.length; _j++) {
                    var _child = createStyledElement(baseNode.childNodes[_j], styleElements, styleClasses);
                    nodeWithStyle.appendChild(_child);
                }
            }
            return nodeWithStyle;
        }
        /**
 * @param {string} text
 * @param {Array.<Object>} styleElements
 * @returns {Array.<HTMLElement>}
 */        function convertPayloadToHTML(text, styleElements) {
            for (var styleClasses = styleElements.map(function(styleElement) {
                return styleElement.className;
            }).filter(function(className) {
                return null != className;
            }), filteredText = text.replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, "").replace(/<([u,i,b,c])(\..*?)?(?: .*?)?>(.*?)<\/\1>/g, "<$1$2>$3</$1$2>"), nodes = new DOMParser().parseFromString(filteredText, "text/html").body.childNodes, styledElements = [], i = 0; i < nodes.length; i++) styledElements.push(createStyledElement(nodes[i], styleElements, styleClasses));
            return styledElements;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parseStyleBlock.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 *
 * Parse style element from WebVTT.
 * @param {Array.<string>} styleBlock
 * @return {Array.<Object>} styleElements
 */        function parseStyleBlock(styleBlock) {
            var styleElements = [], index = 1, classNames = [];
            if (styleBlock.length < 2) return [];
            if (styleBlock[1].match(/::cue {/)) classNames.push({
                isGlobalStyle: !0
            }), index++; else for (var cueClassLine; styleBlock[index] && (cueClassLine = styleBlock[index].match(/::cue\(\.?(.*?)\)(?:,| {)/)); ) classNames.push({
                className: cueClassLine[1],
                isGlobalStyle: !1
            }), index++;
            for (var styleContent = ""; styleBlock[index] && !styleBlock[index].match(/}/) && 0 !== styleBlock[index].length; ) styleContent += styleBlock[index], 
            index++;
            return classNames.forEach(function(name) {
                styleElements.push({
                    className: name.className,
                    isGlobalStyle: name.isGlobalStyle,
                    styleContent: styleContent.replace(/\s/g, "")
                });
            }), styleElements;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/index.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * Parse WebVTT from text. Returns an array with:
 * - start : start of current cue, in seconds
 * - end : end of current cue, in seconds
 * - content : HTML formatted cue.
 *
 * Global style is parsed and applied to div element.
 * Specific style is parsed and applied to class element.
 *
 * @param {string} text
 * @param {Number} timeOffset
 * @return {Array.<Object>}
 * @throws Error - Throws if the given WebVTT string is invalid.
 */
        function parseWebVTT(text, timeOffset) {
            var linified = text.split(/\r\n|\n|\r/g);
            if (!linified.length) return [];
            var cuesArray = [], styleElements = [];
            if (!linified[0].match(/^WEBVTT( |\t|\n|\r|$)/)) throw new Error("Can't parse WebVTT: Invalid File.");
            for (var firstLineAfterHeader = Object(utils.b)(linified), styleBlocks = getStyleBlocks(linified, firstLineAfterHeader), cueBlocks = Object(getCueBlocks.a)(linified, firstLineAfterHeader), i = 0; i < styleBlocks.length; i++) {
                var parsedStyles = parseStyleBlock(styleBlocks[i]);
                styleElements.push.apply(styleElements, parsedStyles);
            }
            for (var _i = 0; _i < cueBlocks.length; _i++) {
                var cueObject = Object(parseCueBlock.a)(cueBlocks[_i], timeOffset);
                if (null != cueObject) {
                    var htmlCue = toHTML(cueObject, styleElements);
                    htmlCue && cuesArray.push(htmlCue);
                }
            }
            return cuesArray;
        }
        /**
 * Parse cue block into an object with the following properties:
 *   - start {number}: start time at which the cue should be displayed
 *   - end {number}: end time at which the cue should be displayed
 *   - element {HTMLElement}: the cue text, translated into an HTMLElement
 *
 * Returns undefined if the cue block could not be parsed.
 * @param {Array.<string>} cueBlock
 * @param {Number} timeOffset
 * @param {Array.<Object>} styleElements
 * @returns {Object|undefined}
 */        function toHTML(cueObj, styleElements) {
            var start = cueObj.start, end = cueObj.end, header = cueObj.header, payload = cueObj.payload, region = document.createElement("div"), regionAttr = document.createAttribute("style");
            regionAttr.value = "width:100%;height:100%;display:flex;flex-direction:column;justify-content:flex-end;align-items:center;", 
            region.setAttributeNode(regionAttr);
            // Get content, format and apply style.
            var pElement = document.createElement("p"), pAttr = document.createAttribute("style");
            pAttr.value = "text-align:center", pElement.setAttributeNode(pAttr);
            var spanElement = document.createElement("span"), attr = document.createAttribute("style");
            // set color and background-color default values, as indicated in:
            // https://www.w3.org/TR/webvtt1/#applying-css-properties
            attr.value = "background-color:rgba(0,0,0,0.8);color:white;", spanElement.setAttributeNode(attr);
            var styles = styleElements.filter(function(styleElement) {
                return styleElement.className === header && !styleElement.isGlobalStyle || styleElement.isGlobalStyle;
            }).map(function(styleElement) {
                return styleElement.styleContent;
            });
            return attr.value += styles.join(), spanElement.setAttributeNode(attr), convertPayloadToHTML(payload.join("\n"), styleElements).forEach(function(element) {
                spanElement.appendChild(element);
            }), region.appendChild(pElement), pElement.appendChild(spanElement), {
                start: start,
                end: end,
                element: region
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseWebVTT;
        });
    }, 
    /* 129 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
        var merge = __webpack_require__(135), interval = __webpack_require__(139), concat = __webpack_require__(109), of = __webpack_require__(64), Subject = __webpack_require__(33), startWith = __webpack_require__(138), switchMapTo = __webpack_require__(151), mapTo = __webpack_require__(149), takeUntil = __webpack_require__(141), events = __webpack_require__(12), config = __webpack_require__(2), log = __webpack_require__(0), abstract_source_buffer = __webpack_require__(85), MAX_DELTA_BUFFER_TIME = .2;
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
                /**
 * @see MAX_DELTA_BUFFER_TIME
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
        function areNearlyEqual(a, b) {
            return Math.abs(a - b) <= MAX_DELTA_BUFFER_TIME;
        }
        /**
 * Get all cues strictly before the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */        function getCuesBefore(cues, time) {
            for (var i = 0; i < cues.length; i++) {
                var cue = cues[i];
                if (time < cue.end) return time >= cue.start ? cues.slice(0, i) : cues.slice(0, i + 1);
            }
            return cues.slice();
        }
        /**
 * Get all cues strictly after the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */        function getCuesAfter(cues, time) {
            for (var i = 0; i < cues.length; i++) {
                var cue = cues[i];
                if (time < cue.end) return time >= cue.start ? cues.slice(i + 1, cues.length) : cues.slice(i, cues.length);
            }
            return [];
        }
        /**
 * @param {Object} cuesInfos
 * @param {Number} start
 * @param {Number} end
 * @returns {Array.<Object>}
 */        function removeCuesInfosBetween(cuesInfos, start, end) {
            var end1 = Math.max(cuesInfos.start, start);
            return [ {
                start: cuesInfos.start,
                end: end1,
                cues: getCuesBefore(cuesInfos.cues, start)
            }, {
                start: Math.min(end, cuesInfos.end),
                end: cuesInfos.end,
                cues: getCuesAfter(cuesInfos.cues, end)
            } ];
        }
        /**
 * Manage the buffer of the HTML text Sourcebuffer.
 * Allows to add, remove and recuperate cues at given times.
 * @class TextBufferManager
 */        var TextBufferManager = 
        /* */
        function() {
            function TextBufferManager() {
                this._cuesBuffer = [];
            }
            /**
   * Get corresponding cue for the given time.
   * A cue is an object with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * We do not mutate individual cue here.
   * That is, if the ``get`` method returns the same cue's reference than a
   * previous ``get`` call, its properties are guaranteed to have the exact same
   * values than before, if you did not mutate it on your side.
   * The inverse is true, if the values are the same than before, the reference
   * will stay the same (this is useful to easily check if the DOM should be
   * updated, for example).
   *
   * @param {Number} time
   * @returns {HTMLElement|undefined} - The cue to display
   */            var _proto = TextBufferManager.prototype;
            return _proto.get = function get(time) {
                // begins at the end as most of the time the player will ask for the last
                // CuesGroup
                for (var cuesBuffer = this._cuesBuffer, i = cuesBuffer.length - 1; 0 <= i; i--) for (var cues = cuesBuffer[i].cues, j = cues.length - 1; 0 <= j; j--) {
                    var cue = cues[j];
                    if (time >= cue.start) return time < cue.end ? cue : void 0;
                }
            }, 
            /**
   * Remove cue from a certain range of time.
   * @param {Number} from
   * @param {Number} to
   */
            _proto.remove = function remove(from, _to) {
                for (var to = Math.max(from, _to), cuesBuffer = this._cuesBuffer, len = cuesBuffer.length, i = 0; i < len; i++) if (cuesBuffer[i].end > from) {
                    var startCuesInfos = cuesBuffer[i];
                    if (startCuesInfos.start >= to) 
                    // our cue is strictly after this interval, we have nothing to do
                    return;
 // ``to`` is within this segment
                                        if (startCuesInfos.end >= to) {
                        var _removeCuesInfosBetwe = removeCuesInfosBetween(startCuesInfos, from, to), cuesInfos1 = _removeCuesInfosBetwe[0], cuesInfos2 = _removeCuesInfosBetwe[1];
                        return this._cuesBuffer[i] = cuesInfos1, void cuesBuffer.splice(i + 1, 0, cuesInfos2);
                    }
 // Else remove the part of the segment after ``from``, and the concerned
                    // segments after that
                                        startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from), 
                    startCuesInfos.end = Math.max(from, startCuesInfos.start);
                    for (var j = i + 1; j < len; j++) {
                        var endCuesInfos = cuesBuffer[i];
                        if (to <= endCuesInfos.end) 
                        // remove all cues from the start to this one non-included
                        return cuesBuffer.splice(i + 1, j - (i + 1)), void (// if ``to`` is in the middle of the last segment
                        to > endCuesInfos.start && (endCuesInfos.cues = getCuesAfter(endCuesInfos.cues, to), 
                        endCuesInfos.start = to));
                    }
                    return void cuesBuffer.splice(i + 1, cuesBuffer.length - (i + 1));
                }
            }, 
            /**
   * Insert new cues in our text buffer.
   * cues is an array of objects with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * @param {Array.<Object>} cues - CuesGroups, array of objects with the
   * following properties:
   *   - start {Number}: the time at which the cue will start to be displayed
   *   - end {Number}: the time at which the cue will end to be displayed
   *   - cue {HTMLElement}: The cue
   * @param {Number} start - Start time at which the CuesGroup applies.
   * This is different than the start of the first cue to display in it, this
   * has more to do with the time at which the _text segment_ starts.
   * @param {Number} end - End time at which the CuesGroup applies.
   * This is different than the end of the last cue to display in it, this
   * has more to do with the time at which the _text segment_ ends.
   *
   * TODO add securities to ensure that:
   *   - the start of a CuesGroup is inferior or equal to the start of the first
   *     cue in it
   *   - the end of a CuesGroup is superior or equal to the end of the last
   *     cue in it
   * If those requirements are not met, we could delete some cues when adding
   * a CuesGroup before/after. Find a solution.
   */
            _proto.insert = function insert(cues, start, end) {
                for (var cuesBuffer = this._cuesBuffer, cuesInfosToInsert = {
                    start: start,
                    end: end,
                    cues: cues
                }, i = 0; i < cuesBuffer.length; i++) {
                    var cuesInfos = cuesBuffer[i];
                    if (start < cuesInfos.end) {
                        if (areNearlyEqual(start, cuesInfos.start)) {
                            if (areNearlyEqual(end, cuesInfos.end)) 
                            // exact same segment
                            //   ours:            |AAAAA|
                            //   the current one: |BBBBB|
                            //   Result:          |AAAAA|
                            // Which means:
                            //   1. replace the current cue with ours
                            return void (cuesBuffer[i] = cuesInfosToInsert);
 // our cue goes beyond the current one:
                            //   ours:            |AAAAAAA|
                            //   the current one: |BBBB|
                            //   Result:          |AAAAAAA|
                            // Here we have to delete any cuesInfos which end before ours end,
                            // and see about the following one.
                                                        if (end < cuesInfos.end) 
                            // our cue overlaps with the current one:
                            //   ours:            |AAAAA|
                            //   the current one: |BBBBBBBB|
                            //   Result:          |AAAAABBB|
                            // Which means:
                            //   1. remove some cues at the start of the current one
                            //   2. update start of current one
                            //   3. add ours before the current one
                            return cuesInfos.cues = getCuesAfter(cuesInfos.cues, end), cuesInfos.start = end, 
                            void cuesBuffer.splice(i, 0, cuesInfosToInsert);
                            for (;cuesBuffer.splice(i, 1), (cuesInfos = cuesBuffer[i]) && end > cuesInfos.end; ) ;
                            return !cuesInfos || // There is no cue here
                            areNearlyEqual(end, cuesInfos.end) ? 
                            // put in place
                            void (cuesBuffer[i] = cuesInfosToInsert) : (// else -> end < cuesInfos.end (overlapping case)
                            //   ours:            |AAAAA|
                            //   the current one: |BBBBBBBB|
                            //   Result:          |AAAAABBB|
                            cuesInfos.cues = getCuesAfter(cuesInfos.cues, end), cuesInfos.start = end, void cuesBuffer.splice(i, 0, cuesInfosToInsert));
                        }
 // else -> start > cuesInfos.start
                                                if (start < cuesInfos.start) return end < cuesInfos.start || (areNearlyEqual(end, cuesInfos.start) || (// our cue overlaps the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:     |BBBBB|
                        //   Result:          |AAAAAAABB|
                        // Which means:
                        //   1. remove some cues at the start of the current one
                        //   2. update start of current one
                        //   3. add ours before the current one
                        cuesInfos.cues = getCuesAfter(cuesInfos.cues, end)), 
                        // our cue goes just before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:         |BBBB|
                        //   Result:          |AAAAAAA|BBBB|
                        // Which means:
                        //   - update start time of the current one to be sure
                        //   - add ours before the current one
                        cuesInfos.start = end), 
                        // our cue goes strictly before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:           |BBBB|
                        //   Result:          |AAAAAAA| |BBBB|
                        // Which means:
                        //   - add ours before the current one
                        void cuesBuffer.splice(i, 0, cuesInfosToInsert);
                        if (end > cuesInfos.end || areNearlyEqual(end, cuesInfos.end)) 
                        // our cue overlaps the current one:
                        //   ours:              |AAAAAA|
                        //   the current one: |BBBBB|
                        //   Result:          |BBAAAAAA|
                        //   - or -
                        //   ours:              |AAAA|
                        //   the current one: |BBBBBB|
                        //   Result:          |BBAAAA|
                        // Which means:
                        //   1. remove some cues at the end of the current one
                        //   2. update end of current one
                        //   3. add ours after current one
                        return cuesInfos.cues = getCuesBefore(cuesInfos.cues, start), cuesInfos.end = start, 
                        void cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
 // else -> end < cuesInfos.end
                        // our cue is in the current one:
                        //   ours:              |AAA|
                        //   the current one: |BBBBBBB|
                        //   Result:          |BBAAABB|
                        // Which means:
                        //   1. split current one in two parts based on our cue.
                        //   2. insert our cue into it.
                                                var _removeCuesInfosBetwe2 = removeCuesInfosBetween(cuesInfos, start, end), cuesInfos1 = _removeCuesInfosBetwe2[0], cuesInfos2 = _removeCuesInfosBetwe2[1];
                        return this._cuesBuffer[i] = cuesInfos1, cuesBuffer.splice(i + 1, 0, cuesInfosToInsert), 
                        void cuesBuffer.splice(i + 2, 0, cuesInfos2);
                    }
                }
 // no cues group has the end after our current start.
                // These cues should be the last one
                                cuesBuffer.push(cuesInfosToInsert);
            }, TextBufferManager;
        }(), features = __webpack_require__(10);
        // EXTERNAL MODULE: ./src/features/index.ts
                // CONCATENATED MODULE: ./src/core/source_buffers/text/html/parsers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert text track data into timed HTML Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<Object>}
 * @throws Error - Throw if no parser is found for the given type
 */
        function parseTextTrackToElements(type, data, timestampOffset, language) {
            log.a.debug("HTTSB: Finding parser for html text tracks:", type);
            var parser = features.a.htmlTextTracksParsers[type];
            if (!parser) throw new Error("no parser found for the given text track");
            log.a.debug("HTTSB: Parser found, parsing...");
            var parsed = parser(data, timestampOffset, language);
            return log.a.debug("HTTB: Parsed successfully!", parsed), parsed;
        }
        // CONCATENATED MODULE: ./src/core/source_buffers/text/html/index.ts
        /* harmony export (binding) */        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */        __webpack_require__.d(__webpack_exports__, "default", function() {
            return html_HTMLTextTrackSourceBuffer;
        });
        var MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL = config.a.MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL;
        /**
 * Generate the clock at which TextTrack HTML Cues should be refreshed.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */        function generateClock(videoElement) {
            var seeking$ = Object(events.m)(videoElement), seeked$ = Object(events.l)(videoElement), ended$ = Object(events.c)(videoElement), manualRefresh$ = Object(merge.a)(seeked$, ended$), autoRefresh$ = Object(interval.a)(MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL).pipe(Object(startWith.a)(null));
            return manualRefresh$.pipe(Object(startWith.a)(null), Object(switchMapTo.a)(Object(concat.a)(autoRefresh$.pipe(Object(mapTo.a)(!0), Object(takeUntil.a)(seeking$)), Object(of.a)(!1))));
        }
        /**
 * @param {Element} element
 * @param {Element|null} [child]
 */        function safelyRemoveChild(element, child) {
            if (child) try {
                element.removeChild(child);
            } catch (e) {
                log.a.warn("HTTSB: Can't remove text track: not in the element.");
            }
        }
        /**
 * Source buffer to display TextTracks in the given HTML element.
 * @class HTMLTextTrackSourceBuffer
 */        var html_HTMLTextTrackSourceBuffer = 
        /* */
        function(_AbstractSourceBuffer) {
            /**
   * @param {HTMLMediaElement} videoElement
   * @param {HTMLElement} textTrackElement
   */
            function HTMLTextTrackSourceBuffer(videoElement, textTrackElement) {
                var _this;
                return log.a.debug("HTTSB: Creating html text track source buffer"), (_this = _AbstractSourceBuffer.call(this) || this)._videoElement = videoElement, 
                _this._textTrackElement = textTrackElement, _this._destroy$ = new Subject.a(), _this._buffer = new TextBufferManager(), 
                _this._currentElement = null, generateClock(_this._videoElement).pipe(Object(takeUntil.a)(_this._destroy$)).subscribe(function(shouldDisplay) {
                    if (!shouldDisplay) return safelyRemoveChild(textTrackElement, _this._currentElement), 
                    void (_this._currentElement = null);
 // to spread the time error, we divide the regular chosen interval.
                    // As the clock is also based on real video events, we cannot just
                    // divide by two the regular interval.
                                        var time = Math.max(_this._videoElement.currentTime - MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 2e3, 0), cue = _this._buffer.get(time);
                    if (!cue) return safelyRemoveChild(textTrackElement, _this._currentElement), void (_this._currentElement = null);
                    _this._currentElement !== cue.element && (safelyRemoveChild(textTrackElement, _this._currentElement), 
                    _this._currentElement = cue.element, textTrackElement.appendChild(_this._currentElement));
                }), _this;
            }
            /**
   * Append text tracks.
   * @param {Object} data
   */            _inheritsLoose(HTMLTextTrackSourceBuffer, _AbstractSourceBuffer);
            var _proto = HTMLTextTrackSourceBuffer.prototype;
            return _proto._append = function _append(data) {
                log.a.debug("HTTSB: Appending new html text tracks", data);
                var timescale = data.timescale, timescaledStart = data.start, timescaledEnd = data.end, dataString = data.data, type = data.type, language = data.language;
                if (timescaledEnd && timescaledEnd - timescaledStart <= 0) 
                // this is accepted for error resilience, just skip that case.
                /* tslint:disable:max-line-length */
                log.a.warn("HTTSB: Invalid text track appended: the start time is inferior or equal to the end time."); else {
                    var startTime = timescaledStart / timescale, endTime = null != timescaledEnd ? timescaledEnd / timescale : void 0, cues = parseTextTrackToElements(type, dataString, this.timestampOffset, language), start = startTime, end = null != endTime ? endTime : cues[cues.length - 1].end;
                    this._buffer.insert(cues, start, end), this.buffered.insert(start, end);
                }
            }, 
            /**
   * @param {Number} from
   * @param {Number} to
   */
            _proto._remove = function _remove(from, to) {
                log.a.debug("HTTSB: Removing html text track data", from, to), this._buffer.remove(from, to), 
                this.buffered.remove(from, to);
            }, 
            /**
   * Free up ressources from this sourceBuffer
   */
            _proto._abort = function _abort() {
                log.a.debug("HTTSB: Aborting html text track source buffer"), this._destroy$.next(), 
                this._destroy$.complete(), safelyRemoveChild(this._textTrackElement, this._currentElement);
            }, HTMLTextTrackSourceBuffer;
        }(abstract_source_buffer.a);
        /***/    }, 
    /* 130 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/compat/index.ts
        var compat = __webpack_require__(8), log = __webpack_require__(0), abstract_source_buffer = __webpack_require__(85), features = __webpack_require__(10);
        // EXTERNAL MODULE: ./src/log.ts + 1 modules
                // CONCATENATED MODULE: ./src/core/source_buffers/text/native/parsers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert text track data into timed VTT Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<VTTCue>}
 * @throws Error - Throw if no parser is found for the given type
 */
        function parseTextTrackToCues(type, data, timestampOffset, language) {
            log.a.debug("NTTSB: Finding parser for native text tracks:", type);
            var parser = features.a.nativeTextTracksParsers[type];
            if (!parser) throw new Error("no parser found for the given text track");
            log.a.debug("NTTSB: Parser found, parsing...");
            var parsed = parser(data, timestampOffset, language);
            return log.a.debug("NTTSB: Parsed successfully!", parsed), parsed;
        }
        // CONCATENATED MODULE: ./src/core/source_buffers/text/native/index.ts
        /* harmony export (binding) */        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * Source buffer to display TextTracks in a <track> element, in the given
 * video element.
 * @class NativeTextTrackSourceBuffer
 * @extends AbstractSourceBuffer
 */        __webpack_require__.d(__webpack_exports__, "default", function() {
            return native_NativeTextTrackSourceBuffer;
        });
        var native_NativeTextTrackSourceBuffer = 
        /* */
        function(_AbstractSourceBuffer) {
            /**
   * @param {HTMLMediaElement} videoElement
   * @param {Boolean} hideNativeSubtitle
   */
            function NativeTextTrackSourceBuffer(videoElement, hideNativeSubtitle) {
                var _this;
                log.a.debug("NTTSB: Creating native text track source buffer"), _this = _AbstractSourceBuffer.call(this) || this;
                var _addTextTrack = Object(compat.a)(videoElement, hideNativeSubtitle), track = _addTextTrack.track, trackElement = _addTextTrack.trackElement;
                return _this._videoElement = videoElement, _this._track = track, _this._trackElement = trackElement, 
                _this;
            }
            /**
   * Append text tracks.
   * @param {Object} data
   */            _inheritsLoose(NativeTextTrackSourceBuffer, _AbstractSourceBuffer);
            var _proto = NativeTextTrackSourceBuffer.prototype;
            return _proto._append = function _append(data) {
                log.a.debug("NTTSB: Appending new native text tracks", data);
                var timescale = data.timescale, timescaledStart = data.start, timescaledEnd = data.end, dataString = data.data, type = data.type, language = data.language;
                if (null != timescaledEnd && timescaledEnd - timescaledStart <= 0) 
                // this is accepted for error resilience, just skip that case.
                log.a.warn("NTTSB: Invalid subtitles appended"); else {
                    var startTime = timescaledStart / timescale, endTime = null != timescaledEnd ? timescaledEnd / timescale : void 0, cues = parseTextTrackToCues(type, dataString, this.timestampOffset, language);
                    if (0 < cues.length) {
                        var firstCue = cues[0], currentCues = this._track.cues;
 // NOTE(compat): cleanup all current cues if the newly added
                        // ones are in the past. this is supposed to fix an issue on
                        // IE/Edge.
                                                0 < currentCues.length && firstCue.startTime < currentCues[currentCues.length - 1].startTime && this._remove(firstCue.startTime, Infinity);
                        for (var i = 0; i < cues.length; i++) this._track.addCue(cues[i]);
                        this.buffered.insert(startTime, null != endTime ? endTime : cues[cues.length - 1].endTime);
                    } else null != endTime && this.buffered.insert(startTime, endTime);
                }
            }, 
            /**
   * @param {Number} from
   * @param {Number} to
   */
            _proto._remove = function _remove(from, to) {
                log.a.debug("NTTSB: Removing native text track data", from, to);
                for (var track = this._track, cues = track.cues, i = cues.length - 1; 0 <= i; i--) {
                    var cue = cues[i], startTime = cue.startTime, endTime = cue.endTime;
                    from <= startTime && startTime <= to && endTime <= to && track.removeCue(cue);
                }
                this.buffered.remove(from, to);
            }, _proto._abort = function _abort() {
                log.a.debug("NTTSB: Aborting native text track source buffer");
                var _trackElement = this._trackElement, _videoElement = this._videoElement;
                if (_trackElement && _videoElement && _videoElement.hasChildNodes()) try {
                    _videoElement.removeChild(_trackElement);
                } catch (e) {
                    log.a.warn("NTTSB: Can't remove track element from the video");
                }
                this._track && (this._track.mode = "disabled"), this._trackElement && (this._trackElement.innerHTML = "");
            }, NativeTextTrackSourceBuffer;
        }(abstract_source_buffer.a);
        /***/    }, 
    /* 131 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
                var Subject = __webpack_require__(33), merge = __webpack_require__(135), throwError = __webpack_require__(78), of = __webpack_require__(64), takeUntil = __webpack_require__(141), bytes = __webpack_require__(1), castToObservable = __webpack_require__(18), eventemitter = __webpack_require__(36), constants = __webpack_require__(24), events = __webpack_require__(12);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
                // CONCATENATED MODULE: ./src/compat/eme/keySystemAccess.ts
        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function _createClass(Constructor, protoProps, staticProps) {
            return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
            Constructor;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Simple implementation of the MediaKeySystemAccess EME API.
 *
 * All needed arguments are given to the constructor
 * @class CustomMediaKeySystemAccess
 */        var MediaKeys_requestMediaKeySystemAccess, CustomMediaKeySystemAccess = 
        /* */
        function() {
            /**
   * @param {string} _keyType
   * @param {Object} _mediaKeys
   * @param {Object} _configuration
   */
            function CustomMediaKeySystemAccess(_keyType, _mediaKeys, _configuration) {
                this._keyType = _keyType, this._mediaKeys = _mediaKeys, this._configuration = _configuration;
            }
            /**
   * @returns {string}
   */            var _proto = CustomMediaKeySystemAccess.prototype;
            /**
   * @returns {Promise}
   */            return _proto.createMediaKeys = function createMediaKeys() {
                var _this = this;
                return new Promise(function(res) {
                    return res(_this._mediaKeys);
                });
            }, 
            /**
   * @returns {Object}
   */
            _proto.getConfiguration = function getConfiguration() {
                return this._configuration;
            }, _createClass(CustomMediaKeySystemAccess, [ {
                key: "keySystem",
                get: function get() {
                    return this._keyType;
                }
            } ]), CustomMediaKeySystemAccess;
        }();
        // CONCATENATED MODULE: ./src/compat/eme/MediaKeys.ts
        /* harmony export (binding) */        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return MockMediaKeys;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return MediaKeys_requestMediaKeySystemAccess;
        });
        // Default MockMediaKeys implementation
        var MockMediaKeys = 
        /* */
        function() {
            function MockMediaKeys() {}
            var _proto = MockMediaKeys.prototype;
            return _proto._setVideo = function _setVideo() {
                throw new Error("MediaKeys is not implemented in your browser");
            }, _proto.createSession = function createSession() {
                throw new Error("MediaKeys is not implemented in your browser");
            }, _proto.setServerCertificate = function setServerCertificate() {
                throw new Error("MediaKeys is not implemented in your browser");
            }, MockMediaKeys;
        }();
        if (navigator.requestMediaKeySystemAccess) MediaKeys_requestMediaKeySystemAccess = function requestMediaKeySystemAccess(a, b) {
            return Object(castToObservable.a)(navigator.requestMediaKeySystemAccess(a, b));
        }; else {
            // Wrap "MediaKeys.prototype.update" form an event based system to a
            // Promise based function.
            var wrapUpdate = function wrapUpdate(memUpdate) {
                return function(license, sessionId) {
                    var _this = this;
                    return new Promise(function(resolve, reject) {
                        try {
                            memUpdate.call(_this, license, sessionId), resolve();
                        } catch (e) {
                            reject(e);
                        }
                    });
                };
            }, isOldWebkitMediaElement = function isOldWebkitMediaElement(element) {
                return "function" == typeof element.webkitGenerateKeyRequest;
            };
            /**
   * Returns true if the given media element has old webkit methods
   * corresponding to the IOldWebkitHTMLMediaElement interface.
   * @param {HTMLMediaElement} element
   * @returns {Boolean}
   */            // This is for Chrome with unprefixed EME api
            if (isOldWebkitMediaElement(HTMLVideoElement.prototype)) {
                var MediaKeys_WebkitMediaKeySession = 
                /* */
                function(_EventEmitter) {
                    function WebkitMediaKeySession(mediaElement, keySystem) {
                        var _this2;
                        return (_this2 = _EventEmitter.call(this) || this)._closeSession$ = new Subject.a(), 
                        _this2._vid = mediaElement, _this2._key = keySystem, _this2.sessionId = "", _this2.closed = new Promise(function(resolve) {
                            _this2._closeSession$.subscribe(resolve);
                        }), _this2.keyStatuses = new Map(), _this2.expiration = NaN, Object(merge.a)(events.g(mediaElement), events.e(mediaElement), events.f(mediaElement)).pipe(Object(takeUntil.a)(_this2._closeSession$)).subscribe(function(evt) {
                            return _this2.trigger(evt.type, evt);
                        }), _this2.update = wrapUpdate(function(license, sessionId) {
                            if (!isOldWebkitMediaElement(_this2._vid)) throw new Error("impossible to add a new key");
                            if (0 <= _this2._key.indexOf("clearkey")) {
                                var json = JSON.parse(Object(bytes.f)(license)), key = Object(bytes.p)(atob(json.keys[0].k)), kid = Object(bytes.p)(atob(json.keys[0].kid));
                                _this2._vid.webkitAddKey(_this2._key, key, kid, sessionId);
                            } else _this2._vid.webkitAddKey(_this2._key, license, null, sessionId);
                            _this2.sessionId = sessionId;
                        }), _this2;
                    }
                    _inheritsLoose(WebkitMediaKeySession, _EventEmitter);
                    var _proto2 = WebkitMediaKeySession.prototype;
                    return _proto2.generateRequest = function generateRequest(_initDataType, initData) {
                        var _this3 = this;
                        return new Promise(function(resolve) {
                            if (!isOldWebkitMediaElement(_this3._vid)) throw new Error("impossible to generate a key request");
                            _this3._vid.webkitGenerateKeyRequest(_this3._key, initData), resolve();
                        });
                    }, _proto2.close = function close() {
                        var _this4 = this;
                        return new Promise(function(resolve) {
                            _this4._closeSession$.next(), _this4._closeSession$.complete(), resolve();
                        });
                    }, _proto2.load = function load() {
                        return Promise.resolve(!1);
                    }, _proto2.remove = function remove() {
                        return Promise.resolve();
                    }, WebkitMediaKeySession;
                }(eventemitter.a);
                MockMediaKeys = 
                /* */
                function() {
                    function MockMediaKeys(keySystem) {
                        this.ks_ = keySystem;
                    }
                    var _proto3 = MockMediaKeys.prototype;
                    return _proto3._setVideo = function _setVideo(vid) {
                        this._vid = vid;
                    }, _proto3.createSession = function createSession() {
                        if (!this._vid) throw new Error("Video not attached to the MediaKeys");
                        return new MediaKeys_WebkitMediaKeySession(this._vid, this.ks_);
                    }, _proto3.setServerCertificate = function setServerCertificate() {
                        throw new Error("Server certificate is not implemented in your browser");
                    }, MockMediaKeys;
                }();
                var isTypeSupported = function isTypeSupported(keyType) {
                    // get any <video> element from the DOM or create one
                    // and try the `canPlayType` method
                    var videoElement = document.querySelector("video") || document.createElement("video");
                    return !(!videoElement || !videoElement.canPlayType) && !!videoElement.canPlayType("video/mp4", keyType);
                };
                MediaKeys_requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
                    if (!isTypeSupported(keyType)) return Object(throwError.a)(void 0);
                    for (var i = 0; i < keySystemConfigurations.length; i++) {
                        var keySystemConfiguration = keySystemConfigurations[i], videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, sessionTypes = keySystemConfiguration.sessionTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier, persistentState = keySystemConfiguration.persistentState, supported = !0;
                        if (supported = (supported = (supported = (supported = supported && (!initDataTypes || !!initDataTypes.filter(function(initDataType) {
                            return "cenc" === initDataType;
                        })[0])) && (!sessionTypes || sessionTypes.filter(function(sessionType) {
                            return "temporary" === sessionType;
                        }).length === sessionTypes.length)) && "required" !== distinctiveIdentifier) && "required" !== persistentState) {
                            var keySystemConfigurationResponse = {
                                videoCapabilities: videoCapabilities,
                                audioCapabilities: audioCapabilities,
                                initDataTypes: [ "cenc" ],
                                sessionTypes: [ "temporary" ],
                                distinctiveIdentifier: "not-allowed",
                                persistentState: "not-allowed"
                            };
                            return Object(of.a)(new CustomMediaKeySystemAccess(keyType, new MockMediaKeys(keyType), keySystemConfigurationResponse));
                        }
                    }
                    return Object(throwError.a)(void 0);
                };
            } // This is for IE11
             else if (constants.b && constants.b.prototype && "function" == typeof constants.b.prototype.createSession && "function" == typeof constants.b.isTypeSupported) {
                // TODO implement MediaKeySession completely
                var MediaKeys_IE11MediaKeySession = 
                /* */
                function(_EventEmitter2) {
                    function IE11MediaKeySession(mk) {
                        var _this5;
                        return (_this5 = _EventEmitter2.call(this) || this).sessionId = "", _this5.expiration = NaN, 
                        _this5.keyStatuses = new Map(), _this5._mk = mk, _this5._closeSession$ = new Subject.a(), 
                        _this5.closed = new Promise(function(resolve) {
                            _this5._closeSession$.subscribe(resolve);
                        }), _this5.update = wrapUpdate(function(license, sessionId) {
                            if (!_this5._ss) throw new Error("MediaKeySession not set");
                            _this5._ss.update(license, sessionId), _this5.sessionId = sessionId;
                        }), _this5;
                    }
                    _inheritsLoose(IE11MediaKeySession, _EventEmitter2);
                    var _proto4 = IE11MediaKeySession.prototype;
                    return _proto4.generateRequest = function generateRequest(_initDataType, initData) {
                        var _this6 = this;
                        return new Promise(function(resolve) {
                            _this6._ss = _this6._mk.memCreateSession("video/mp4", initData), Object(merge.a)(events.g(_this6._ss), events.e(_this6._ss), events.f(_this6._ss)).pipe(Object(takeUntil.a)(_this6._closeSession$)).subscribe(function(evt) {
                                return _this6.trigger(evt.type, evt);
                            }), resolve();
                        });
                    }, _proto4.close = function close() {
                        var _this7 = this;
                        return new Promise(function(resolve) {
                            _this7._ss && (
                            /* tslint:disable no-floating-promises */
                            _this7._ss.close(), 
                            /* tslint:enable no-floating-promises */
                            _this7._ss = void 0), _this7._closeSession$.next(), _this7._closeSession$.complete(), 
                            resolve();
                        });
                    }, _proto4.load = function load() {
                        return Promise.resolve(!1);
                    }, _proto4.remove = function remove() {
                        return Promise.resolve();
                    }, IE11MediaKeySession;
                }(eventemitter.a);
 // on IE11, each created session needs to be created on a new
                // MediaKeys object
                                constants.b.prototype.alwaysRenew = !0, constants.b.prototype.memCreateSession = constants.b.prototype.createSession, 
                constants.b.prototype.createSession = function() {
                    /* tslint:disable no-invalid-this */
                    return new MediaKeys_IE11MediaKeySession(this);
                    /* tslint:enable no-invalid-this */                }, MediaKeys_requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
                    // TODO Why TS Do not understand that isTypeSupported exists here?
                    if (!constants.b.isTypeSupported(keyType)) return Object(throwError.a)(void 0);
                    for (var i = 0; i < keySystemConfigurations.length; i++) {
                        var keySystemConfiguration = keySystemConfigurations[i], videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier, supported = !0;
                        if (supported = (supported = supported && (!initDataTypes || !!initDataTypes.filter(function(idt) {
                            return "cenc" === idt;
                        })[0])) && "required" !== distinctiveIdentifier) {
                            var keySystemConfigurationResponse = {
                                videoCapabilities: videoCapabilities,
                                audioCapabilities: audioCapabilities,
                                initDataTypes: [ "cenc" ],
                                distinctiveIdentifier: "not-allowed",
                                persistentState: "required",
                                sessionTypes: [ "temporary", "persistent-license" ]
                            };
                            return Object(of.a)(new CustomMediaKeySystemAccess(keyType, new constants.b(keyType), keySystemConfigurationResponse));
                        }
                    }
                    return Object(throwError.a)(void 0);
                };
            } else MediaKeys_requestMediaKeySystemAccess = null;
        }
        /***/    }, 
    /* 132 */ 
    /* 133 */ , 
    /* 134 */
    /***/ , 
    /* 134 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return defer;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35), _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
        function defer(observableFactory) {
            return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                var input;
                try {
                    input = observableFactory();
                } catch (err) {
                    return void subscriber.error(err);
                }
                return (input ? Object(_from__WEBPACK_IMPORTED_MODULE_1__.a)(input) : Object(_empty__WEBPACK_IMPORTED_MODULE_2__.b)()).subscribe(subscriber);
            });
        }
        //# sourceMappingURL=defer.js.map
        /***/    }, 
    /* 135 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return merge;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31), _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98), _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
        function merge() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            var concurrent = Number.POSITIVE_INFINITY, scheduler = null, last = observables[observables.length - 1];
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(last) ? (scheduler = observables.pop(), 
            1 < observables.length && "number" == typeof observables[observables.length - 1] && (concurrent = observables.pop())) : "number" == typeof last && (concurrent = observables.pop()), 
            null === scheduler && 1 === observables.length && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.a ? observables[0] : Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__.a)(concurrent)(Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__.a)(observables, scheduler));
        }
        //# sourceMappingURL=merge.js.map
        /***/    }, 
    /* 136 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return fromEvent;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47), _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49), _operators_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42);
        /* harmony import */        Object.prototype.toString;
        function fromEvent(target, eventName, options, resultSelector) {
            return Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__.a)(options) && (resultSelector = options, 
            options = void 0), resultSelector ? fromEvent(target, eventName, options).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_3__.a)(function(args) {
                return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__.a)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
            })) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                setupSubscription(target, eventName, function handler(e) {
                    1 < arguments.length ? subscriber.next(Array.prototype.slice.call(arguments)) : subscriber.next(e);
                }, subscriber, options);
            });
        }
        function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
            var unsubscribe;
            if (isEventTarget(sourceObj)) {
                var source_1 = sourceObj;
                sourceObj.addEventListener(eventName, handler, options), unsubscribe = function() {
                    return source_1.removeEventListener(eventName, handler, options);
                };
            } else if (isJQueryStyleEventEmitter(sourceObj)) {
                var source_2 = sourceObj;
                sourceObj.on(eventName, handler), unsubscribe = function() {
                    return source_2.off(eventName, handler);
                };
            } else if (isNodeStyleEventEmitter(sourceObj)) {
                var source_3 = sourceObj;
                sourceObj.addListener(eventName, handler), unsubscribe = function() {
                    return source_3.removeListener(eventName, handler);
                };
            } else {
                if (!sourceObj || !sourceObj.length) throw new TypeError("Invalid event target");
                for (var i = 0, len = sourceObj.length; i < len; i++) setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
            subscriber.add(unsubscribe);
        }
        function isNodeStyleEventEmitter(sourceObj) {
            return sourceObj && "function" == typeof sourceObj.addListener && "function" == typeof sourceObj.removeListener;
        }
        function isJQueryStyleEventEmitter(sourceObj) {
            return sourceObj && "function" == typeof sourceObj.on && "function" == typeof sourceObj.off;
        }
        function isEventTarget(sourceObj) {
            return sourceObj && "function" == typeof sourceObj.addEventListener && "function" == typeof sourceObj.removeEventListener;
        }
        //# sourceMappingURL=fromEvent.js.map
        /***/    }, 
    /* 137 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return filter;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function filter(predicate, thisArg) {
            return function filterOperatorFunction(source) {
                return source.lift(new FilterOperator(predicate, thisArg));
            };
        }
        var FilterOperator = /* */ function() {
            function FilterOperator(predicate, thisArg) {
                this.predicate = predicate, this.thisArg = thisArg;
            }
            return FilterOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
            }, FilterOperator;
        }(), FilterSubscriber = /* */ function(_super) {
            function FilterSubscriber(destination, predicate, thisArg) {
                var _this = _super.call(this, destination) || this;
                return _this.predicate = predicate, _this.thisArg = thisArg, _this.count = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(FilterSubscriber, _super), FilterSubscriber.prototype._next = function(value) {
                var result;
                try {
                    result = this.predicate.call(this.thisArg, value, this.count++);
                } catch (err) {
                    return void this.destination.error(err);
                }
                result && this.destination.next(value);
            }, FilterSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 138 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return startWith;
        });
        /* harmony import */ var _observable_fromArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26), _observable_scalar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76), _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27), _observable_concat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(109), _util_isScheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31);
        /* harmony import */        
        /** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */
        function startWith() {
            for (var array = [], _i = 0; _i < arguments.length; _i++) array[_i] = arguments[_i];
            return function(source) {
                var scheduler = array[array.length - 1];
                Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__.a)(scheduler) ? array.pop() : scheduler = null;
                var len = array.length;
                return 1 !== len || scheduler ? 0 < len ? Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__.a)(Object(_observable_fromArray__WEBPACK_IMPORTED_MODULE_0__.a)(array, scheduler), source) : Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__.a)(Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__.b)(scheduler), source) : Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__.a)(Object(_observable_scalar__WEBPACK_IMPORTED_MODULE_1__.a)(array[0]), source);
            };
        }
        //# sourceMappingURL=startWith.js.map
        /***/    }, 
    /* 139 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return interval;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34), _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
        function interval(period, scheduler) {
            return void 0 === period && (period = 0), void 0 === scheduler && (scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a), 
            (!Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(period) || period < 0) && (period = 0), 
            scheduler && "function" == typeof scheduler.schedule || (scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a), 
            new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return subscriber.add(scheduler.schedule(dispatch, period, {
                    subscriber: subscriber,
                    counter: 0,
                    period: period
                })), subscriber;
            });
        }
        function dispatch(state) {
            var subscriber = state.subscriber, counter = state.counter, period = state.period;
            subscriber.next(counter), this.schedule({
                subscriber: subscriber,
                counter: counter + 1,
                period: period
            }, period);
        }
        //# sourceMappingURL=interval.js.map
        /***/    }, 
    /* 140 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return distinctUntilChanged;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7), _util_tryCatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63), _util_errorObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */
        function distinctUntilChanged(compare, keySelector) {
            return function(source) {
                return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
            };
        }
        var DistinctUntilChangedOperator = /* */ function() {
            function DistinctUntilChangedOperator(compare, keySelector) {
                this.compare = compare, this.keySelector = keySelector;
            }
            return DistinctUntilChangedOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
            }, DistinctUntilChangedOperator;
        }(), DistinctUntilChangedSubscriber = /* */ function(_super) {
            function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
                var _this = _super.call(this, destination) || this;
                return _this.keySelector = keySelector, _this.hasKey = !1, "function" == typeof compare && (_this.compare = compare), 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(DistinctUntilChangedSubscriber, _super), 
            DistinctUntilChangedSubscriber.prototype.compare = function(x, y) {
                return x === y;
            }, DistinctUntilChangedSubscriber.prototype._next = function(value) {
                var key = value;
                if (this.keySelector && (key = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_2__.a)(this.keySelector)(value)) === _util_errorObject__WEBPACK_IMPORTED_MODULE_3__.a) return this.destination.error(_util_errorObject__WEBPACK_IMPORTED_MODULE_3__.a.e);
                var result = !1;
                if (this.hasKey) {
                    if ((result = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_2__.a)(this.compare)(this.key, key)) === _util_errorObject__WEBPACK_IMPORTED_MODULE_3__.a) return this.destination.error(_util_errorObject__WEBPACK_IMPORTED_MODULE_3__.a.e);
                } else this.hasKey = !0;
                !1 === Boolean(result) && (this.key = key, this.destination.next(value));
            }, DistinctUntilChangedSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 141 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return takeUntil;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function takeUntil(notifier) {
            return function(source) {
                return source.lift(new TakeUntilOperator(notifier));
            };
        }
        var TakeUntilOperator = /* */ function() {
            function TakeUntilOperator(notifier) {
                this.notifier = notifier;
            }
            return TakeUntilOperator.prototype.call = function(subscriber, source) {
                var takeUntilSubscriber = new TakeUntilSubscriber(subscriber), notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__.a)(takeUntilSubscriber, this.notifier);
                return notifierSubscription && !takeUntilSubscriber.seenValue ? (takeUntilSubscriber.add(notifierSubscription), 
                source.subscribe(takeUntilSubscriber)) : takeUntilSubscriber;
            }, TakeUntilOperator;
        }(), TakeUntilSubscriber = /* */ function(_super) {
            function TakeUntilSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.seenValue = !1, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(TakeUntilSubscriber, _super), TakeUntilSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.seenValue = !0, this.complete();
            }, TakeUntilSubscriber.prototype.notifyComplete = function() {}, TakeUntilSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 142 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return take;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7), _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79), _observable_empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
        function take(count) {
            return function(source) {
                return 0 === count ? Object(_observable_empty__WEBPACK_IMPORTED_MODULE_3__.b)() : source.lift(new TakeOperator(count));
            };
        }
        var TakeOperator = /* */ function() {
            function TakeOperator(total) {
                if (this.total = total, this.total < 0) throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__.a();
            }
            return TakeOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new TakeSubscriber(subscriber, this.total));
            }, TakeOperator;
        }(), TakeSubscriber = /* */ function(_super) {
            function TakeSubscriber(destination, total) {
                var _this = _super.call(this, destination) || this;
                return _this.total = total, _this.count = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(TakeSubscriber, _super), TakeSubscriber.prototype._next = function(value) {
                var total = this.total, count = ++this.count;
                count <= total && (this.destination.next(value), count === total && (this.destination.complete(), 
                this.unsubscribe()));
            }, TakeSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 143 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mergeMapTo;
        });
        /* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);
        /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */        function mergeMapTo(innerObservable, resultSelector, concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), "function" == typeof resultSelector ? Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            }, resultSelector, concurrent) : ("number" == typeof resultSelector && (concurrent = resultSelector), 
            Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            }, concurrent));
        }
        //# sourceMappingURL=mergeMapTo.js.map
        /***/    }, 
    /* 144 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return ignoreElements;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function ignoreElements() {
            return function ignoreElementsOperatorFunction(source) {
                return source.lift(new IgnoreElementsOperator());
            };
        }
        var IgnoreElementsOperator = /* */ function() {
            function IgnoreElementsOperator() {}
            return IgnoreElementsOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new IgnoreElementsSubscriber(subscriber));
            }, IgnoreElementsOperator;
        }(), IgnoreElementsSubscriber = /* */ function(_super) {
            function IgnoreElementsSubscriber() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(IgnoreElementsSubscriber, _super), IgnoreElementsSubscriber.prototype._next = function(unused) {}, 
            IgnoreElementsSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 145 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return combineLatest;
        });
        /* unused harmony export CombineLatestOperator */
        /* unused harmony export CombineLatestSubscriber */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31), _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(22), _fromArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26), NONE = {};
        /* harmony import */        function combineLatest() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            var resultSelector = null, scheduler = null;
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(observables[observables.length - 1]) && (scheduler = observables.pop()), 
            "function" == typeof observables[observables.length - 1] && (resultSelector = observables.pop()), 
            1 === observables.length && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__.a)(observables[0]) && (observables = observables[0]), 
            Object(_fromArray__WEBPACK_IMPORTED_MODULE_5__.a)(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
        }
        var CombineLatestOperator = /* */ function() {
            function CombineLatestOperator(resultSelector) {
                this.resultSelector = resultSelector;
            }
            return CombineLatestOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
            }, CombineLatestOperator;
        }(), CombineLatestSubscriber = /* */ function(_super) {
            function CombineLatestSubscriber(destination, resultSelector) {
                var _this = _super.call(this, destination) || this;
                return _this.resultSelector = resultSelector, _this.active = 0, _this.values = [], 
                _this.observables = [], _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(CombineLatestSubscriber, _super), CombineLatestSubscriber.prototype._next = function(observable) {
                this.values.push(NONE), this.observables.push(observable);
            }, CombineLatestSubscriber.prototype._complete = function() {
                var observables = this.observables, len = observables.length;
                if (0 === len) this.destination.complete(); else {
                    this.active = len, this.toRespond = len;
                    for (var i = 0; i < len; i++) {
                        var observable = observables[i];
                        this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__.a)(this, observable, observable, i));
                    }
                }
            }, CombineLatestSubscriber.prototype.notifyComplete = function(unused) {
                0 == (this.active -= 1) && this.destination.complete();
            }, CombineLatestSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                var values = this.values, oldVal = values[outerIndex], toRespond = this.toRespond ? oldVal === NONE ? --this.toRespond : this.toRespond : 0;
                values[outerIndex] = innerValue, 0 === toRespond && (this.resultSelector ? this._tryResultSelector(values) : this.destination.next(values.slice()));
            }, CombineLatestSubscriber.prototype._tryResultSelector = function(values) {
                var result;
                try {
                    result = this.resultSelector.apply(this, values);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(result);
            }, CombineLatestSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__.a);
    }, 
    /* 146 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return catchError;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23), _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function catchError(selector) {
            return function catchErrorOperatorFunction(source) {
                var operator = new CatchOperator(selector), caught = source.lift(operator);
                return operator.caught = caught;
            };
        }
        var CatchOperator = /* */ function() {
            function CatchOperator(selector) {
                this.selector = selector;
            }
            return CatchOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
            }, CatchOperator;
        }(), CatchSubscriber = /* */ function(_super) {
            function CatchSubscriber(destination, selector, caught) {
                var _this = _super.call(this, destination) || this;
                return _this.selector = selector, _this.caught = caught, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(CatchSubscriber, _super), CatchSubscriber.prototype.error = function(err) {
                if (!this.isStopped) {
                    var result = void 0;
                    try {
                        result = this.selector(err, this.caught);
                    } catch (err2) {
                        return void _super.prototype.error.call(this, err2);
                    }
                    this._unsubscribeAndRecycle();
                    var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__.a(this, void 0, void 0);
                    this.add(innerSubscriber), Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__.a)(this, result, void 0, void 0, innerSubscriber);
                }
            }, CatchSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 147 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return timer;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34), _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66), _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
        function timer(dueTime, periodOrScheduler, scheduler) {
            void 0 === dueTime && (dueTime = 0);
            var period = -1;
            return Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(periodOrScheduler) ? period = Number(periodOrScheduler) < 1 ? 1 : Number(periodOrScheduler) : Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__.a)(periodOrScheduler) && (scheduler = periodOrScheduler), 
            Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__.a)(scheduler) || (scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a), 
            new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                var due = Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(dueTime) ? dueTime : +dueTime - scheduler.now();
                return scheduler.schedule(dispatch, due, {
                    index: 0,
                    period: period,
                    subscriber: subscriber
                });
            });
        }
        function dispatch(state) {
            var index = state.index, period = state.period, subscriber = state.subscriber;
            if (subscriber.next(index), !subscriber.closed) {
                if (-1 === period) return subscriber.complete();
                state.index = index + 1, this.schedule(state, period);
            }
        }
        //# sourceMappingURL=timer.js.map
        /***/    }, 
    /* 148 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return concatMap;
        });
        /* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);
        /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */        function concatMap(project, resultSelector) {
            return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(project, resultSelector, 1);
        }
        //# sourceMappingURL=concatMap.js.map
        /***/    }, 
    /* 149 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mapTo;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function mapTo(value) {
            return function(source) {
                return source.lift(new MapToOperator(value));
            };
        }
        var MapToOperator = /* */ function() {
            function MapToOperator(value) {
                this.value = value;
            }
            return MapToOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new MapToSubscriber(subscriber, this.value));
            }, MapToOperator;
        }(), MapToSubscriber = /* */ function(_super) {
            function MapToSubscriber(destination, value) {
                var _this = _super.call(this, destination) || this;
                return _this.value = value, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MapToSubscriber, _super), MapToSubscriber.prototype._next = function(x) {
                this.destination.next(this.value);
            }, MapToSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 150 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return tap;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7), _util_noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46), _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
        function tap(nextOrObserver, error, complete) {
            return function tapOperatorFunction(source) {
                return source.lift(new DoOperator(nextOrObserver, error, complete));
            };
        }
        var DoOperator = /* */ function() {
            function DoOperator(nextOrObserver, error, complete) {
                this.nextOrObserver = nextOrObserver, this.error = error, this.complete = complete;
            }
            return DoOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
            }, DoOperator;
        }(), TapSubscriber = /* */ function(_super) {
            function TapSubscriber(destination, observerOrNext, error, complete) {
                var _this = _super.call(this, destination) || this;
                return _this._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, _this._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, _this._tapError = error || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapComplete = complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_3__.a)(observerOrNext) ? (_this._context = _this)._tapNext = observerOrNext : observerOrNext && (_this._context = observerOrNext, 
                _this._tapNext = observerOrNext.next || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapError = observerOrNext.error || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapComplete = observerOrNext.complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a), 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(TapSubscriber, _super), TapSubscriber.prototype._next = function(value) {
                try {
                    this._tapNext.call(this._context, value);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(value);
            }, TapSubscriber.prototype._error = function(err) {
                try {
                    this._tapError.call(this._context, err);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.error(err);
            }, TapSubscriber.prototype._complete = function() {
                try {
                    this._tapComplete.call(this._context);
                } catch (err) {
                    return void this.destination.error(err);
                }
                return this.destination.complete();
            }, TapSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 151 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return switchMapTo;
        });
        /* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);
        /** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */        function switchMapTo(innerObservable, resultSelector) {
            return resultSelector ? Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            }, resultSelector) : Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            });
        }
        //# sourceMappingURL=switchMapTo.js.map
        /***/    }, 
    /* 152 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return share;
        });
        /* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(103), _refCount__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92), _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
        /* harmony import */        
        /** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
        function shareSubjectFactory() {
            return new _Subject__WEBPACK_IMPORTED_MODULE_2__.a();
        }
        function share() {
            return function(source) {
                return Object(_refCount__WEBPACK_IMPORTED_MODULE_1__.a)()(Object(_multicast__WEBPACK_IMPORTED_MODULE_0__.a)(shareSubjectFactory)(source));
            };
        }
        //# sourceMappingURL=share.js.map
        /***/    }, 
    /* 153 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(3), Subject = __webpack_require__(33), QueueAction_QueueAction = /* */ function(_super) {
            function QueueAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this;
            }
            return tslib_es6.a(QueueAction, _super), QueueAction.prototype.schedule = function(state, delay) {
                return void 0 === delay && (delay = 0), 0 < delay ? _super.prototype.schedule.call(this, state, delay) : (this.delay = delay, 
                this.state = state, this.scheduler.flush(this), this);
            }, QueueAction.prototype.execute = function(state, delay) {
                return 0 < delay || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
            }, QueueAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), null !== delay && 0 < delay || null === delay && 0 < this.delay ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay) : scheduler.flush(this);
            }, QueueAction;
        }(__webpack_require__(106).a), queue = /* */ new (/* */ function(_super) {
            function QueueScheduler() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib_es6.a(QueueScheduler, _super), QueueScheduler;
        }(__webpack_require__(105).a))(QueueAction_QueueAction), Subscription = __webpack_require__(15), Subscriber = __webpack_require__(7), empty = __webpack_require__(27), of = __webpack_require__(64), throwError = __webpack_require__(78), Notification_Notification = /* */ function() {
            function Notification(kind, value, error) {
                this.kind = kind, this.value = value, this.error = error, this.hasValue = "N" === kind;
            }
            return Notification.prototype.observe = function(observer) {
                switch (this.kind) {
                  case "N":
                    return observer.next && observer.next(this.value);

                  case "E":
                    return observer.error && observer.error(this.error);

                  case "C":
                    return observer.complete && observer.complete();
                }
            }, Notification.prototype.do = function(next, error, complete) {
                switch (this.kind) {
                  case "N":
                    return next && next(this.value);

                  case "E":
                    return error && error(this.error);

                  case "C":
                    return complete && complete();
                }
            }, Notification.prototype.accept = function(nextOrObserver, error, complete) {
                return nextOrObserver && "function" == typeof nextOrObserver.next ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
            }, Notification.prototype.toObservable = function() {
                switch (this.kind) {
                  case "N":
                    return Object(of.a)(this.value);

                  case "E":
                    return Object(throwError.a)(this.error);

                  case "C":
                    return Object(empty.b)();
                }
                throw new Error("unexpected notification kind value");
            }, Notification.createNext = function(value) {
                return void 0 !== value ? new Notification("N", value) : Notification.undefinedValueNotification;
            }, Notification.createError = function(err) {
                return new Notification("E", void 0, err);
            }, Notification.createComplete = function() {
                return Notification.completeNotification;
            }, Notification.completeNotification = new Notification("C"), Notification.undefinedValueNotification = new Notification("N", void 0), 
            Notification;
        }();
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
                var observeOn_ObserveOnSubscriber = /* */ function(_super) {
            function ObserveOnSubscriber(destination, scheduler, delay) {
                void 0 === delay && (delay = 0);
                var _this = _super.call(this, destination) || this;
                return _this.scheduler = scheduler, _this.delay = delay, _this;
            }
            return tslib_es6.a(ObserveOnSubscriber, _super), ObserveOnSubscriber.dispatch = function(arg) {
                var notification = arg.notification, destination = arg.destination;
                notification.observe(destination), this.unsubscribe();
            }, ObserveOnSubscriber.prototype.scheduleMessage = function(notification) {
                this.destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
            }, ObserveOnSubscriber.prototype._next = function(value) {
                this.scheduleMessage(Notification_Notification.createNext(value));
            }, ObserveOnSubscriber.prototype._error = function(err) {
                this.scheduleMessage(Notification_Notification.createError(err)), this.unsubscribe();
            }, ObserveOnSubscriber.prototype._complete = function() {
                this.scheduleMessage(Notification_Notification.createComplete()), this.unsubscribe();
            }, ObserveOnSubscriber;
        }(Subscriber.a), ObserveOnMessage = /* */ function() {
            return function ObserveOnMessage(notification, destination) {
                this.notification = notification, this.destination = destination;
            };
        }(), ObjectUnsubscribedError = __webpack_require__(40), SubjectSubscription = __webpack_require__(77);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return ReplaySubject_ReplaySubject;
        });
        /** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
        var ReplaySubject_ReplaySubject = /* */ function(_super) {
            function ReplaySubject(bufferSize, windowTime, scheduler) {
                void 0 === bufferSize && (bufferSize = Number.POSITIVE_INFINITY), void 0 === windowTime && (windowTime = Number.POSITIVE_INFINITY);
                var _this = _super.call(this) || this;
                return _this.scheduler = scheduler, _this._events = [], _this._infiniteTimeWindow = !1, 
                _this._bufferSize = bufferSize < 1 ? 1 : bufferSize, _this._windowTime = windowTime < 1 ? 1 : windowTime, 
                windowTime === Number.POSITIVE_INFINITY ? (_this._infiniteTimeWindow = !0, _this.next = _this.nextInfiniteTimeWindow) : _this.next = _this.nextTimeWindow, 
                _this;
            }
            return tslib_es6.a(ReplaySubject, _super), ReplaySubject.prototype.nextInfiniteTimeWindow = function(value) {
                var _events = this._events;
                _events.push(value), _events.length > this._bufferSize && _events.shift(), _super.prototype.next.call(this, value);
            }, ReplaySubject.prototype.nextTimeWindow = function(value) {
                this._events.push(new ReplayEvent(this._getNow(), value)), this._trimBufferThenGetEvents(), 
                _super.prototype.next.call(this, value);
            }, ReplaySubject.prototype._subscribe = function(subscriber) {
                var subscription, _infiniteTimeWindow = this._infiniteTimeWindow, _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents(), scheduler = this.scheduler, len = _events.length;
                if (this.closed) throw new ObjectUnsubscribedError.a();
                if (subscription = this.isStopped || this.hasError ? Subscription.a.EMPTY : (this.observers.push(subscriber), 
                new SubjectSubscription.a(this, subscriber)), scheduler && subscriber.add(subscriber = new observeOn_ObserveOnSubscriber(subscriber, scheduler)), 
                _infiniteTimeWindow) for (var i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i]); else for (i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i].value);
                return this.hasError ? subscriber.error(this.thrownError) : this.isStopped && subscriber.complete(), 
                subscription;
            }, ReplaySubject.prototype._getNow = function() {
                return (this.scheduler || queue).now();
            }, ReplaySubject.prototype._trimBufferThenGetEvents = function() {
                for (var now = this._getNow(), _bufferSize = this._bufferSize, _windowTime = this._windowTime, _events = this._events, eventsCount = _events.length, spliceCount = 0; spliceCount < eventsCount && !(now - _events[spliceCount].time < _windowTime); ) spliceCount++;
                return _bufferSize < eventsCount && (spliceCount = Math.max(spliceCount, eventsCount - _bufferSize)), 
                0 < spliceCount && _events.splice(0, spliceCount), _events;
            }, ReplaySubject;
        }(Subject.a), ReplayEvent = /* */ function() {
            return function ReplayEvent(time, value) {
                this.time = time, this.value = value;
            };
        }();
    }
    /******/ ]);
});