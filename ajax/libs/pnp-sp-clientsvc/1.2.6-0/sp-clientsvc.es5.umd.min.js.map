{"version":3,"file":"sp-clientsvc.es5.umd.min.js","sources":["../../../../node_modules/tslib/tslib.es6.js","../../../../packages/sp-clientsvc/src/opactionbuilders.ts","../../../../packages/sp-clientsvc/src/opbuilders.ts","../../../../packages/sp-clientsvc/src/utils.ts","../../../../packages/sp-clientsvc/src/objectpath.ts","../../../../packages/sp-clientsvc/src/parsers.ts","../../../../packages/sp-clientsvc/src/clintsvcqueryable.ts","../../../../packages/sp-clientsvc/src/batch.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { PropertyType } from \"./types\";\nimport { IMethodParamsBuilder } from \"./opbuilders\";\n\nexport function objectPath(): string {\n    return `<ObjectPath Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\" />`;\n}\n\nexport function identityQuery(): string {\n    return `<ObjectIdentityQuery Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\" />`;\n}\n\nexport function opQuery(selectProperties: string[] = null, childSelectProperties: string[] | null = null): string {\n\n    // this is fairly opaque behavior, but is the simplest way to convey the required information.\n    // if selectProperties.length === 0 or null then select all\n    // else select indicated properties\n\n    // if childSelectProperties === null do not include that block\n    // if childSelectProperties.length === 0 then select all\n    // else select indicated properties\n\n    const builder = [];\n    builder.push(`<Query Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\">`);\n    if (selectProperties === null || selectProperties.length < 1) {\n        builder.push(`<Query SelectAllProperties=\"true\" >`);\n        builder.push(`<Properties />`);\n        builder.push(`</Query >`);\n    } else {\n        builder.push(`<Query SelectAllProperties=\"false\" >`);\n        builder.push(`<Properties>`);\n        [].push.apply(builder, selectProperties.map(p => `<Property Name=\"${p}\" SelectAll=\"true\" />`));\n        builder.push(`</Properties>`);\n        builder.push(`</Query >`);\n    }\n\n    if (childSelectProperties !== null) {\n        if (childSelectProperties.length < 1) {\n            builder.push(`<ChildItemQuery SelectAllProperties=\"true\" >`);\n            builder.push(`<Properties />`);\n            builder.push(`</ChildItemQuery >`);\n        } else {\n            builder.push(`<ChildItemQuery SelectAllProperties=\"false\" >`);\n            builder.push(`<Properties>`);\n            [].push.apply(builder, childSelectProperties.map(p => `<Property Name=\"${p}\" SelectAll=\"true\" />`));\n            builder.push(`</Properties>`);\n            builder.push(`</ChildItemQuery >`);\n        }\n    }\n\n    builder.push(`</Query >`);\n\n    return builder.join(\"\");\n}\n\nexport function setProperty(name: string, type: PropertyType, value: string): string {\n    const builder = [];\n    builder.push(`<SetProperty Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\" Name=\"${name}\">`);\n    builder.push(`<Parameter Type=\"${type}\">${value}</Parameter>`);\n    builder.push(`</SetProperty>`);\n    return builder.join(\"\");\n}\n\nexport function methodAction(name: string, params: IMethodParamsBuilder | null): string {\n\n    const builder = [];\n    builder.push(`<Method Id=\"$$ID$$\" ObjectPathId=\"$$PATH_ID$$\" Name=\"${name}\">`);\n\n    if (params !== null) {\n        const arrParams = params.toArray();\n        if (arrParams.length < 1) {\n            builder.push(`<Parameters />`);\n        } else {\n            builder.push(`<Parameters>`);\n            [].push.apply(builder, arrParams.map(p => `<Parameter Type=\"${p.type}\">${p.value}</Parameter>`));\n            builder.push(`</Parameters>`);\n        }\n    }\n\n    builder.push(\"</Method>\");\n\n    return builder.join(\"\");\n}\n\nexport function objectProperties(o: any): string[] {\n\n    return Object.getOwnPropertyNames(o).map((name) => {\n\n        const value = o[name];\n        if (typeof value === \"boolean\") {\n            return setProperty(name, \"Boolean\", `${value}`);\n        } else if (typeof value === \"number\") {\n            return setProperty(name, \"Number\", `${value}`);\n        } else if (typeof value === \"string\") {\n            return setProperty(name, \"String\", `${value}`);\n        }\n\n        return \"\";\n    }, []);\n}\n","import { ObjectPath, IObjectPath } from \"./objectpath\";\nimport { PropertyType } from \"./types\";\n\nexport function property(name: string, ...actions: string[]): IObjectPath {\n    return new ObjectPath(`<Property Id=\"$$ID$$\" ParentId=\"$$PARENT_ID$$\" Name=\"${name}\" />`, actions);\n}\n\nexport function staticMethod(name: string, typeId: string, ...actions: string[]): IObjectPath {\n    return new ObjectPath(`<StaticMethod Id=\"$$ID$$\" Name=\"${name}\" TypeId=\"${typeId}\" />`, actions);\n}\n\nexport function staticProperty(name: string, typeId: string, ...actions: string[]): IObjectPath {\n    return new ObjectPath(`<StaticProperty Id=\"$$ID$$\" Name=\"${name}\" TypeId=\"${typeId}\" />`, actions);\n}\n\nexport function objConstructor(typeId: string, ...actions: string[]): IObjectPath {\n    return new ObjectPath(`<Constructor Id=\"$$ID$$\" TypeId=\"${typeId}\" />`, actions);\n}\n\nexport interface IMethodParamsBuilder {\n    string(value: string): this;\n    number(value: number): this;\n    boolean(value: boolean): this;\n    objectPath(inputIndex: number): this;\n    toArray(): { type: PropertyType, value: string }[];\n}\n\n/**\n * Used to build parameters when calling methods\n */\nexport class MethodParams implements IMethodParamsBuilder {\n\n    constructor(private _p: { type: PropertyType, value: string }[] = []) { }\n\n    public static build(initValues: { type: PropertyType, value: string }[] = []): IMethodParamsBuilder {\n        const params = new MethodParams();\n        [].push.apply(params._p, initValues);\n        return params;\n    }\n\n    public string(value: string): this {\n        return this.a(\"String\", value);\n    }\n\n    public number(value: number): this {\n        return this.a(\"Number\", value.toString());\n    }\n\n    public boolean(value: boolean): this {\n        return this.a(\"Boolean\", value.toString());\n    }\n\n    public objectPath(inputIndex: number): this {\n        return this.a(\"ObjectPath\", inputIndex.toString());\n    }\n\n    public toArray(): { type: PropertyType, value: string }[] {\n        return this._p;\n    }\n\n    private a(type: PropertyType, value: string): this {\n        this._p.push({ type, value });\n        return this;\n    }\n}\n\nexport function method(name: string, params: IMethodParamsBuilder, ...actions: string[]): IObjectPath {\n    const builder = [];\n    builder.push(`<Method Id=\"$$ID$$\" ParentId=\"$$PARENT_ID$$\" Name=\"${name}\">`);\n\n    if (params !== null) {\n        const arrParams = params.toArray();\n        if (arrParams.length < 1) {\n            builder.push(`<Parameters />`);\n        } else {\n            builder.push(`<Parameters>`);\n            [].push.apply(builder, arrParams.map(p => {\n\n                if (p.type === \"ObjectPath\") {\n                    return `<Parameter ObjectPathId=\"$$OP_PARAM_ID_${p.value}$$\" />`;\n                }\n\n                return `<Parameter Type=\"${p.type}\">${p.value}</Parameter>`;\n            }));\n            builder.push(`</Parameters>`);\n        }\n    }\n\n    builder.push(\"</Method>\");\n\n    return new ObjectPath(builder.join(\"\"), actions);\n}\n","import { IObjectPath } from \"./objectpath\";\n\n/**\n * Transforms an array of object paths into a request xml body. Does not do placeholder substitutions.\n * \n * @param objectPaths The object paths for which we want to generate a body\n */\nexport function writeObjectPathBody(objectPaths: IObjectPath[]): string {\n\n    const actions: string[] = [];\n    const paths: string[] = [];\n\n    objectPaths.forEach(op => {\n        paths.push(op.path);\n        actions.push(...op.actions);\n    });\n\n    // create our xml payload\n    return [\n        `<Request xmlns=\"http://schemas.microsoft.com/sharepoint/clientquery/2009\" SchemaVersion=\"15.0.0.0\" LibraryVersion=\"16.0.0.0\" ApplicationName=\"PnPjs\">`,\n        \"<Actions>\",\n        actions.join(\"\"),\n        \"</Actions>\",\n        \"<ObjectPaths>\",\n        paths.join(\"\"),\n        \"</ObjectPaths>\",\n        \"</Request>\",\n    ].join(\"\");\n}\n","import { TypedHash, extend, objectDefinedNotNull } from \"@pnp/common\";\nimport { objectPath } from \"./opactionbuilders\";\nimport { property, staticProperty } from \"./opbuilders\";\nimport { writeObjectPathBody } from \"./utils\";\n\n/**\n * Defines the properties and method of an ObjectPath\n */\nexport interface IObjectPath {\n    /**\n     * The ObjectPath xml node\n     */\n    path: string;\n    /**\n     * Collection of xml action nodes\n     */\n    actions: string[];\n    /**\n     * The id of this object path, used for processing, not set directly\n     */\n    id: number | undefined;\n}\n\n/**\n * Represents an ObjectPath used when querying ProcessQuery\n */\nexport class ObjectPath implements IObjectPath {\n    constructor(public path: string, public actions: string[] = [], public id = -1, public replaceAfter: IObjectPath[] = []) { }\n}\n\n/**\n * Replaces all found instance of the $$ID$$ placeholder in the supplied xml string\n * \n * @param id New value to be insterted\n * @param xml The existing xml fragment in which the replace should occur\n */\nexport function opSetId(id: string, xml: string): string {\n    return xml.replace(/\\$\\$ID\\$\\$/g, id);\n}\n\n/**\n * Replaces all found instance of the $$PATH_ID$$ placeholder in the supplied xml string\n * \n * @param id New value to be insterted\n * @param xml The existing xml fragment in which the replace should occur\n */\nexport function opSetPathId(id: string, xml: string): string {\n    return xml.replace(/\\$\\$PATH_ID\\$\\$/g, id);\n}\n\n/**\n * Replaces all found instance of the $$PARENT_ID$$ placeholder in the supplied xml string\n * \n * @param id New value to be insterted\n * @param xml The existing xml fragment in which the replace should occur\n */\nexport function opSetParentId(id: string, xml: string): string {\n    return xml.replace(/\\$\\$PARENT_ID\\$\\$/g, id);\n}\n\n/**\n * Replaces all found instance of the $$OP_PARAM_ID$$ placeholder in the supplied xml string\n * \n * @param map A mapping where [index] = replaced_object_path_id\n * @param xml The existing xml fragment in which the replace should occur\n * @param indexMapper Used when creating batches, not meant for direct use external to this library\n */\nexport function opSetPathParamId(map: number[], xml: string, indexMapper: (n: number) => number = (n) => n): string {\n\n    // this approach works because input params must come before the things that need them\n    // meaning the right id will always be in the map\n    const matches = /\\$\\$OP_PARAM_ID_(\\d+)\\$\\$/ig.exec(xml);\n    if (matches !== null) {\n        for (let i = 1; i < matches.length; i++) {\n            const index = parseInt(matches[i], 10);\n            const regex = new RegExp(`\\\\$\\\\$OP_PARAM_ID_${index}\\\\$\\\\$`, \"ig\");\n            xml = xml.replace(regex, map[indexMapper(index)].toString());\n        }\n    }\n\n    return xml;\n}\n\n/**\n * Represents a collection of IObjectPaths\n */\nexport class ObjectPathQueue {\n\n    private _xml: string | null;\n    private _contextIndex = -1;\n    private _siteIndex = -1;\n    private _webIndex = -1;\n\n    constructor(protected _paths: IObjectPath[] = [], protected _relationships: TypedHash<number[]> = {}) { }\n\n    /**\n     * Adds an object path to the queue\n     * \n     * @param op The action to add\n     * @returns The index of the added object path\n     */\n    public add(op: IObjectPath): number {\n\n        this.dirty();\n        this._paths.push(op);\n        return this.lastIndex;\n    }\n\n    public addChildRelationship(parentIndex: number, childIndex: number) {\n        if (objectDefinedNotNull(this._relationships[`_${parentIndex}`])) {\n            this._relationships[`_${parentIndex}`].push(childIndex);\n        } else {\n            this._relationships[`_${parentIndex}`] = [childIndex];\n        }\n    }\n\n    public getChildRelationship(parentIndex: number): number[] {\n        if (objectDefinedNotNull(this._relationships[`_${parentIndex}`])) {\n            return this._relationships[`_${parentIndex}`];\n        } else {\n            return [];\n        }\n    }\n\n    public getChildRelationships(): TypedHash<number[]> {\n        return this._relationships;\n    }\n\n    /**\n     * Appends an action to the supplied IObjectPath, replacing placeholders\n     * \n     * @param op IObjectPath to which the action will be appended\n     * @param action The action to append\n     */\n    public appendAction(op: IObjectPath, action: string): this {\n\n        this.dirty();\n        op.actions.push(action);\n        return this;\n    }\n\n    /**\n     * Appends an action to the last IObjectPath in the collection\n     * \n     * @param action \n     */\n    public appendActionToLast(action: string): this {\n\n        return this.appendAction(this.last, action);\n    }\n\n    /**\n     * Creates a copy of this ObjectPathQueue\n     */\n    public clone(): ObjectPathQueue {\n        const clone = new ObjectPathQueue(this.toArray(), extend({}, this._relationships));\n        clone._contextIndex = this._contextIndex;\n        clone._siteIndex = this._siteIndex;\n        clone._webIndex = this._webIndex;\n        return clone;\n    }\n\n    /**\n     * Gets a copy of this instance's paths\n     */\n    public toArray(): IObjectPath[] {\n        return this._paths.slice(0);\n    }\n\n    /**\n     * The last IObjectPath instance added to this collection\n     */\n    public get last(): IObjectPath {\n\n        if (this._paths.length < 1) {\n            return null;\n        }\n\n        return this._paths[this.lastIndex];\n    }\n\n    /**\n     * Index of the last IObjectPath added to the queue\n     */\n    public get lastIndex(): number {\n        return this._paths.length - 1;\n    }\n\n    /**\n     * Gets the index of the current site in the queue\n     */\n    public get siteIndex(): number {\n\n        if (this._siteIndex < 0) {\n\n            // this needs to be here in case we create it\n            const contextIndex = this.contextIndex;\n\n            this._siteIndex = this.add(property(\"Site\",\n                // actions\n                objectPath()));\n\n            this.addChildRelationship(contextIndex, this._siteIndex);\n        }\n\n        return this._siteIndex;\n    }\n\n    /**\n     * Gets the index of the current web in the queue\n     */\n    public get webIndex(): number {\n\n        if (this._webIndex < 0) {\n\n            // this needs to be here in case we create it\n            const contextIndex = this.contextIndex;\n\n            this._webIndex = this.add(property(\"Web\",\n                // actions\n                objectPath()));\n\n            this.addChildRelationship(contextIndex, this._webIndex);\n        }\n\n        return this._webIndex;\n    }\n\n    /**\n     * Gets the index of the Current context in the queue, can be used to establish parent -> child rels\n     */\n    public get contextIndex(): number {\n        if (this._contextIndex < 0) {\n            this._contextIndex = this.add(staticProperty(\"Current\", \"{3747adcd-a3c3-41b9-bfab-4a64dd2f1e0a}\",\n                // actions\n                objectPath()));\n        }\n\n        return this._contextIndex;\n    }\n\n    public toBody(): string {\n\n        if (objectDefinedNotNull(this._xml)) {\n            return this._xml;\n        }\n\n        // create our xml payload\n        this._xml = writeObjectPathBody(this.toIndexedTree());\n\n        return this._xml;\n    }\n\n    /**\n     * Conducts the string replacements for id, parent id, and path id\n     * \n     * @returns The tree with all string replacements made\n     */\n    public toIndexedTree(): IObjectPath[] {\n\n        let builderIndex = -1;\n        let lastOpId = -1;\n        const idIndexMap: number[] = [];\n\n        return this.toArray().map((op, index, arr) => {\n\n            const opId = ++builderIndex;\n\n            // track the array index => opId relationship\n            idIndexMap.push(opId);\n\n            // do path replacements\n            op.path = opSetPathParamId(idIndexMap, opSetId(opId.toString(), op.path));\n\n            if (lastOpId >= 0) {\n                // if we have a parent do the replace\n                op.path = opSetParentId(lastOpId.toString(), op.path);\n            }\n\n            // rewrite actions with placeholders replaced\n            op.actions = op.actions.map(a => {\n                const actionId = ++builderIndex;\n                return opSetId(actionId.toString(), opSetPathId(opId.toString(), a));\n            });\n\n            // handle any specific child relationships\n            this.getChildRelationship(index).forEach(childIndex => {\n                // set the parent id for our non-immediate children, thus removing the token so it isn't overwritten\n                arr[childIndex].path = opSetParentId(opId.toString(), arr[childIndex].path);\n            });\n\n            // and remember our last object path id for the parent replace above\n            lastOpId = opId;\n\n            return op;\n        });\n    }\n\n    /**\n     * Dirties this queue clearing any cached data\n     */\n    protected dirty(): void {\n        this._xml = null;\n    }\n}\n","import { getAttrValueFromString, jsS, hOP } from \"@pnp/common\";\nimport { IObjectPath } from \"./objectpath\";\n\n/**\n * Used within the request pipeline to parse ProcessQuery results\n */\nexport class ProcessQueryParser<T = any> {\n\n    constructor(protected op: IObjectPath) { }\n\n    /**\n     * Parses the response checking for errors\n     * \n     * @param r Response object\n     */\n    public parse(r: Response): Promise<T> {\n\n        return r.text().then(t => {\n\n            if (!r.ok) {\n                throw Error(t);\n            }\n\n            try {\n                return JSON.parse(t);\n            } catch (e) {\n                // special case in ProcessQuery where we got an error back, but it is not in json format\n                throw Error(t);\n            }\n\n        }).then((parsed: any[]) => {\n\n            // here we need to check for an error body\n            if (parsed.length > 0 && hOP(parsed[0], \"ErrorInfo\") && parsed[0].ErrorInfo !== null) {\n                throw Error(jsS(parsed[0].ErrorInfo));\n            }\n\n            return this.findResult(parsed);\n        });\n    }\n\n    public findResult(json: any): Promise<T | null> {\n\n        for (let i = 0; i < this.op.actions.length; i++) {\n\n\n            const a = this.op.actions[i];\n\n            // let's see if the result is null based on the ObjectPath action, if it exists\n            // <ObjectPath Id=\"8\" ObjectPathId=\"7\" />\n            if (/^<ObjectPath /i.test(a)) {\n                const result = this.getParsedResultById<{ IsNull: boolean }>(json, parseInt(getAttrValueFromString(a, \"Id\"), 10));\n                if (!result || (result && result.IsNull)) {\n                    return Promise.resolve(null);\n                }\n            }\n\n            // let's see if we have a query result\n            // <Query Id=\"5\" ObjectPathId = \"3\" >\n            if (/^<Query /i.test(a)) {\n                const result = this.getParsedResultById(json, parseInt(getAttrValueFromString(a, \"Id\"), 10));\n\n                if (result && hOP(result, \"_Child_Items_\")) {\n                    // this is a collection result\n                    /* tslint:disable:no-string-literal */\n                    return Promise.resolve(result[\"_Child_Items_\"]);\n                    /* tslint:enable:no-string-literal */\n                } else {\n                    // this is an instance result\n                    return Promise.resolve(result);\n                }\n            }\n\n            // this is an invokeMethodAction so the last method action corresponds to our result\n            if (i === (this.op.actions.length - 1) && /^<Method /i.test(a)) {\n                return Promise.resolve(this.getParsedResultById(json, parseInt(getAttrValueFromString(a, \"Id\"), 10)));\n            }\n        }\n\n        // no result could be found so we are effectively returning void\n        // issue is we really don't know if we should be returning void (a method invocation with a void return) or\n        // if we just didn't find something above. We will let downstream things worry about that\n    }\n\n    /**\n     * Locates a result by ObjectPath id\n     * \n     * @param parsed the parsed JSON body from the response\n     * @param id The ObjectPath id whose result we want\n     */\n    protected getParsedResultById<R = any>(parsed: any[], id: number): R {\n\n        for (let i = 0; i < parsed.length; i++) {\n\n            if (parsed[i] === id) {\n                return parsed[i + 1];\n            }\n        }\n\n        return null;\n    }\n}\n","import { FetchOptions, combine, extend, getGUID, mergeHeaders, mergeOptions, objectDefinedNotNull, hOP, getHashCode } from \"@pnp/common\";\nimport { CachingOptions, ICachingOptions, ODataParser, Queryable, RequestContext } from \"@pnp/odata\";\nimport { SPHttpClient, toAbsoluteUrl } from \"@pnp/sp\";\nimport { IObjectPathBatch } from \"./batch\";\nimport { ObjectPathQueue } from \"./objectpath\";\nimport { methodAction, objectPath, objectProperties, opQuery } from \"./opactionbuilders\";\nimport { IMethodParamsBuilder, method, property } from \"./opbuilders\";\nimport { ProcessQueryParser } from \"./parsers\";\n\n\nexport interface IClientSvcQueryable {\n    select(...selects: string[]): this;\n    usingCaching(options?: ICachingOptions): this;\n    inBatch(batch: IObjectPathBatch): this;\n}\n\nexport interface ClientSvcQueryableConstructor<T> {\n    new(baseUrl: string | ClientSvcQueryable, objectPaths?: ObjectPathQueue): T;\n}\n\nconst ProcessQueryPath = \"_vti_bin/client.svc/ProcessQuery\";\n\nexport class ClientSvcQueryable<GetType = any> extends Queryable<GetType> implements IClientSvcQueryable {\n\n    /**\n     * Collection of select fields\n     */\n    protected _selects: string[];\n\n    /**\n     * Tracks the batch of which this query may be part\n     */\n    protected _batch: IObjectPathBatch;\n\n    constructor(parent: ClientSvcQueryable | string = \"\", protected _objectPaths: ObjectPathQueue | null = null) {\n        super();\n\n        this._selects = [];\n\n        if (typeof parent === \"string\") {\n\n            // we assume the parent here is an absolute url to a web\n            this._parentUrl = parent;\n            this._url = combine(parent.replace(ProcessQueryPath, \"\"), ProcessQueryPath);\n            if (!objectDefinedNotNull(this._objectPaths)) {\n                this._objectPaths = new ObjectPathQueue();\n            }\n\n        } else {\n            this._parentUrl = parent._parentUrl;\n            this._url = combine(parent._parentUrl, ProcessQueryPath);\n            if (!objectDefinedNotNull(_objectPaths)) {\n                this._objectPaths = parent._objectPaths.clone();\n            }\n            this.configureFrom(parent);\n        }\n    }\n\n    /**\n     * Choose which fields to return\n     *\n     * @param selects One or more fields to return\n     */\n    public select(...selects: string[]): this {\n        [].push.apply(this._selects, selects);\n        return this;\n    }\n\n    /**\n     * Adds this query to the supplied batch\n     *\n     * @example\n     * ```\n     *\n     * let b = pnp.sp.createBatch();\n     * pnp.sp.web.inBatch(b).get().then(...);\n     * b.execute().then(...)\n     * ```\n     */\n    public inBatch(batch: IObjectPathBatch): this {\n\n        if (this.batch !== null) {\n            throw Error(\"This query is already part of a batch.\");\n        }\n\n        this._batch = batch;\n\n        return this;\n    }\n\n    /**\n     * Gets the full url with query information\n     *\n     */\n    public toUrlAndQuery(): string {\n        return `${super.toUrl()}?${Array.from(this.query).map((v: [string, string]) => v[0] + \"=\" + v[1]).join(\"&\")}`;\n    }\n\n    protected getSelects(): string[] {\n        return objectDefinedNotNull(this._selects) ? this._selects : [];\n    }\n\n    /**\n     * Gets a child object based on this instance's paths and the supplied paramters\n     * \n     * @param factory Instance factory of the child type\n     * @param methodName Name of the method used to load the child\n     * @param params Parameters required by the method to load the child\n     */\n    protected getChild<T>(factory: ClientSvcQueryableConstructor<T>, methodName: string, params: IMethodParamsBuilder | null): T {\n\n        const objectPaths = this._objectPaths.clone();\n\n        objectPaths.add(method(methodName, params,\n            // actions\n            objectPath()));\n\n        return new factory(this, objectPaths);\n    }\n\n    /**\n     * Gets a property of the current instance\n     * \n     * @param factory Instance factory of the child type\n     * @param propertyName Name of the property to load\n     */\n    protected getChildProperty<T>(factory: ClientSvcQueryableConstructor<T>, propertyName: string): T {\n\n        const objectPaths = this._objectPaths.clone();\n\n        objectPaths.add(property(propertyName));\n\n        return new factory(this, objectPaths);\n    }\n\n    /**\n     * Sends a request\n     * \n     * @param op \n     * @param options \n     * @param parser \n     */\n    protected send<T = any>(objectPaths: ObjectPathQueue, options: FetchOptions = {}, parser: ODataParser<T> = null): Promise<T> {\n\n        if (!objectDefinedNotNull(parser)) {\n            // we assume here that we want to return for this index path\n            parser = new ProcessQueryParser(objectPaths.last);\n        }\n\n        if (this.hasBatch) {\n\n            // this is using the options variable to pass some extra information downstream to the batch\n            options = extend(options, {\n                clientsvc_ObjectPaths: objectPaths.clone(),\n            });\n\n        } else {\n\n            if (!hOP(options, \"body\")) {\n                options = extend(options, {\n                    body: objectPaths.toBody(),\n                });\n            }\n        }\n\n        return super.postCore(options, parser);\n    }\n\n    /**\n     * Sends the request, merging the result data with a new instance of factory\n     */\n    protected sendGet<DataType, FactoryType>(factory: ClientSvcQueryableConstructor<FactoryType>): Promise<(DataType & FactoryType)> {\n\n        const ops = this._objectPaths.clone().appendActionToLast(opQuery(this.getSelects()));\n\n        return this.send<DataType>(ops).then(r => extend(new factory(this), r));\n    }\n\n    /**\n     * Sends the request, merging the result data array with a new instances of factory\n     */\n    protected sendGetCollection<DataType, FactoryType>(factory: (d: DataType) => FactoryType): Promise<(DataType & FactoryType)[]> {\n\n        const ops = this._objectPaths.clone().appendActionToLast(opQuery([], this.getSelects()));\n\n        return this.send<DataType[]>(ops).then(r => r.map(d => extend(factory(d), d)));\n    }\n\n    /**\n     * Invokes the specified method on the server and returns the result\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param actions Any additional actions to execute in addition to the method invocation (set property for example)\n     */\n    protected invokeMethod<T>(methodName: string, params: IMethodParamsBuilder | null = null, ...actions: string[]): Promise<T> {\n        return this.invokeMethodImpl(methodName, params, actions, opQuery([], null));\n    }\n\n    /**\n     * Invokes a method action that returns a single result and does not have an associated query (ex: GetDescription on Term)\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param actions Any additional actions to execute in addition to the method invocation (set property for example)\n     */\n    protected invokeMethodAction<T>(methodName: string, params: IMethodParamsBuilder | null = null, ...actions: string[]): Promise<T> {\n        return this.invokeMethodImpl(methodName, params, actions, null, true);\n    }\n\n    /**\n     * Invokes the specified non-query method on the server\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param actions Any additional actions to execute in addition to the method invocation (set property for example)\n     */\n    protected invokeNonQuery(methodName: string, params: IMethodParamsBuilder | null = null, ...actions: string[]): Promise<void> {\n        // by definition we are not returning anything from these calls so we should not be caching the results\n        this._useCaching = false;\n        return this.invokeMethodImpl<void>(methodName, params, actions, null, true);\n    }\n\n    /**\n     * Invokes the specified method on the server and returns the resulting collection\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param actions Any additional actions to execute in addition to the method invocation (set property for example)\n     */\n    protected invokeMethodCollection<T>(methodName: string, params: IMethodParamsBuilder | null = null, ...actions: string[]): Promise<T> {\n        return this.invokeMethodImpl(methodName, params, actions, opQuery([], []));\n    }\n\n    /**\n     * Updates this instance, returning a copy merged with the updated data after the update\n     * \n     * @param properties Plain object of the properties and values to update\n     * @param factory Factory method use to create a new instance of FactoryType\n     */\n    protected invokeUpdate<DataType, FactoryType>(properties: any, factory: ClientSvcQueryableConstructor<FactoryType>): Promise<DataType & FactoryType> {\n\n        const ops = this._objectPaths.clone();\n        // append setting all the properties to this instance\n        objectProperties(properties).map(a => ops.appendActionToLast(a));\n        ops.appendActionToLast(opQuery([], null));\n        return this.send<DataType>(ops).then(r => extend(new factory(this), r));\n    }\n\n    /**\n     * Converts the current instance to a request context\n     *\n     * @param verb The request verb\n     * @param options The set of supplied request options\n     * @param parser The supplied ODataParser instance\n     * @param pipeline Optional request processing pipeline\n     */\n    protected toRequestContext<T>(\n        verb: string,\n        options: FetchOptions,\n        parser: ODataParser<T>,\n        pipeline: Array<(c: RequestContext<T>) => Promise<RequestContext<T>>>): Promise<RequestContext<T>> {\n\n        return toAbsoluteUrl(this.toUrlAndQuery()).then(url => {\n\n            mergeOptions(options, this._options);\n\n            const headers = new Headers();\n\n            mergeHeaders(headers, options.headers);\n\n            mergeHeaders(headers, {\n                \"accept\": \"*/*\",\n                \"content-type\": \"text/xml\",\n            });\n\n            options = extend(options, { headers });\n\n            // we need to do some special cache handling to ensure we have a good key\n            if (this._useCaching) {\n\n                // because all the requests use the same url they would collide in the cache we use a special key\n                const cacheKey = `PnPjs.ProcessQueryClient(${getHashCode(this._objectPaths.toBody())})`;\n\n                if (objectDefinedNotNull(this._cachingOptions)) {\n                    // if our key ends in the ProcessQuery url we overwrite it\n                    if (/\\/client\\.svc\\/ProcessQuery\\?$/i.test(this._cachingOptions.key)) {\n                        this._cachingOptions.key = cacheKey;\n                    }\n                } else {\n                    this._cachingOptions = new CachingOptions(cacheKey);\n                }\n            }\n\n            const dependencyDispose = this.hasBatch ? this.addBatchDependency() : () => { return; };\n\n            // build our request context\n            const context: RequestContext<T> = {\n                batch: this.batch,\n                batchDependency: dependencyDispose,\n                cachingOptions: this._cachingOptions,\n                clientFactory: () => new SPHttpClient(),\n                isBatched: this.hasBatch,\n                isCached: this._useCaching,\n                options: options,\n                parser: parser,\n                pipeline: pipeline,\n                requestAbsoluteUrl: url,\n                requestId: getGUID(),\n                verb: verb,\n            };\n\n            return context;\n        });\n    }\n\n    /**\n     * Blocks a batch call from occuring, MUST be cleared by calling the returned function\n    */\n    protected addBatchDependency(): () => void {\n        if (this._batch !== null) {\n            return this._batch.addDependency();\n        }\n\n        return () => null;\n    }\n\n    /**\n     * Indicates if the current query has a batch associated\n     *\n     */\n    protected get hasBatch(): boolean {\n        return objectDefinedNotNull(this._batch);\n    }\n\n    /**\n     * The batch currently associated with this query or null\n     *\n     */\n    protected get batch(): IObjectPathBatch {\n        return this.hasBatch ? this._batch : null;\n    }\n\n    /**\n     * Executes the actual invoke method call\n     * \n     * @param methodName Name of the method to invoke\n     * @param params Method parameters\n     * @param queryAction Specifies the query action to take\n     */\n    private invokeMethodImpl<T>(methodName: string, params: IMethodParamsBuilder | null, actions: string[], queryAction: string, isAction = false): Promise<T> {\n\n        const ops = this._objectPaths.clone();\n\n        if (isAction) {\n            ops.appendActionToLast(methodAction(methodName, params));\n        } else {\n            ops.add(method(methodName, params, ...[objectPath(), ...actions, queryAction]));\n        }\n\n        return this.send<T>(ops);\n    }\n}\n","import { LogLevel, Logger } from \"@pnp/logging\";\nimport { CachingParserWrapper, ODataBatch, ODataBatchRequestInfo } from \"@pnp/odata\";\nimport { ClientSvcQueryable } from \"./clintsvcqueryable\";\nimport { ObjectPath, ObjectPathQueue, opSetId, opSetParentId, opSetPathId, opSetPathParamId } from \"./objectpath\";\nimport { objectPath } from \"./opactionbuilders\";\nimport { staticMethod } from \"./opbuilders\";\nimport { ProcessQueryParser } from \"./parsers\";\nimport { writeObjectPathBody } from \"./utils\";\n\nexport interface IObjectPathBatch extends ODataBatch {\n\n}\n\n/**\n * Implements ODataBatch for use with the ObjectPath framework\n */\nexport class ObjectPathBatch extends ODataBatch implements IObjectPathBatch {\n\n    constructor(protected parentUrl: string, _batchId?: string) {\n        super(_batchId);\n    }\n\n    protected executeImpl(): Promise<void> {\n\n        // if we don't have any requests, don't bother sending anything\n        // this could be due to caching further upstream, or just an empty batch\n        if (this.requests.length < 1) {\n            Logger.write(`Resolving empty batch.`, LogLevel.Info);\n            return Promise.resolve();\n        }\n\n        const executor = new BatchExecutor(this.parentUrl, this.batchId);\n        executor.appendRequests(this.requests);\n        return executor.execute();\n    }\n}\n\nclass BatchExecutor extends ClientSvcQueryable {\n\n    private _builderIndex: number;\n    private _requests: ODataBatchRequestInfo[];\n\n    constructor(parentUrl: string, public batchId: string) {\n        super(parentUrl);\n\n        this._requests = [];\n        this._builderIndex = 1;\n\n        // we add our session object path and hard code in the IDs so we can reference it\n        const method = staticMethod(\"GetTaxonomySession\", \"{981cbc68-9edc-4f8d-872f-71146fcbb84f}\");\n        method.path = opSetId(\"0\", method.path);\n        method.actions.push(opSetId(\"1\", opSetPathId(\"0\", objectPath())));\n\n        this._objectPaths.add(method);\n    }\n\n    public appendRequests(requests: ODataBatchRequestInfo[]): void {\n\n        requests.forEach(request => {\n\n            // grab the special property we added to options when we created the batch info\n            const pathQueue: ObjectPathQueue = (<any>request.options).clientsvc_ObjectPaths;\n\n            let paths = pathQueue.toArray();\n\n            // getChildRelationships\n            if (paths.length < 0) {\n                return;\n            }\n\n            let indexMappingFunction = (n: number) => n;\n\n            if (/GetTaxonomySession/i.test(paths[0].path)) {\n\n                // drop the first thing as it is a get session object path, which we add once for the entire batch\n                paths = paths.slice(1);\n\n                // replace the next item's parent id with 0, which will be the id of the session call at the root of this request\n                paths[0].path = opSetParentId(\"0\", paths[0].path);\n\n                indexMappingFunction = (n: number) => n - 1;\n            }\n\n            let lastOpId = -1;\n            const idIndexMap: number[] = [];\n\n            paths.map((op, index, arr) => {\n\n                // rewrite the path string\n                const opId = ++this._builderIndex;\n\n                // track the array index => opId relationship\n                idIndexMap.push(opId);\n\n                let path = opSetPathParamId(idIndexMap, opSetId(opId.toString(), op.path), indexMappingFunction);\n                if (lastOpId >= 0) {\n                    path = opSetParentId(lastOpId.toString(), path);\n                }\n\n                // rewrite actions with placeholders replaced\n                const opActions = op.actions.map(a => {\n                    const actionId = ++this._builderIndex;\n                    return opSetId(actionId.toString(), opSetPathId(opId.toString(), a));\n                });\n\n                // handle any specific child relationships\n                // the childIndex is reduced by 1 because we are removing the Session Path\n                pathQueue.getChildRelationship(index + 1).map(i => i - 1).forEach(childIndex => {\n                    // set the parent id for our non-immediate children\n                    arr[childIndex].path = opSetParentId(opId.toString(), arr[childIndex].path);\n                });\n\n                // and remember our last object path id for the parent replace above\n                lastOpId = opId;\n\n                // return our now substituted path and actions as a new object path instance\n                return new ObjectPath(path, opActions);\n\n            }).forEach(op => this._objectPaths.add(op));\n\n            // get this once\n            const obPaths = this._objectPaths.toArray();\n\n            // create a new parser to handle finding the result based on the path\n            const parser = new ProcessQueryParser(obPaths[obPaths.length - 1]);\n\n            if (request.parser instanceof CachingParserWrapper) {\n                // handle special case of caching\n                request.parser = new ProcessQueryCachingParserWrapper(parser, request.parser);\n            } else {\n                request.parser = parser;\n            }\n\n            // add the request to our batch requests\n            this._requests.push(request);\n\n            // remove the temp property\n            delete (<any>request.options).clientsvc_ObjectPaths;\n        });\n    }\n\n    public execute(): Promise<void> {\n\n        Logger.write(`[${this.batchId}] (${(new Date()).getTime()}) Executing batch with ${this._requests.length} requests.`, LogLevel.Info);\n\n        // create our request body from all the merged object paths\n        const options = {\n            body: writeObjectPathBody(this._objectPaths.toArray()),\n        };\n\n        Logger.write(`[${this.batchId}] (${(new Date()).getTime()}) Sending batch request.`, LogLevel.Info);\n\n        // send the batch\n        return super.postCore(options, new BatchParser()).then((rawResponse: any) => {\n\n            Logger.write(`[${this.batchId}] (${(new Date()).getTime()}) Resolving batched requests.`, LogLevel.Info);\n\n            return this._requests.reduce((chain, request) => {\n\n                Logger.write(`[${request.id}] (${(new Date()).getTime()}) Resolving request in batch ${this.batchId}.`, LogLevel.Info);\n\n                return chain.then(_ => (<ProcessQueryParser>request.parser).findResult(rawResponse).then(request.resolve).catch(request.reject));\n\n            }, Promise.resolve());\n        });\n    }\n}\n\n/**\n * Used to return the raw results from parsing the batch\n */\nclass BatchParser<T = any> extends ProcessQueryParser<T> {\n\n    constructor() {\n        super(null);\n    }\n\n    public findResult(json: any): Promise<T> {\n        // we leave it to the individual request parsers to find their results in the raw json body\n        return json;\n    }\n}\n\n/**\n * Handles processing batched results that are also cached\n */\nclass ProcessQueryCachingParserWrapper<T> extends CachingParserWrapper<T> {\n\n    constructor(parser: ProcessQueryParser, wrapper: CachingParserWrapper<T>) {\n        super(parser, wrapper.cacheOptions);\n    }\n\n    public findResult(json: any): Promise<T> {\n        return (<any>this.parser).findResult(json).then((d: any) => this.cacheData(d));\n    }\n}\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","objectPath","opQuery","selectProperties","childSelectProperties","builder","push","length","apply","map","join","setProperty","name","type","value","methodAction","params","arrParams","toArray","objectProperties","o","getOwnPropertyNames","property","_i","actions","ObjectPath","staticMethod","typeId","staticProperty","_p","MethodParams","initValues","a","toString","inputIndex","method","writeObjectPathBody","objectPaths","paths","forEach","op","path","id","replaceAfter","opSetId","xml","replace","opSetPathId","opSetParentId","opSetPathParamId","indexMapper","n","matches","exec","i","index","parseInt","regex","RegExp","_paths","_relationships","ObjectPathQueue","dirty","lastIndex","parentIndex","childIndex","objectDefinedNotNull","action","appendAction","last","clone","extend","_contextIndex","_siteIndex","_webIndex","slice","contextIndex","add","addChildRelationship","_xml","toIndexedTree","builderIndex","lastOpId","idIndexMap","arr","opId","_this","getChildRelationship","ProcessQueryParser","r","text","then","t","ok","Error","JSON","parse","e","parsed","hOP","ErrorInfo","jsS","findResult","json","result","test","getParsedResultById","getAttrValueFromString","IsNull","Promise","resolve","ProcessQueryPath","parent","_objectPaths","_super","_selects","_parentUrl","_url","combine","configureFrom","tslib_1.__extends","ClientSvcQueryable","selects","batch","_batch","toUrl","from","query","v","factory","methodName","propertyName","options","parser","hasBatch","clientsvc_ObjectPaths","body","toBody","postCore","ops","appendActionToLast","getSelects","send","invokeMethodImpl","_useCaching","properties","verb","pipeline","toAbsoluteUrl","toUrlAndQuery","url","mergeOptions","_options","headers","Headers","mergeHeaders","accept","content-type","cacheKey","getHashCode","_cachingOptions","key","CachingOptions","dependencyDispose","addBatchDependency","batchDependency","cachingOptions","clientFactory","SPHttpClient","isBatched","isCached","requestAbsoluteUrl","requestId","getGUID","addDependency","queryAction","isAction","Queryable","parentUrl","_batchId","ObjectPathBatch","requests","Logger","write","executor","BatchExecutor","batchId","appendRequests","execute","ODataBatch","_requests","_builderIndex","request","pathQueue","indexMappingFunction","opActions","obPaths","CachingParserWrapper","ProcessQueryCachingParserWrapper","Date","getTime","BatchParser","rawResponse","reduce","chain","_","catch","reject","wrapper","cacheOptions","cacheData"],"mappings":"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"}